<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chou&#39;s blog</title>
  
  
  <link href="https://aachou.github.io/atom.xml" rel="self"/>
  
  <link href="https://aachou.github.io/"/>
  <updated>2024-01-18T02:09:49.000Z</updated>
  <id>https://aachou.github.io/</id>
  
  <author>
    <name>Aaron Chou</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringBoot原理解析</title>
    <link href="https://aachou.github.io/2024/0118/"/>
    <id>https://aachou.github.io/2024/0118/</id>
    <published>2024-01-18T01:16:09.000Z</published>
    <updated>2024-01-18T02:09:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>springboot是一种简化springweb开发的框架，类似springmvc，他提供各种默认配置，达到开箱即用、敏捷开发的效果。本文主要介绍springboot的依赖管理、自动配置、web开发、thymeleaf与视图解析、拦截器、文件上传、异常处理、web原生组件注入、整合数据源Druid与Redis、Junit单元测试、spring Acutuator性能监控、高级特性与springboot启动原理。<span id="more"></span></p><h4 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h4><h5 id="父项目依赖"><a href="#父项目依赖" class="headerlink" title="父项目依赖"></a>父项目依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>作用：依赖管理及版本管理。</p><p>父项目的父项目：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中默认引入了许多依赖，自动版本仲裁无需关注版本，我们可以不用配置某些依赖的版本，但是第三方需要。根据maven就近原则，默认使用本项目pom.xml配置好的依赖，若需要修改依赖版本号：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">mysql.version</span>&gt;</span>5.2.41<span class="tag">&lt;/<span class="name">mysql.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="starter场景启动器"><a href="#starter场景启动器" class="headerlink" title="starter场景启动器"></a>starter场景启动器</h5><p>starter也叫依赖管理器，spring-boot-starter-*是用来开发某一场景的一组依赖，引入starter就导入了相关的开发依赖。</p><p>starter基本依赖为pring-boot-starter，web开发还需要引入spring-boot-starter-json、spring-boot-starter-tomcat、spring-web、spring-webmvc。</p><h4 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h4><p>启动时加载所有自动配置和组件，条件装配按需配置。自动配置tomcat、自动配置springMVC、自动配置web常见功能、自动扫描springboot主程序所在包及子包下的bean组件。</p><p><code>@SpringBootApplication</code>注解相当于<code>@SpringBootConfiguration</code>、<code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code>注解。</p><p>自动配置按需加载，pom.xml引入依赖后该依赖的自动配置才会生效。配置会映射到某个配置类中，springboot默认配置会映射到名为xxProperties.class配置类中，配置类也是组件。</p><p><code>@Configuration</code>声明配置类，参数proxyBeanMethods默认为true，开启代理，即使用cglib生成代理对象，只会在容器中生成一个组件示例。若为false，则不会生成代理对象，每次调用组件都会创建一个实例对象。</p><p><code>@Bean</code>给容器中添加组件，以类名或方法名做id，返回类型为组件类型，返回值即组件在容器中的示例。<code>@Bean</code>注解的方法名默认作为对象的名字，也可以用name属性定义对象的名字。<code>@bean</code>分为两种模式,一种是Lite Mode(轻量模式),这种模式下被<code>@bean</code>定义的方法需要在<code>@Component</code>下或者原生类下,效果类似于<code>@Component</code>注册在类上的效果。<code>@Configuration</code>下的<code>@bean</code>被称为是Full mode，bean的创建是通过cglib代理生成的被<code>@Configuration</code>定义的类的增强类，因为<code>@Configuration</code>定义的类的bean，默认都是被Spring通过Cglib增强的子类。</p><p><code>@Bean</code>注解参数：</p><p>value：定义bean在IOC容器中的id属性。<br>name ：定义bean在IOC容器中的id属性。<br>autowire：装配方式<br>Autowire.NO (默认设置)<br>Autowire.BY_NAME<br>Autowire.BY_TYPE<br>initMethod：指定初始化方法 相当于xml文件中 init-method<br>destroyMethod：指定销毁的方法 相当于xml文件中 destroy-method</p><h5 id="Bean和-Component的区别："><a href="#Bean和-Component的区别：" class="headerlink" title="@Bean和@Component的区别："></a><u><code>@Bean</code>和<code>@Component</code>的区别：</u></h5><p><code>@Bean</code>和<code>@Component</code>都是将Spring Bean添加到Spring Context 中。</p><p>1）作用域</p><p><code>@Component</code>注解表明一个类会作为组件类，并告知 Spring 要为这个类创建 bean。<code>@Bean</code>不能作用在类上，只能作用于方法。</p><p><code>@Bean</code>注解告诉 Spring 这个方法将会返回一个对象，这个对象要注册为 Spring 应用上下文中的 bean。要获取这个 bean 的时候，Spring 要按照这种方式、去获取这个 bean。</p><p>2）注册方式</p><p><code>@Component</code>注解表明一个类会作为组件类，并告知 Spring 要为这个类创建 bean。<code>@Bean</code>注解告诉 Spring 这个方法将会返回一个对象，这个对象要注册为 Spring 应用上下文中的 bean。通常方法体中包含了最终产生bean实例的逻辑。</p><p>当我们引用第三方库中的类需要装配到 Spring 容器时，则只能通过<code>@Bean</code>来实现。</p><p>3）使用方式</p><p><code>@Component</code>（<code>@Controller</code>、<code>@Service</code>、<code>@Repository</code>）通常是通过类路径扫描来侦测及自动装配到 Spring 容器中。<code>@Bean</code>一般结合<code>@Configuration</code>一起使用，也可以配置在类的方法中。</p><h5 id="容器功能注解"><a href="#容器功能注解" class="headerlink" title="容器功能注解"></a>容器功能注解</h5><p>组件添加：</p><p>1、@Configuration</p><p>2、@Bean、@Component、@Controller、@Service</p><p>3、@ComponentScan</p><p>4、@Conditional</p><p>原生配置文件导入：</p><p>@ImportResource</p><p>配置绑定：</p><p>1、@ConfigurationProperties</p><p>2、@EnableConfigurationProperties+@ConfigurationProperties</p><p>3、@Component+@ConfigurationProperties</p><p><code>@Import(&#123;xx.class,xx.class&#125;)</code>，通过类型在容器中创建组件实例，组件名为全类名。</p><p><code>@Conditional</code>，条件装配注解，满足指定条件进行组件注册。参数value为一个class泛型数组。@ConditionalOnBean(name &#x3D; “xxx”)，当ioc容器中存在该对象时，为该组件注册实例。</p><p><code>@ImportResource(&quot;classpath:beans.xml&quot;)</code>，导入spring原生配置文件，支持xml配置。</p><p><code>@EnableConfigurationProperties(xx.class)</code>，为xx.class开启配置属性绑定。</p><p><code>@AutoConfigurationPackage</code>，自动配置包原则，利用Register批量地将主程序所在包下的所有组件批量注册进容器。</p><p><code>@ConfigurationProperties(prefix=&quot;spring&quot;)</code>，为核心配置文件中的属性绑定前缀，在映射的实体类上添加注解，表示将该类注册成bean并配置属性值。</p><h4 id="简化开发"><a href="#简化开发" class="headerlink" title="简化开发"></a>简化开发</h4><p><u>lombok开发</u></p><p>1、在maven项目的pom.xml文件中添加lombok依赖</p><p>2、执行maven导入依赖</p><p>3、添加@Data注解，免去get和set方法</p><p>4、添加@ToString重写toString方法。</p><p><u>spring Initailizr开发</u>，再idea中使用spring Initailizr创建初始化项目，勾选依赖配置和版本，maven自动导入，实现快速初始化项目。</p><p><u>yaml</u>（yaml ain’t markup language）配置，key-value写法，大小写敏感，缩进表层级，#为注释。字符串值用单引号或双引号包围，单引号将\n作为字符串输出，双引号将\n作为换行输出。</p><p>注：标记语言是一种将标记以及文本相关的其他信息结合起来，展现出关于文档结构和数据处理细节的文字编码。</p><p><u>spring-boot-configuration-processor配置处理器</u>，显示配置提示信息，添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--在打包项目的时候排除以下简化开发的插件--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">exclude</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="web场景开发"><a href="#web场景开发" class="headerlink" title="web场景开发"></a>web场景开发</h4><p>src&#x2F;main&#x2F;java；src&#x2F;main&#x2F;resources都是classes类路径的根路径，下面的所有文件都在该类路径下。当请求来时，java先动态处理，无法处理后寻找静态资源。默认的静态资源路径有[&#x2F;static，&#x2F;resources，&#x2F;META-INF，&#x2F;public]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] CLASSPATH_RESOURCE_LOCATIONS = &#123; <span class="string">&quot;classpath:/META-INF/resources/&quot;</span>,<span class="string">&quot;classpath:/resources/&quot;</span>, <span class="string">&quot;classpath:/static/&quot;</span>, <span class="string">&quot;classpath:/public/&quot;</span> &#125;;</span><br></pre></td></tr></table></figure><p>欢迎页处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">WelcomePageHandlerMapping(TemplateAvailabilityProviders templateAvailabilityProviders,</span><br><span class="line">ApplicationContext applicationContext, Optional&lt;Resource&gt; welcomePage, String staticPathPattern) &#123;</span><br><span class="line"><span class="keyword">if</span> (welcomePage.isPresent() &amp;&amp; <span class="string">&quot;/**&quot;</span>.equals(staticPathPattern)) &#123;</span><br><span class="line">        <span class="comment">//要用欢迎页功能，必须是/**</span></span><br><span class="line">logger.info(<span class="string">&quot;Adding welcome page: &quot;</span> + welcomePage.get());</span><br><span class="line">setRootViewName(<span class="string">&quot;forward:index.html&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (welcomeTemplateExists(templateAvailabilityProviders, applicationContext)) &#123;</span><br><span class="line">        <span class="comment">// 调用Controller  /index</span></span><br><span class="line">logger.info(<span class="string">&quot;Adding welcome page template: index&quot;</span>);</span><br><span class="line">setRootViewName(<span class="string">&quot;index&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="请求处理"><a href="#请求处理" class="headerlink" title="请求处理"></a>请求处理</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/user&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;_method&quot;</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">value</span>=<span class="string">&quot;delete&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;delete提交&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>核心Filter：HiddenHttpMethodFilter；用法： 表单method&#x3D;post，隐藏域 _method&#x3D;put，SpringBoot中手动开启。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">hiddenmethod:</span></span><br><span class="line">      <span class="attr">filter:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span>   <span class="comment">#开启页面表单的Rest功能</span></span><br></pre></td></tr></table></figure><p>设置自定义的methodFilter，编写webconfig配置类，创建filter对象，调用HiddenHttpMethodFilter的setMethodParam方法。</p><p><strong>Rest原理</strong></p><ul><li><p>表单提交会带上<code>_method=PUT</code></p></li><li><p>请求过来被<code>HiddenHttpMethodFilter</code>拦截</p></li><li><p>请求是否正常，并且是POST</p></li><li><p>获取到<code>_method</code>的值。</p><ul><li>兼容以下请求；PUT、DELETE、PATCH</li><li>原生request（post），包装模式requesWrapper重写了getMethod方法，返回的是传入的值。</li><li>过滤器链放行的时候用wrapper。以后的方法调用getMethod是调用requesWrapper。</li></ul></li></ul><p>Rest使用客户端工具，PostMan直接发送Put、delete等方式请求，无需Filter。</p><p><u>请求映射原理：</u></p><p>SpringMVC功能分析都从 org.springframework.web.servlet.DispatcherServlet-&gt;doDispatch(）</p><p><code>RequestMappingHandlerMapping</code>：保存了所有<code>@RequestMapping</code>和handler的映射规则。</p><p>所有的请求映射都在HandlerMapping中。</p><ul><li>SpringBoot自动配置欢迎页的 WelcomePageHandlerMapping ，访问 &#x2F;能访问到index.html</li><li>SpringBoot自动配置了默认的RequestMappingHandlerMapping</li><li>请求进来，挨个尝试所有的HandlerMapping看是否有请求信息。如果有就找到这个请求对应的handler，如果没有就是下一个 HandlerMapping。</li></ul><p><strong>基本注解：</strong></p><p>路径变量<code>@PathVariable</code>、获取请求头<code>@RequestHeader</code>、模型属性<code>@ModelAttribute</code>、声明请求参数<code>@RequestParam</code>、获取post请求体<code>@RequestBody</code>、声明请求属性<code>@RequestAttribute</code>、矩阵变量<code>@MatrixVariable</code>、获取cookie值<code>@CookieValue</code>、请求处理映射路径<code>@RequestMapping</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(<span class="meta">@RequestParam(value = &quot;name&quot;, defaultValue = &quot;World&quot;)</span> String name)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> String.format(<span class="string">&quot;Hello %s!&quot;</span>, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Servlet API：</strong></p><p>WebRequest、ServletRequest、MultipartRequest、 HttpSession、javax.servlet.http.PushBuilder、Principal、InputStream、Reader、HttpMethod、Locale、TimeZone、ZoneId。</p><p><strong>复杂参数</strong>：</p><p><strong>Map</strong>、<strong>Model</strong>（map、model里面的数据会被放在request的请求域  request.setAttribute）、Errors&#x2F;BindingResult、RedirectAttributes（ 重定向携带数据）、<strong>ServletResponse（response）</strong>、SessionStatus、UriComponentsBuilder、ServletUriComponentsBuilder</p><p><strong>自定义对象参数：</strong></p><p>可以自动类型转换与格式化，可以级联封装</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123; </span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Pet pet; </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>参数处理原理</strong></p><ul><li>HandlerMapping中找到能处理请求的Handler（Controller.method()）</li><li>为当前Handler 找一个适配器 HandlerAdapter； RequestMappingHandlerAdapter</li><li>适配器执行目标方法并确定方法参数的每一个值</li></ul><p><strong>参数解析器-HandlerMethodArgumentResolver</strong></p><p>确定将要执行的目标方法的每一个参数的值是什么，SpringMVC目标方法能写多少种参数类型。取决于参数解析器。</p><h5 id="响应请求"><a href="#响应请求" class="headerlink" title="响应请求"></a>响应请求</h5><p> 响应JSON ， jackson+@ResponseBody（返回数据不返回页面视图）</p><p>SpringMVC到底支持以下返回值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ModelAndView</span><br><span class="line">Model</span><br><span class="line">View</span><br><span class="line">ResponseEntity </span><br><span class="line">ResponseBodyEmitter</span><br><span class="line">StreamingResponseBody</span><br><span class="line">HttpEntity</span><br><span class="line">HttpHeaders</span><br><span class="line">Callable</span><br><span class="line">DeferredResult</span><br><span class="line">ListenableFuture</span><br><span class="line">CompletionStage</span><br><span class="line">WebAsyncTask</span><br><span class="line">@ResponseBody---&gt; RequestResponseBodyMethodProcessor；</span><br></pre></td></tr></table></figure><p><strong>返回值解析器原理</strong></p><ul><li><p>返回值处理器判断是否支持这种类型返回值 supportsReturnType</p></li><li><p>返回值处理器调用 handleReturnValue 进行处理</p></li><li><p>RequestResponseBodyMethodProcessor 可以处理返回值标了@ResponseBody 注解的</p></li><li><p>底层利用 MessageConverters 进行处理 ，将数据写为json</p></li><li><p>1、内容协商（浏览器默认会以请求头的方式告诉服务器他能接受什么样的内容类型）</p><p>2、服务器最终根据自己自身的能力，决定服务器能生产出什么样内容类型的数据，</p><p>3、SpringMVC会挨个遍历所有容器底层的 HttpMessageConverter ，看谁能处理</p></li><li><p>得到MappingJackson2HttpMessageConverter可以将对象写为json</p></li></ul><p>根据客户端接收能力不同，返回不同媒体类型的数据，只需要改变请求头中Accept字段。Http协议中规定的，告诉服务器本客户端可以接收的数据类型。</p><p><u>导入了jackson处理xml的包</u>，xml的converter就会自动进来:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-dataformat-xml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><u>开启浏览器参数方式内容协商功能:</u></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">contentnegotiation:</span></span><br><span class="line">      <span class="attr">favor-parameter:</span> <span class="literal">true</span>  </span><br><span class="line"><span class="comment">#开启基于请求参数内容协商策略</span></span><br></pre></td></tr></table></figure><p><strong>内容协商原理</strong></p><p>1、判断当前响应头中是否已经有确定的媒体类型MediaType。</p><p>2、获取客户端支持接收的内容类型。（获取客户端Accept请求头字段）。</p><p>​    contentNegotiationManager内容协商管理器两种内容协商策略：</p><p>​（1）ParameterContentNegotiationStrategy 基于format参数(mediaType有json;xml)</p><p>​（2）HeaderContentNegotiationStrategy  <u>默认</u>基于请求头(mediaType为xml)</p><p>3、遍历循环所有当前系统的 MessageConverter，看谁支持操作这个对象。</p><p>4、找到支持操作Person的converter，把converter支持的媒体类型统计出来。</p><p>5、客户端需要【application&#x2F;xml】，服务端能力【10种、json、xml】。</p><p>6、进行内容协商的最佳匹配媒体类型。</p><p>7、用支持将对象转为 最佳匹配媒体类型 的converter。调用它进行转化 。</p><p>自定义返回值mediaType数据格式，配置内容协商策略，添加自定义的mediaType类型。</p><p>**自定义MessageConverter **</p><p>实现多协议数据兼容。json、xml…</p><p>(1)、@ResponseBody 返回响应数据出去，调用 RequestResponseBodyMethodProcessor 处理</p><p>(2)、Processor 处理方法返回值，通过 MessageConverter 处理</p><p>(3)、所有 MessageConverter 合起来可以支持各种媒体类型数据的操作（读、写）</p><p>(4)、内容协商找到最终的 messageConverter</p><h4 id="thymeleaf"><a href="#thymeleaf" class="headerlink" title="thymeleaf"></a>thymeleaf</h4><p>一个XML&#x2F;XHTML&#x2F;HTML5模板引擎，可用于Web与非Web环境中的应用开发。它是一个开源的现代化服务端Java模板引擎，是整合 Spring MVC 的可选模块，在应用开发中，使用 Thymeleaf 来代替 JSP或其他模板引擎。<a href="thymeleaf.org">官网</a></p><p>注：由于SpringBoot打包是以jar的方式，不是war。其次我们的tomcat是嵌入式的，所以现在SpringBoot默认不支持jsp。<a href="https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#using-boot-starter">Spring官方文档</a></p><p> <strong>基本语法</strong> ：</p><table><thead><tr><th>表达式名字</th><th>语法</th><th>用途</th></tr></thead><tbody><tr><td>变量取值</td><td>${…}</td><td>获取请求域、session域、对象等值</td></tr><tr><td>选择变量</td><td>*{…}</td><td>获取上下文对象值</td></tr><tr><td>消息</td><td>#{…}</td><td>获取国际化等值</td></tr><tr><td>链接</td><td>@{…}</td><td>生成链接</td></tr><tr><td>片段表达式</td><td>~{…}</td><td>jsp:include 作用，引入公共页面片段</td></tr></tbody></table><p> 2、字面量 </p><p>文本值: ‘one text’ , ‘Another one!’ ,…数字: 0 , 34 , 3.0 , 12.3 ,…布尔值: true , false</p><p>空值: null</p><p>变量： one，two，…. 变量不能有空格</p><p> 3、文本操作 </p><p>字符串拼接: +</p><p>变量替换: |The name is ${name}| </p><p> 4、数学运算 </p><p>运算符: + , - , * , &#x2F; , %</p><p> 5、布尔运算 </p><p>运算符:  and , or</p><p>一元运算: ! , not </p><p> 6、比较运算 </p><p>比较: &gt; , &lt; , &gt;&#x3D; , &lt;&#x3D; ( gt , lt , ge , le )等式: &#x3D;&#x3D; , !&#x3D; ( eq , ne ) </p><p> 7、条件运算 </p><p>If-then: (if) ? (then)</p><p>If-then-else: (if) ? (then) : (else)</p><p>Default: (value) ?: (defaultvalue) </p><p> 8、特殊操作 </p><p>无操作： _</p><p><strong>迭代</strong>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:each</span>=<span class="string">&quot;prod : $&#123;prods&#125;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;prod.name&#125;&quot;</span>&gt;</span>Onions<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;prod.price&#125;&quot;</span>&gt;</span>2.41<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;prod.inStock&#125;? #&#123;true&#125; : #&#123;false&#125;&quot;</span>&gt;</span>yes<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>使用thymeleaf</strong></p><p>引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在相关页面中定义命名空间：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">&quot;layui-form&quot;</span> <span class="attr">lay-filter</span>=<span class="string">&quot;userForm&quot;</span> <span class="attr">id</span>=<span class="string">&quot;userForm&quot;</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--/*@thymesVar id=&quot;myUserName&quot; type=&quot;ch&quot;*/--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;myUserName&#125;&quot;</span> <span class="attr">name</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">lay-verify</span>=<span class="string">&quot;required&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入用户名&quot;</span> <span class="attr">autocomplete</span>=<span class="string">&quot;off&quot;</span> <span class="attr">class</span>=<span class="string">&quot;layui-input&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;www.xxxx.com&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;$&#123;link&#125;&quot;</span>&gt;</span>百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>controller返回对应页面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/editUser&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">editUser</span><span class="params">(Model model)</span>&#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> userService.getUser();</span><br><span class="line">    model.addAttribute(<span class="string">&quot;myUserName&quot;</span>,u.getUserName());</span><br><span class="line">    model.addAttribute(<span class="string">&quot;myNickName&quot;</span>,u.getNickName());</span><br><span class="line">    model.addAttribute(<span class="string">&quot;link&quot;</span>,<span class="string">&quot;www.baidu.com&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;user&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="视图解析原理流程"><a href="#视图解析原理流程" class="headerlink" title="视图解析原理流程"></a>视图解析原理流程</h5><p>1、目标方法处理的过程中，所有数据都会被放在<code> ModelAndViewContainer</code> 里面。包括数据和视图地址</p><p>2、方法的参数是一个自定义类型对象（从请求参数中确定的），把他重新放在 <code>ModelAndViewContainer</code></p><p>3、任何目标方法执行完成以后都会返回 ModelAndView（数据和视图地址）。</p><p>4、processDispatchResult  处理派发结果（页面改如何响应）</p><ul><li>render(mv, request, response); 进行页面渲染逻辑</li><li>根据方法的String返回值得到 View 对象（定义了页面的渲染逻辑），所有的视图解析器尝试是否能根据当前返回值得到View对象，得到了  redirect:&#x2F;main.html –&gt; Thymeleaf new RedirectView()，<code>ContentNegotiationViewResolver</code> 里面包含了下面所有的视图解析器，内部还是利用下面所有视图解析器得到视图对象。view.render(mv.getModelInternal(), request, response)，视图对象调用自定义的render进行页面渲染工作。</li><li>RedirectView 如何渲染【重定向到一个页面】<ul><li>1、获取目标url地址</li><li>2、response.sendRedirect(encodedURL)</li></ul></li></ul><p>视图解析：</p><p>1）返回值以 forward: 开始： new InternalResourceView(forwardUrl)–&gt;  转发request.getRequestDispatcher(path).forward(request, response); </p><p>2）返回值以 redirect: 开始： new RedirectView() -&gt; render就是重定向 </p><p>3）返回值是普通字符串： new ThymeleafView() </p><h4 id="HandlerInterceptor拦截器"><a href="#HandlerInterceptor拦截器" class="headerlink" title="HandlerInterceptor拦截器"></a>HandlerInterceptor拦截器</h4><p>定义拦截器，实现HandlerInterceptor接口，重写preHandler方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//获取session</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">httpSession</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">        <span class="keyword">if</span>(httpSession.getAttribute(<span class="string">&quot;loginUser&quot;</span>)==<span class="literal">null</span>)&#123;</span><br><span class="line">            response.sendRedirect(<span class="string">&quot;/f/toLogin&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>webMvcConfig重写addInterceptor方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>())</span><br><span class="line">                .addPathPatterns(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">           .excludePathPatterns(<span class="string">&quot;/&quot;</span>,<span class="string">&quot;/login.html&quot;</span>,<span class="string">&quot;/f/toLogin&quot;</span>,</span><br><span class="line">                                <span class="string">&quot;/user/login&quot;</span>,<span class="string">&quot;/img/*&quot;</span>,<span class="string">&quot;/layui/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拦截器执行过程：</p><p><u>preHandler-&gt;目标方法-&gt;postHandler-&gt;afterCompletion</u></p><p><strong>原理</strong>：</p><p>1、根据当前请求，找到HandlerExecutionChain【可以处理请求的handler以及handler的所有拦截器】</p><p>2、先顺序执行 所有拦截器的 preHandle方法</p><ul><li>如果当前拦截器prehandler返回为true。则执行下一个拦截器的preHandle。</li><li>如果当前拦截器返回为false。直接倒序执行所有已经执行了的拦截器的afterCompletion。</li></ul><p>3、如果任何一个拦截器返回false。直接跳出不执行目标方法。</p><p>4、所有拦截器都返回True，执行目标方法。</p><p>5、倒序执行所有拦截器的postHandle方法。</p><p>6、前面的步骤有任何异常都会直接倒序触发 afterCompletion</p><p>7、页面成功渲染完成以后，也会倒序触发 afterCompletion</p><h4 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h4><p>文件上传自动配置类-<code>MultipartAutoConfiguration</code>，spring boot自动配置好了 <code>StandardServletMultipartResolver</code> 文件上传解析器。</p><p>原理步骤：</p><p>1、请求进来使用文件上传解析器判断（isMultipart）并封装（resolveMultipart，返回MultipartHttpServletRequest）文件上传请求。</p><p>2、参数解析器来解析请求中的文件内容封装成MultipartFile。</p><p>3、将request中多个文件信息封装为一个Map ，MultiValueMap&lt;String, MultipartFile&gt;  。</p><p>注：可以FileCopyUtils文件复制工具类的copy方法，实现文件流的拷贝。</p><p>核心配置文件中配置spring文件上传大小：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">servlet:</span></span><br><span class="line">       <span class="attr">multipart:</span></span><br><span class="line">          <span class="attr">max-file-size:</span> <span class="string">10MB</span></span><br><span class="line">          <span class="attr">max-request-size:</span> <span class="string">100MB</span></span><br></pre></td></tr></table></figure><p>前端页面表单：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--post提交，上传至/upload，contentType=&quot;multipart/form-data&quot;--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">action</span>=<span class="string">&quot;/upload&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;file&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>后端接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * MultipartFile 自动封装上传过来的文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@RequestPart</span>从请求中取multipartFile文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/upload&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">upload</span><span class="params">(<span class="meta">@RequestParam(&quot;username&quot;)</span> String username,</span></span><br><span class="line"><span class="params">                     <span class="meta">@RequestPart(&quot;headerImg&quot;)</span> MultipartFile headerImg,</span></span><br><span class="line"><span class="params">                     <span class="meta">@RequestPart(&quot;photos&quot;)</span> MultipartFile[] photos)</span> </span><br><span class="line">    <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;main&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><h5 id="错误处理默认规则"><a href="#错误处理默认规则" class="headerlink" title="错误处理默认规则"></a>错误处理默认规则</h5><ul><li><p>默认情况下，Spring Boot提供<code>/error</code>处理所有错误的映射</p></li><li><p>对于服务器端，它将生成JSON响应，其中包含错误，HTTP状态和异常消息的详细信息。对于浏览器端，响应一个“ WhitelabelErrorView”，以HTML格式呈现。</p></li><li><p>要对其进行自定义，添加<code>View</code>解析为<code>error</code></p></li><li><p>要完全替换默认行为，可以实现 <code>ErrorController </code>并注册该类型的Bean定义，或添加ErrorAttributes类型的组件以使用现有机制但替换其内容。</p></li><li><p>templates&#x2F;error&#x2F;下的4xx，5xx页面会被自动解析；</p></li></ul><h5 id="定制错误处理逻辑"><a href="#定制错误处理逻辑" class="headerlink" title="定制错误处理逻辑"></a>定制错误处理逻辑</h5><ul><li><p>自定义错误页</p></li><li><p>error&#x2F;404.html   error&#x2F;5xx.html，有精确的错误状态码页面就匹配精确，没有就找 4xx.html；如果都没有就触发白页。</p></li><li><p>@ControllerAdvice+@ExceptionHandler处理全局异常，底层是使用ExceptionHandlerExceptionResolver</p></li><li><p>@ResponseStatus(返回状态码)+自定义异常 ，底层是使用ResponseStatusExceptionResolver，把@ResponseStatus注解的信息封装成ModelAndView并返回，底层调用 response.sendError(statusCode, resolvedReason)。</p></li><li><p>Spring底层的异常，如参数类型转换异常，使用DefaultHandlerExceptionResolver 处理框架底层的异常。</p></li><li><p>response.sendError(HttpServletResponse.SC_BAD_REQUEST, ex.getMessage())</p></li><li><p>自定义实现 HandlerExceptionResolver接口的异常解析器，可以作为默认的全局异常处理规则。</p></li><li><p>ErrorViewResolver实现自定义处理异常，response.sendError(411,”自定义异常”)，error请求就会转给controller。异常没有任何人能处理，则tomcat底层调用response.sendError，error请求就会转给controller。BasicErrorController要去的页面地址是ErrorViewResolver 。</p></li></ul><h5 id="异常处理自动配置"><a href="#异常处理自动配置" class="headerlink" title="异常处理自动配置"></a>异常处理自动配置</h5><ul><li><p>ErrorMvcAutoConfiguration  自动配置异常处理规则</p></li><li><p>容器中的组件：类型：DefaultErrorAttributes -&gt; id：errorAttributes。</p></li><li><p>public class DefaultErrorAttributes implements ErrorAttributes, HandlerExceptionResolver。</p></li></ul><p>DefaultErrorAttributes：定义错误页面中可以包含哪些数据。</p><ul><li><p>容器中的组件：类型：BasicErrorController –&gt; id：basicErrorController（json+白页 适配响应）。</p></li><li><p>处理默认 &#x2F;error 路径的请求，页面响应 new ModelAndView(“error”, model)。</p><ul><li>容器中有组件 View-&gt;id是error（响应默认错误页）。</li></ul></li><li><p>容器中放组件 BeanNameViewResolver，按照返回的视图名作为组件的id去容器中找View对象。</p></li><li><p>容器中的组件：类型：DefaultErrorViewResolver -&gt; id：conventionErrorViewResolver。</p></li><li><p>如果发生错误，会以HTTP的状态码作为视图页地址（viewName），找到真正的页面。</p><ul><li>viewName：error&#x2F;404、5xx.html。</li></ul></li></ul><p>如果想要返回页面，就会找error视图StaticView类型的defaultErrorView，默认是一个白页。其中定义了类WhitelabelErrorViewConfiguration。</p><h5 id="异常处理步骤流程"><a href="#异常处理步骤流程" class="headerlink" title="异常处理步骤流程"></a>异常处理步骤流程</h5><p>1、执行目标方法，目标方法运行期间有任何异常都会被catch，而且标志当前请求结束，并且用 dispatchException封装 。</p><p>2、进入视图解析页面渲染</p><p><code>mav = processDispatchResult(processedRequest, response, mappedHandler, mav, dispatchException);</code></p><p>3、处理handler发生的异常，处理完成返回ModelAndView（跳转地址和页面数据）。</p><ul><li><p>遍历所有的handlerExceptionResolvers，找到HandlerExceptionResolver处理器异常解析器。</p></li><li><p>默认异常解析器（DefaultErrorAttributes、DefaultHandlerExceptionResolver、ExceptionHandlerExceptionResolver、ResponseHandlerExceptionResolver）</p></li><li><p>DefaultErrorAttributes定义错误信息(<u>exception、status、stack_trace、error、message、path</u>)，把异常信息保存到request域，并且返回null。默认没有任何人能处理异常，所以异常会被抛出</p></li><li><p>如果没有任何人能处理最终底层就会发送 &#x2F;error 请求，会被底层的BasicErrorController处理。解析错误视图，遍历所有的 ErrorViewResolver解析，找到默认的DefaultErrorViewResolver(作用是把响应状态码作为错误页的地址)，模板引擎最终响应这个页面error&#x2F;xxx.html。</p></li></ul><h4 id="Web原生组件注入（Servlet、Filter、Listener）"><a href="#Web原生组件注入（Servlet、Filter、Listener）" class="headerlink" title="Web原生组件注入（Servlet、Filter、Listener）"></a>Web原生组件注入（Servlet、Filter、Listener）</h4><p><strong>使用Servlet API</strong></p><p><code>@ServletComponentScan(basePackages = &quot;com.xxx.xxx&quot;) </code>:指定原生Servlet组件都放在那里</p><p><code>@WebServlet(urlPatterns = &quot;/my&quot;)</code>：效果：直接响应，没有经过Spring的拦截器。</p><p><code>@WebFilter(urlPatterns=&#123;&quot;/css/\*&quot;,&quot;/images/\*&quot;&#125;)</code></p><p><code>@WebListener</code></p><p><u>DispatchServlet 如何注册进来</u></p><ul><li>容器中自动配置了  DispatcherServlet  属性绑定到 WebMvcProperties；对应的配置文件配置项是 spring.mvc。</li><li>通过<code>ServletRegistrationBean&lt;DispatcherServlet&gt;</code>把 DispatcherServlet  配置进来。</li><li>默认映射的是 &#x2F; 路径。</li></ul><p>Tomcat-Servlet；</p><p><u>多个Servlet都能处理到同一层路径，精确优选原则</u></p><p>A： &#x2F;my&#x2F;</p><p>B： &#x2F;my&#x2F;1</p><p><strong>使用RegistrationBean</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServletRegistrationBean`, `FilterRegistrationBean`, and `ServletListenerRegistrationBean</span><br></pre></td></tr></table></figure><p><strong>嵌入式Servlet容器</strong></p><p>默认支持的webServer有<code>Tomcat</code>, <code>Jetty</code>, or <code>Undertow</code>，<code>ServletWebServerApplicationContext</code> 容器启动寻找ServletWebServerFactory 并引导创建服务器。</p><p>原理</p><p>(1) SpringBoot应用启动发现当前是Web应用。web场景包-导入tomcat，web应用会创建一个web版的ioc容器 <code>ServletWebServerApplicationContext</code> 。<code>ServletWebServerApplicationContext</code> 启动的时候寻找 <code>ServletWebServerFactory</code>（Servlet 的web服务器工厂—&gt; Servlet 的web服务器）。</p><p>(2) SpringBoot底层默认有很多的WebServer工厂，<code>TomcatServletWebServerFactory</code>, <code>JettyServletWebServerFactory</code>, or <code>UndertowServletWebServerFactory</code>。底层直接会有一个自动配置类<code>ServletWebServerFactoryAutoConfiguration</code>，它导入了<code>ServletWebServerFactoryConfiguration</code>。</p><p>(3) <code>ServletWebServerFactoryConfiguration </code>配置类 根据动态判断系统中到底导入了那个Web服务器的包。（默认是web-starter导入tomcat包），容器中就有<code>TomcatServletWebServerFactory</code> ，它创建出Tomcat服务器并启动。TomcatWebServer 的构造器拥有初始化方法initialize—this.tomcat.start()。</p><p>(4) 内嵌服务器就是手动把启动服务器的代码调用，前提是tomcat核心jar包存在。</p><p><strong>定制Servlet容器</strong></p><ul><li><p>实现 <code>WebServerFactoryCustomizer&lt;ConfigurableServletWebServerFactory&gt; </code>接口的xxxCustomizer定制化器，可以改变xxxx的默认规则。</p></li><li><p>把配置文件的值和ServletWebServerFactory 进行绑定。</p></li><li><p>修改核心配置文件，server.xxx。</p></li><li><p>直接自定义 ConfigurableServletWebServerFactory </p></li><li><p>编写一个配置类实现 WebMvcConfigurer 即可定制化web功能+ @Bean给容器中再扩展一些组件。</p></li></ul><h4 id="Druid数据源"><a href="#Druid数据源" class="headerlink" title="Druid数据源"></a>Druid数据源</h4><ul><li>Druid主要解决的问题就是<code>传统数据库无法解决的大数据量查询性能的问题</code>。</li><li>本质就是<code>一个分布式支持实时数据分析的数据存储系统</code>。</li></ul><p>在实际应用中，MyBatis 可以利用 Druid 作为其连接池，这样可以避免频繁地创建和关闭连接。MyBatis 会指定 Druid 作为连接池，并从中获取连接。这样MyBatis 从 Druid 中获得连接的管理工作，专注于数据处理本身。总结来说，Druid 为 MyBatis 提供了一个高效且可靠的连接池服务，使得MyBatis能够在不需要手动管理连接的情况下进行数据库操作。</p><p>引入druid-starter：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>系统中所有filter：</p><table><thead><tr><th>别名</th><th>Filter类名</th></tr></thead><tbody><tr><td>default</td><td>com.alibaba.druid.filter.stat.StatFilter</td></tr><tr><td>stat</td><td>com.alibaba.druid.filter.stat.StatFilter</td></tr><tr><td>mergeStat</td><td>com.alibaba.druid.filter.stat.MergeStatFilter</td></tr><tr><td>encoding</td><td>com.alibaba.druid.filter.encoding.EncodingConvertFilter</td></tr><tr><td>log4j</td><td>com.alibaba.druid.filter.logging.Log4jFilter</td></tr><tr><td>log4j2</td><td>com.alibaba.druid.filter.logging.Log4j2Filter</td></tr><tr><td>slf4j</td><td>com.alibaba.druid.filter.logging.Slf4jLogFilter</td></tr><tr><td>commonlogging</td><td>com.alibaba.druid.filter.logging.CommonsLogFilter</td></tr></tbody></table><p>核心配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span>   </span><br><span class="line">    <span class="attr">druid:</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/db</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">      <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">      <span class="attr">aop-patterns:</span> <span class="string">com.xxx.admin.*</span>  <span class="comment">#监控SpringBean</span></span><br><span class="line">      <span class="attr">filters:</span> <span class="string">stat,wall</span>     <span class="comment"># 底层开启功能，stat（sql监控），wall（防火墙）</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">stat-view-servlet:</span>   <span class="comment"># 配置监控页功能</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">login-username:</span> <span class="string">admin</span></span><br><span class="line">        <span class="attr">login-password:</span> <span class="number">123456</span></span><br><span class="line">        <span class="attr">resetEnable:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">web-stat-filter:</span>  <span class="comment"># 监控web</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">urlPattern:</span> <span class="string">/*</span></span><br><span class="line">        <span class="attr">exclusions:</span> <span class="string">&#x27;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*&#x27;</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">filter:</span></span><br><span class="line">        <span class="attr">stat:</span>    <span class="comment"># 对上面filters里面的stat的详细配置</span></span><br><span class="line">          <span class="attr">slow-sql-millis:</span> <span class="number">1000</span></span><br><span class="line">          <span class="attr">logSlowSql:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">wall:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">config:</span></span><br><span class="line">            <span class="attr">drop-table-allow:</span> <span class="literal">false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://github.com/alibaba/druid/tree/master/druid-spring-boot-starter">SpringBoot配置示例</a></p><p><a href="https://github.com/alibaba/druid/wiki/DruidDataSource%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E5%88%97%E8%A1%A8">配置项列表</a></p><h4 id="整合Redis"><a href="#整合Redis" class="headerlink" title="整合Redis"></a>整合Redis</h4><p>Redis 是一个开源的内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>核心配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">r-bp1nc7reqesxisgxpipd.redis.rds.aliyuncs.com</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">lfy:Lfy123456</span></span><br><span class="line">     <span class="comment">#client-type: jedis</span></span><br><span class="line">     <span class="comment"># jedis:</span></span><br><span class="line">       <span class="comment"># pool:</span></span><br><span class="line">        <span class="comment">#  max-active: 10</span></span><br></pre></td></tr></table></figure><p>自动配置：</p><ul><li>RedisAutoConfiguration 自动配置类。RedisProperties 属性类 ，spring.redis.xxx是对redis的配置。</li><li>连接工厂是准备好的。LettuceConnectionConfiguration、JedisConnectionConfiguration。</li><li>自动注入了RedisTemplate&lt;Object, Object&gt; ： xxxTemplate。</li><li>自动注入了StringRedisTemplate；k：v都是String。</li><li>底层只要我们使用 StringRedisTemplate、RedisTemplate就可以操作redis。</li></ul><p>连接测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">testRedis</span><span class="params">()</span>&#123;</span><br><span class="line">      ValueOperations&lt;String, String&gt; operations = redisTemplate.opsForValue();</span><br><span class="line">      operations.set(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>);</span><br><span class="line">      <span class="type">String</span> <span class="variable">hello</span> <span class="operator">=</span> operations.get(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">      System.out.println(hello);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><p> Spring Boot 2.2.0 版本开始引入 JUnit 5 作为单元测试默认库，作为最新版本的JUnit框架，JUnit5与之前版本的Junit框架有很大的不同。由三个不同子项目的几个不同模块组成。</p><p><strong>JUnit 5 &#x3D; JUnit Platform + JUnit Jupiter + JUnit Vintage</strong></p><p>1）JUnit Platform: Junit Platform是在JVM上启动测试框架的基础，不仅支持Junit自制的测试引擎，其他测试引擎也都可以接入。</p><p>2）JUnit Jupiter: 提供了JUnit5的新的编程模型，是JUnit5新特性的核心，内部包含了一个测试引擎，用于在Junit Platform上运行。</p><p>3）JUnit Vintage: 提供了兼容JUnit4.x,Junit3.x的测试引擎。</p><p><u>相关变化：</u></p><ul><li>注解在 org.junit.jupiter.api 包中，断言在 org.junit.jupiter.api.Assertions 类中，前置条件在 org.junit.jupiter.api.Assumptions 类中。</li><li>把@Before 和@After 替换成@BeforeEach 和@AfterEach。</li><li>把@BeforeClass 和@AfterClass 替换成@BeforeAll 和@AfterAll。</li><li>把@Ignore 替换成@Disabled。</li><li>把@Category 替换成@Tag。</li><li>把@RunWith、@Rule 和@ClassRule 替换成@ExtendWith。</li></ul><p><strong>注意</strong>：SpringBoot 2.4 以上版本移除了默认对 Vintage 的依赖，不能使用junit4的功能 @Test，JUnit 5’s Vintage Engine 从spring-boot-starter-test中移除，如果需要继续兼容junit4需要自行引入vintage。</p><p>引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--兼容junit4--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hamcrest<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hamcrest-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>SpringBoot整合Junit以后,编写测试方法：@Test标注（注意需要使用junit5版本的注解），Junit类具有Spring的功能，@Autowired、@Transactional 标注测试方法，测试完成后自动回滚。</p><h5 id="JUnit5常用注解"><a href="#JUnit5常用注解" class="headerlink" title="JUnit5常用注解"></a>JUnit5常用注解</h5><p><a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-annotations">JUnit5与JUnit4的注解变化</a></p><ul><li><code>@Test</code> :表示方法是测试方法。但是与JUnit4的@Test不同，他的职责非常单一不能声明任何属性，拓展的测试将会由Jupiter提供额外测试</li><li><code>@ParameterizedTest</code> :表示方法是参数化测试</li><li><code>@RepeatedTest</code> :表示方法可重复执行</li><li><code>@DisplayName</code> :为测试类或者测试方法设置展示名称</li><li><code>@BeforeEach</code> :表示在每个单元测试之前执行</li><li><code>@AfterEach</code> :表示在每个单元测试之后执行</li><li><code>@BeforeAll</code> :表示在所有单元测试之前执行</li><li><code>@AfterAll</code> :表示在所有单元测试之后执行</li><li><code>@Tag</code> :表示单元测试类别，类似于JUnit4中的@Categories</li><li><code>@Disabled</code> :表示测试类或测试方法不执行，类似于JUnit4中的@Ignore</li><li><code>@Timeout</code> :表示测试方法运行如果超过了指定时间将会返回错误</li><li><code>@ExtendWith</code> :为测试类或测试方法提供扩展类引用</li></ul><h5 id="断言assertions"><a href="#断言assertions" class="headerlink" title="断言assertions"></a>断言assertions</h5><p>断言（assertions）是测试方法中的核心部分，用来对测试需要满足的条件进行验证。这些断言方法都是 org.junit.jupiter.api.Assertions 的静态方法。JUnit 5 内置的断言可以分成如下几个类别：</p><p><strong>1、简单断言</strong></p><p>用来对单个值进行简单的验证，前面的断言失败，后面的代码不会执行。</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>assertEquals</td><td>判断两个对象或两个原始类型是否相等</td></tr><tr><td>assertNotEquals</td><td>判断两个对象或两个原始类型是否不相等</td></tr><tr><td>assertSame</td><td>判断两个对象引用是否指向同一个对象</td></tr><tr><td>assertNotSame</td><td>判断两个对象引用是否指向不同的对象</td></tr><tr><td>assertTrue</td><td>判断给定的布尔值是否为 true</td></tr><tr><td>assertFalse</td><td>判断给定的布尔值是否为 false</td></tr><tr><td>assertNull</td><td>判断给定的对象引用是否为 null</td></tr><tr><td>assertNotNull</td><td>判断给定的对象引用是否不为 null</td></tr></tbody></table><p><strong>2、数组断言</strong></p><p>通过 assertArrayEquals 方法来判断两个对象或原始类型的数组是否相等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName(&quot;array assertion&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">array</span><span class="params">()</span> &#123;</span><br><span class="line"> assertArrayEquals(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、组合断言</strong></p><p>assertAll 方法接受多个 org.junit.jupiter.api.Executable 函数式接口的实例作为要验证的断言，可以通过 lambda 表达式很容易的提供这些断言</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName(&quot;assert all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">all</span><span class="params">()</span> &#123;</span><br><span class="line"> assertAll(<span class="string">&quot;Math&quot;</span>,</span><br><span class="line">    () -&gt; assertEquals(<span class="number">2</span>, <span class="number">1</span> + <span class="number">1</span>),</span><br><span class="line">    () -&gt; assertTrue(<span class="number">1</span> &gt; <span class="number">0</span>)</span><br><span class="line"> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4、异常断言</strong></p><p>在JUnit4时期，想要测试方法的异常情况时，需要用**@Rule<strong>注解的ExpectedException变量还是比较麻烦的。而JUnit5提供了一种新的断言方式</strong>Assertions.assertThrows()** ,配合函数式编程就可以进行使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName(&quot;异常测试&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ArithmeticException</span> <span class="variable">exception</span> <span class="operator">=</span> Assertions.assertThrows(</span><br><span class="line">        <span class="comment">//扔出断言异常</span></span><br><span class="line">        ArithmeticException.class, () -&gt; System.out.println(<span class="number">1</span> % <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5、超时断言</strong></p><p>Junit5还提供了Assertions.assertTimeout() 为测试方法设置了超时时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName(&quot;超时测试&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">timeoutTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//如果测试方法时间超过1s将会异常</span></span><br><span class="line">    Assertions.assertTimeout(Duration.ofMillis(<span class="number">1000</span>), () -&gt; Thread.sleep(<span class="number">500</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>6、快速失败</strong></p><p>通过 fail 方法直接使得测试失败</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName(&quot;fail&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shouldFail</span><span class="params">()</span> &#123;</span><br><span class="line"> fail(<span class="string">&quot;This should fail&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="前置条件（assumptions）"><a href="#前置条件（assumptions）" class="headerlink" title="前置条件（assumptions）"></a>前置条件（assumptions）</h5><p>JUnit 5 中的前置条件类似于断言，不同之处在于不满足的断言会使得测试方法失败，而不满足的前置条件只会使得测试方法的执行终止直接跳过。前置条件可以看成是测试方法执行的前提，当该前提不满足时，就没有继续执行的必要。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DisplayName(&quot;前置条件&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AssumptionsTest</span> &#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">environment</span> <span class="operator">=</span> <span class="string">&quot;DEV&quot;</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="meta">@Test</span></span><br><span class="line"> <span class="meta">@DisplayName(&quot;assumeTrue&quot;)</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">simpleAssume</span><span class="params">()</span> &#123;</span><br><span class="line">    assumeTrue(Objects.equals(<span class="built_in">this</span>.environment, <span class="string">&quot;DEV&quot;</span>));</span><br><span class="line">    assumeFalse(() -&gt; Objects.equals(<span class="built_in">this</span>.environment, <span class="string">&quot;PROD&quot;</span>));</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="meta">@Test</span></span><br><span class="line"> <span class="meta">@DisplayName(&quot;assumingThat&quot;)</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">assumeThenDo</span><span class="params">()</span> &#123;</span><br><span class="line">    assumingThat(</span><br><span class="line">       Objects.equals(<span class="built_in">this</span>.environment, <span class="string">&quot;DEV&quot;</span>),</span><br><span class="line">       () -&gt; System.out.println(<span class="string">&quot;In DEV&quot;</span>)</span><br><span class="line">    );</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>assumeTrue 和 assumFalse 确保给定的条件为 true 或 false，不满足条件会使得测试执行终止。assumingThat 的参数是表示条件的布尔值和对应的 Executable 接口的实现对象。只有条件满足时，Executable 对象才会被执行；当条件不满足时，测试执行并不会终止。</p><h5 id="嵌套测试"><a href="#嵌套测试" class="headerlink" title="嵌套测试"></a>嵌套测试</h5><p>JUnit 5 可以通过 Java 中的内部类和<code>@Nested </code>注解实现嵌套测试，从而可以更好的把相关的测试方法组织在一起。在内部类中可以使用<code>@BeforeEach</code> 和<code>@AfterEach</code> 注解，而且嵌套的层次没有限制。但是，嵌套内部的<code>@BeforeEach</code> 和<code>@AfterEach</code> 方法不会对外部的<code>@Test</code>单元测试生效。相反，外层的会对内层的单元测试生效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">xxx</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;is empty&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nested</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;after&quot;)</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">After</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="参数化测试"><a href="#参数化测试" class="headerlink" title="参数化测试"></a>参数化测试</h5><p>参数化测试是JUnit5很重要的一个新特性，用不同的参数多次运行测试，为我们的单元测试带来许多便利。</p><p><strong>相关注解：</strong></p><p>@ParameterizedTest：代表这是一个参数化测试单元，而不是普通测试单元。</p><p>@ValueSource：为参数化测试指定入参来源，支持八大基础类以及String类型,Class类型，使用不同的参数进行多次单元测试，而不需要每新增一个参数就新增一个单元测试，省去了很多冗余代码。</p><p>@NullSource: 表示为参数化测试提供一个null的入参。</p><p>@EnumSource: 表示为参数化测试提供一个枚举入参。</p><p>@CsvFileSource：表示读取指定CSV文件内容作为参数化测试入参。</p><p>@MethodSource：表示读取指定方法的返回值作为参数化测试入参(注意方法返回需要是一个流)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@ValueSource(strings = &#123;&quot;x&quot;, &quot;xx&quot;, &quot;xxx&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parameterizedTest1</span><span class="params">(String string)</span> &#123;</span><br><span class="line">    System.out.println(string);</span><br><span class="line">    Assertions.assertTrue(StringUtils.isNotBlank(string));</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@MethodSource(&quot;method&quot;)</span>    <span class="comment">//指定方法名</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testWithExplicitLocalMethodSource</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    System.out.println(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Stream&lt;String&gt; <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Stream.of(<span class="string">&quot;xxx&quot;</span>, <span class="string">&quot;xx&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：当然如果参数化测试仅仅只能做到指定普通的入参，他的强大之处的地方在于可以支持外部的各类入参。如:CSV,YML,JSON 文件甚至方法的返回值也可以作为入参。只需要去实现<code>ArgumentsProvider</code>接口，任何外部文件都可以作为它的入参。</p><h4 id="指标监控Actuator"><a href="#指标监控Actuator" class="headerlink" title="指标监控Actuator"></a>指标监控Actuator</h4><p>未来每一个微服务在云上部署以后，都需要对其进行监控、追踪、审计、控制等。SpringBoot就抽取了Actuator场景，使得我们每个微服务快速引用即可获得生产级别的应用监控、审计等功能。</p><p>引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​</p><p>2.x版本与1.x版本不同在于在支持MVC的基础上支持webFlux函数式编程、注解扩展、丰富的安全策略，底层使用MicroMeter。</p><p><u>访问路径：</u>localhost:8080&#x2F;actuator，localhost:8080&#x2F;actuator&#x2F;EndPoint</p><p>相关配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#management是actuator的配置</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">enabled-by-default:</span> <span class="literal">true</span> <span class="comment">#暴露所有JMX端点信息</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&#x27;*&#x27;</span>  <span class="comment">#以web方式暴露所有端点</span></span><br></pre></td></tr></table></figure><h5 id="Actuator-Endpoint"><a href="#Actuator-Endpoint" class="headerlink" title="Actuator Endpoint"></a>Actuator Endpoint</h5><p><strong>常用的Endpoints监控端点</strong></p><table><thead><tr><th>ID</th><th>描述</th></tr></thead><tbody><tr><td><code>auditevents</code></td><td>暴露当前应用程序的审核事件信息。需要一个<code>AuditEventRepository组件</code>。</td></tr><tr><td><code>beans</code></td><td>显示应用程序中所有Spring Bean的完整列表。</td></tr><tr><td><code>caches</code></td><td>暴露可用的缓存。</td></tr><tr><td><code>conditions</code></td><td>显示自动配置的所有条件信息，包括匹配或不匹配的原因。</td></tr><tr><td><code>configprops</code></td><td>显示所有配置<code>@ConfigurationProperties</code>。</td></tr><tr><td><code>env</code></td><td>暴露Spring的属性<code>ConfigurableEnvironment</code></td></tr><tr><td><code>flyway</code></td><td>显示已应用的所有Flyway数据库迁移。 需要一个或多个<code>Flyway</code>组件。</td></tr><tr><td><code>health</code></td><td>显示应用程序运行状况信息。</td></tr><tr><td><code>httptrace</code></td><td>显示HTTP跟踪信息（默认情况下，最近100个HTTP请求-响应）。需要一个<code>HttpTraceRepository</code>组件。</td></tr><tr><td><code>info</code></td><td>显示应用程序信息。</td></tr><tr><td><code>integrationgraph</code></td><td>显示Spring <code>integrationgraph</code> 。需要依赖<code>spring-integration-core</code>。</td></tr><tr><td><code>loggers</code></td><td>显示和修改应用程序中日志的配置。</td></tr><tr><td><code>liquibase</code></td><td>显示已应用的所有Liquibase数据库迁移。需要一个或多个<code>Liquibase</code>组件。</td></tr><tr><td><code>metrics</code></td><td>显示当前应用程序的“指标”信息。</td></tr><tr><td><code>mappings</code></td><td>显示所有<code>@RequestMapping</code>路径列表。</td></tr><tr><td><code>scheduledtasks</code></td><td>显示应用程序中的计划任务。</td></tr><tr><td><code>sessions</code></td><td>允许从Spring Session支持的会话存储中检索和删除用户会话。需要使用Spring Session的基于Servlet的Web应用程序。</td></tr><tr><td><code>shutdown</code></td><td>使应用程序正常关闭。默认禁用。</td></tr><tr><td><code>startup</code></td><td>显示由<code>ApplicationStartup</code>收集的启动步骤数据。需要使用<code>SpringApplication</code>进行配置<code>BufferingApplicationStartup</code>。</td></tr><tr><td><code>threaddump</code></td><td>执行线程转储。</td></tr></tbody></table><p>如果应用程序是Web应用程序（Spring MVC，Spring WebFlux或Jersey），则可以使用以下附加端点：</p><table><thead><tr><th>ID</th><th>描述</th></tr></thead><tbody><tr><td><code>heapdump</code></td><td>返回<code>hprof</code>堆转储文件。</td></tr><tr><td><code>jolokia</code></td><td>通过HTTP暴露JMX bean（需要引入Jolokia，不适用于WebFlux）。需要引入依赖<code>jolokia-core</code>。</td></tr><tr><td><code>logfile</code></td><td>返回日志文件的内容（如果已设置<code>logging.file.name</code>或<code>logging.file.path</code>属性）。支持使用HTTP<code>Range</code>标头来检索部分日志文件的内容。</td></tr><tr><td><code>prometheus</code></td><td>以Prometheus服务器可以抓取的格式公开指标。需要依赖<code>micrometer-registry-prometheus</code>。</td></tr></tbody></table><p><u>最常用的Endpoint</u></p><ul><li>Health：监控状况</li><li>Metrics：运行时指标</li><li>Loggers：日志记录</li></ul><p><u>Health Endpoint</u></p><p>健康检查端点，一般用于在云平台，平台会定时的检查应用的健康状况，status为up表示健康，为down不健康，web访问路径：localhost:8080&#x2F;actuator&#x2F;health。</p><p><u>Metrics Endpoint</u></p><p>提供详细的、层级的、空间指标信息，这些信息可以被主动推送或者被动获取方式得到。相关metric访问路径：localhost:8080&#x2F;actuator&#x2F;metrics&#x2F;http.server.requests。</p><h5 id="管理Endpoints"><a href="#管理Endpoints" class="headerlink" title="管理Endpoints"></a>管理Endpoints</h5><p><strong>1、开启与禁用Endpoints</strong></p><ul><li>默认所有的Endpoint除过shutdown都是开启的。</li><li>需要开启或者禁用某个Endpoint，配置模式为<code>management.endpoint.端点名.enabled = true</code></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoint:</span></span><br><span class="line">    <span class="attr">health:</span></span><br><span class="line">      <span class="attr">show-details:</span> <span class="string">always</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><ul><li>或者禁用所有的Endpoint然后手动开启指定的Endpoint</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">enabled-by-default:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">endpoint:</span></span><br><span class="line">    <span class="attr">beans:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">health:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>2、暴露Endpoint</strong>s</p><p>支持的暴露方式</p><ul><li>HTTP：<u>默认只暴露health和info</u></li><li>JMX：默认暴露所有Endpoint，cmd使用<code>jconsole</code>本地访问</li><li>除过health和info，剩下的Endpoint都应该进行保护访问。如果引入SpringSecurity，则会默认配置安全访问规则</li></ul><p><strong>JMX</strong> （Java Management Extensions，即Java管理扩展）是一个为应用程序、设备、系统等植入管理功能的框架，提供了一种简单的、标准的监控和管理资源的性能监控方式。</p><h5 id="定制-Endpoint"><a href="#定制-Endpoint" class="headerlink" title="定制 Endpoint"></a>定制 Endpoint</h5><p><strong>1、定制 Health 信息</strong></p><p>监控端点的类名须以HealthIndicator结尾，方式一实现<code>HealthIndicator</code>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyHealthIndicator</span> <span class="keyword">implements</span> <span class="title class_">HealthIndicator</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Health <span class="title function_">health</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">errorCode</span> <span class="operator">=</span> check(); </span><br><span class="line">        <span class="keyword">if</span> (errorCode != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Health.down().withDetail(<span class="string">&quot;Error Code&quot;</span>, errorCode).build();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Health.up().build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式二继承<code>AbstractHealthIndicator</code>抽象类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyhealthHealthIndicator</span> <span class="keyword">extends</span> <span class="title class_">AbstractHealthIndicator</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doHealthCheck</span><span class="params">(Health.Builder builder)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Map&lt;String,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span> == <span class="number">1</span>)&#123;</span><br><span class="line">       <span class="comment">// builder.up(); 健康</span></span><br><span class="line">            builder.status(Status.UP);</span><br><span class="line">            map.put(<span class="string">&quot;count&quot;</span>,<span class="number">1</span>);</span><br><span class="line">            map.put(<span class="string">&quot;ms&quot;</span>,<span class="number">100</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// builder.down();</span></span><br><span class="line">            builder.status(Status.OUT_OF_SERVICE);</span><br><span class="line">            map.put(<span class="string">&quot;err&quot;</span>,<span class="string">&quot;连接超时&quot;</span>);</span><br><span class="line">            map.put(<span class="string">&quot;ms&quot;</span>,<span class="number">3000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        builder.withDetail(<span class="string">&quot;code&quot;</span>,<span class="number">100</span>)</span><br><span class="line">                .withDetails(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问：localhost:8080&#x2F;actuator&#x2F;health 会返回的所有health信息，包括Myhealth。</p><p><strong>2、定制info信息</strong></p><p>常用两种方式：</p><p>1、编写核心配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">info:</span></span><br><span class="line">  <span class="attr">appName:</span> <span class="string">MyAdmin</span></span><br><span class="line">  <span class="attr">version:</span> <span class="number">1.0</span><span class="number">.0</span></span><br><span class="line">  <span class="comment">#使用@@可以获取maven的pom文件值</span></span><br><span class="line">  <span class="attr">mavenProjectName:</span> <span class="string">@project.artifactId@</span>  </span><br><span class="line">  <span class="attr">mavenProjectVersion:</span> <span class="string">@project.version@</span></span><br></pre></td></tr></table></figure><p>2、编写InfoContributor监控点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.actuate.info.Info;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.actuate.info.InfoContributor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleInfoContributor</span> <span class="keyword">implements</span> <span class="title class_">InfoContributor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contribute</span><span class="params">(Info.Builder builder)</span> &#123;</span><br><span class="line">        builder.withDetail(<span class="string">&quot;example&quot;</span>,</span><br><span class="line">                Collections.singletonMap(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>))</span><br><span class="line">            .withDetail(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问：localhost:8080&#x2F;actuator&#x2F;info 会输出以上方式返回的所有info信息。</p><p><strong>3、定制Metrics信息</strong></p><p>SpringBoot支持自动适配的Metrics。</p><p>增加定制Metrics：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyService</span>&#123;</span><br><span class="line">    Counter counter;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyService</span><span class="params">(MeterRegistry meterRegistry)</span>&#123;</span><br><span class="line">        <span class="comment">//通过Registry注册metrics指标</span></span><br><span class="line">         counter = meterRegistry.counter(<span class="string">&quot;myservice.hello.count&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//记录hello方法调用次数</span></span><br><span class="line">        counter.increment();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//也可以使用下面的方式</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line">MeterBinder <span class="title function_">queueSize</span><span class="params">(Queue queue)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (registry) -&gt; Gauge.builder(<span class="string">&quot;queueSize&quot;</span>, queue::size).register(registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问：localhost:8080&#x2F;actuator&#x2F;metrics&#x2F;myservice.hello.count，会输出该监控指标信息。</p><p><strong>4、自定义Endpoint</strong></p><p>使用<code>@EndPoint</code>注解，属性id为EndPointName。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Endpoint(id = &quot;EPname&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DockerEndpoint</span> &#123;</span><br><span class="line">    <span class="meta">@ReadOperation</span></span><br><span class="line">    <span class="keyword">public</span> Map <span class="title function_">getDockerInfo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.singletonMap(<span class="string">&quot;info&quot;</span>,<span class="string">&quot;docker started...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@WriteOperation</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">stopDocker</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;docker stopped....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问：localhost:8080&#x2F;actuator&#x2F;EPname 获取以上信息。</p><p>开发ReadinessEndpoint来管理程序是否就绪，或者LivenessEndpoint来管理程序是否存活。</p><h5 id="可视化应用监控服务"><a href="#可视化应用监控服务" class="headerlink" title="可视化应用监控服务"></a>可视化应用监控服务</h5><p>引入springboot-admin-server依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.codecentric<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-admin-starter-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.codecentric<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-admin-starter-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在主配置类上添加<code>@EnableAdminServer</code>注解开启admin监控，在核心配置文件中配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#admin访问地址</span></span><br><span class="line"><span class="attr">spring.boot.admin.url</span>=<span class="string">http://localhost:8080</span></span><br><span class="line"><span class="comment">#应用以ip注册</span></span><br><span class="line"><span class="attr">spring.boot.admin.instance.prefer-ip</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">#应用名</span></span><br><span class="line"><span class="attr">spring.application.name</span>=<span class="string">hello</span></span><br><span class="line"><span class="attr">management.endpoints.enabled-by-default</span>=<span class="string">true </span></span><br><span class="line"><span class="comment">#暴露所有端点</span></span><br><span class="line"><span class="attr">management.endpoints.web.exposure.include</span>=<span class="string">*</span></span><br><span class="line"><span class="comment">#以web方式暴露所有端点</span></span><br></pre></td></tr></table></figure><h4 id="高级特性与原理解析"><a href="#高级特性与原理解析" class="headerlink" title="高级特性与原理解析"></a>高级特性与原理解析</h4><h5 id="Profile功能"><a href="#Profile功能" class="headerlink" title="Profile功能"></a>Profile功能</h5><p>为了方便多环境适配，springboot简化了profile功能。</p><p>1、application-profile功能</p><ul><li><p>默认配置文件  application.yaml，任何时候都会加载。</p></li><li><p>指定环境配置文件： application-{env}.yaml，env可为test、prod。</p></li><li><p>激活指定环境并指定相关配置参数。</p><p>激活profile环境方式：</p><p>一、配置文件激活：<code>spring.profiles.active=prod</code></p><p>二、命令行激活：<code>java -jar xxx.jar --spring.profiles.active=prod  --person.name=666</code></p></li><li><p>修改配置文件的任意值，<u>命令行优先。</u></p></li><li><p>默认配置与环境配置同时生效。</p></li><li><p>同名配置项，profile配置优先。</p></li></ul><p>2、<code>@Profile</code>条件装配功能</p><p>该注解使类或方法等在指定配置环境下生效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@Profile(&quot;prod&quot;)</span><span class="comment">//该类在生产环境下生效</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductionConfiguration</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、profile分组</p><p>批量加载配置文件，互补配置，注意不要冲突。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.profiles.group.myprod[0]</span>=<span class="string">prod</span></span><br><span class="line"><span class="attr">spring.profiles.group.myprod[1]</span>=<span class="string">test</span></span><br><span class="line"><span class="attr">spring.profiles.active</span>=<span class="string">myprod  </span></span><br><span class="line"><span class="comment">#激活</span></span><br></pre></td></tr></table></figure><h5 id="外部化配置"><a href="#外部化配置" class="headerlink" title="外部化配置"></a>外部化配置</h5><p>1、外部配置源</p><p>常用：Java属性文件、YAML文件、环境变量、命令行参数</p><p>2、springboot配置文件查找位置</p><p>(1) classpath 根路径</p><p>(2) classpath 根路径下config目录</p><p>(3) jar包当前目录</p><p>(4) jar包当前目录的config目录</p><p>(5) &#x2F;config子目录的直接子目录</p><p>​</p><p>注：<u>指定环境优先，外部优先，后面的可以覆盖前面的同名配置项</u></p><p>3、配置文件加载顺序</p><ol><li>　当前jar包内部的application.properties和application.yml</li><li>　当前jar包内部的application-{profile}.properties 和 application-{profile}.yml</li><li>　引用的外部jar包的application.properties和application.yml</li><li>　引用的外部jar包的application-{profile}.properties 和 application-{profile}.yml</li></ol><h5 id="springboot启动过程"><a href="#springboot启动过程" class="headerlink" title="springboot启动过程"></a>springboot启动过程</h5><p>starter启动原理：</p><ul><li>autoconfigure包中配置使用 <code>META-INF/spring.factories </code>中 <code>EnableAutoConfiguration</code>的值，使得项目启动加载指定的自动配置类。</li><li>编写自动配置类 xxxAutoConfiguration -&gt; xxxxProperties</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@Conditional</span><br><span class="line">@EnableConfigurationProperties</span><br><span class="line">@Bean</span><br></pre></td></tr></table></figure><p><u>过程</u>：引入starter —&gt;xxxAutoConfiguration —&gt; 容器中放入组件 —&gt; 绑定xxxProperties.java —&gt; 配置项</p><p>springboot应用启动过程：</p><ul><li><p>创建 SpringApplication</p><ul><li>保存一些信息。</li><li>判定当前应用的类型。</li><li><code>bootstrappers</code>：初始启动引导器，去spring.factories文件中找 <code>org.springframework.boot.Bootstrapper</code></li><li>找 ApplicationContextInitializer初始化器·，去spring.factories找<code> ApplicationContextInitializer</code>。</li><li>找 ApplicationListener应用监听器(事件通知)，去spring.factories找<code>ApplicationListener</code>。</li></ul></li><li><p>运行 SpringApplication</p><ul><li>StopWatch监控应用启停。</li><li>记录应用的启动时间。</li><li>创建引导上下文（Context环境）createBootstrapContext()，获取到所有之前的 bootstrappers 挨个执行 intitialize() 来完成对引导启动器上下文环境设置。</li><li>让当前应用进入headless模式。</li><li>获取所有RunListener（运行监听器），<code>getSpringFactoriesInstances</code> 去<code>spring.factories</code>找 <code>SpringApplicationRunListener</code>。</li><li>遍历<code>SpringApplicationRunListener</code>调用 starting 方法，相当于通知所有感兴趣系统正在启动过程的人，项目正在 starting。</li><li>保存命令行参数<code>ApplicationArguments</code></li><li>准备环境 prepareEnvironment（）<ul><li>返回或者创建基础环境信息对象StandardServletEnvironment</li><li>配置环境信息对象，读取所有的配置源的配置属性值</li><li>绑定环境信息</li><li>监听器调用<code>listener.environmentPrepared()</code>通知所有的监听器当前环境准备完成</li><li>创建IOC容器createApplicationContext<ul><li>根据项目类型（Servlet）创建容器</li><li>当前会创建AnnotationConfigServletWebServerApplicationContext</li></ul></li></ul></li><li>准备ApplicationContext IOC容器的基本信息 prepareContext()<ul><li>保存环境信息</li><li>IOC容器的后置处理流程</li><li>应用初始化器applyInitializers<ul><li>遍历所有的 ApplicationContextInitializer，调用 initialize.来对ioc容器进行初始化扩展功能</li><li>遍历所有的 listener 调用 contextPrepared，EventPublishRunListenr，通知所有的监听器contextPrepared</li></ul></li><li>所有的监听器 调用 contextLoaded，通知所有的监听器 contextLoaded。</li></ul></li><li><u>刷新IOC容器refreshContext，创建容器中的所有组件</u></li><li>容器刷新完成后工作afterRefresh</li><li>所有监听器调用 listeners.started(context)，通知所有的监听器started</li><li>调用所有runners，callRunners()<ul><li>获取容器中的<code>ApplicationRunner </code></li><li>获取容器中的 <code>CommandLineRunner</code></li><li>合并所有runner并且按照@Order进行排序</li><li>遍历所有的runner，调用 run 方法</li></ul></li><li>如果以上有异常，调用Listener 的 failed方法。</li><li>调用所有监听器的 running 方法listeners.running(context)，通知所有的监听器应用运行中 </li><li>running如果有问题，继续通知 failed ，调用所有 Listener 的 failed，通知所有的监听器 failed</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;springboot是一种简化springweb开发的框架，类似springmvc，他提供各种默认配置，达到开箱即用、敏捷开发的效果。本文主要介绍springboot的依赖管理、自动配置、web开发、thymeleaf与视图解析、拦截器、文件上传、异常处理、web原生组件注入、整合数据源Druid与Redis、Junit单元测试、spring Acutuator性能监控、高级特性与springboot启动原理。</summary>
    
    
    
    <category term="java" scheme="https://aachou.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring入门</title>
    <link href="https://aachou.github.io/2023/1231/"/>
    <id>https://aachou.github.io/2023/1231/</id>
    <published>2023-12-31T10:16:09.000Z</published>
    <updated>2024-01-01T10:07:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>Spring是一个开放源代码的JavaEE设计层面框架，解决了业务逻辑层和其他各层的松耦合问题，因此它将面向接口的编程思想贯穿整个系统应用，它的核心是IOC控制反转和AOP面向切面编程<span id="more"></span>。</p><p>七大模块：core、aop、orm、dao、web、context、web mvc。</p><h4 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h4><p>控制反转，面向对象的设计原则，用来降低代码之间的耦合度。它有一种Bean对象容器，帮我们创建、管理、装配对象，即bean管理。</p><p><strong>原理</strong>：xml解析、工厂模式、反射</p><p>提供IOC容器的接口：BeanFactory、ApplicationContext(加载配置文件时创建对象)。</p><p>ApplicationContext接口实现类：FileSystemXmlApplicationContext、ClassPathXmlApplicationContext。</p><p>实现IOC的方法：依赖注入。</p><p>bean管理：创建对象、注入属性(装配)。</p><p>bean管理的两种方式：xml配置、注解。</p><p>两种Bean：普通bean、工厂bean。</p><p>bean的作用域：singleton单例（默认）、prototype原型、request、session、application。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.xx.xxx.user&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;propotype&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--原型，调用getBean方法时创建不同的对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Bean的生命周期：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.执行无参构造创建bean</span><br><span class="line">2.调用set方法设置属性值</span><br><span class="line">3.执行初始化方法(postProcess)</span><br><span class="line">4.获取bean实例</span><br><span class="line">5.调用销毁方法销毁</span><br></pre></td></tr></table></figure><h5 id="xml配置创建对象"><a href="#xml配置创建对象" class="headerlink" title="xml配置创建对象"></a>xml配置创建对象</h5><p>配置文件中配置bean。</p><p><code>&lt;bean id=&quot;user&quot; class=&quot;com.xx.xxx.user&quot; name=&quot;别名&quot;&gt;</code></p><p>id：唯一标识</p><p>class：全类名</p><p>默认通过无参构造创建对象。</p><p>有参构造创建：1）通过对象构造器参数下标 2）通过参数名 3）通过参数类型</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.xx.xxx.user&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--第一个参数设值--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;xx&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--通过参数名设值--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;xx&quot;</span> <span class="attr">value</span>=<span class="string">&quot;xx&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;int&quot;</span> <span class="attr">value</span>=<span class="string">&quot;xx&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="xml配置注入属性"><a href="#xml配置注入属性" class="headerlink" title="xml配置注入属性"></a>xml配置注入属性</h5><p>1）set方法。</p><p>2）配置文件中配置属性注入。</p><p><strong>属性注入方式</strong>：property标签 、collection集合、p命名空间 、c命名空间。</p><p>（1）property配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.xx.xxx.user&quot;</span> <span class="attr">name</span>=<span class="string">&quot;别名&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--属性名，值--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;xxx&quot;</span> <span class="attr">value</span>=<span class="string">&quot;xxx&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--null注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;xxx&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">null</span>/&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--特殊符号注入--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--转义或CDATA--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;xxx&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>&lt;![CDATA[&lt;&lt;年龄&gt;&gt;]]&gt;<span class="tag">&lt;/<span class="name">value</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--外部Bean注入，ref指向哪个bean--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--类中需定义对象属性，set方法--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;xxx&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;xxx&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--内部Bean注入(对象注入)--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;xxx&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.xx.xx.Dept&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;xx&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--通过级联赋值，对多个对象属性赋值，需要设置对象属性的get方法--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;property name=&quot;dept.dname&quot; value=&quot;xx&quot;/&gt;--&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--数组注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;xxx&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--map注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;xxx&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;x&quot;</span> <span class="attr">value</span>=<span class="string">&quot;x&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--list类型注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;xxx&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--list中存对象&lt;ref bean=&quot;外部bean对象&quot;&gt;&lt;/ref&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试获取bean对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span>  <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line"><span class="type">xxx</span> <span class="variable">x</span> <span class="operator">=</span> (xxx)context.getBean(<span class="string">&quot;xxx&quot;</span>);</span><br></pre></td></tr></table></figure><p>（2）p命名空间注入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.xx.xx.user&quot;</span> <span class="attr">p:name</span>=<span class="string">&quot;xx&quot;</span> <span class="attr">p:age</span>=<span class="string">&quot;12&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（3）c命名空间注入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:c</span>=<span class="string">&quot;http://www.springframework.org/schema/c&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--constructor构造器参数注入--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--需要有参构造--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.xx.xx.user&quot;</span> <span class="attr">c:name</span>=<span class="string">&quot;xx&quot;</span> <span class="attr">c:age</span>=<span class="string">&quot;12&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（4）公共集合属性提取</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:util</span>=<span class="string">&quot;http://www.springframework.org/schema/util&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/util</span></span></span><br><span class="line"><span class="string"><span class="tag">https://www.springframework.org/schema/util/spring-util.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">util:list</span> <span class="attr">id</span>=<span class="string">&quot;booklist&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">value</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">util:util</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.xx.xx.book&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;list&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;booklist&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h5><p>spring根据属性名称和属性类型自动将bean的属性值注入。</p><p>byName：默认，在容器中寻找set方法中对应的Beand的id，id唯一。</p><p>byType：寻找和自己属性类型相同的对象，class唯一。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;pet&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.xx.xx.pet&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;people&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.xx.xxx.user&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;property name=&quot;name&quot; ref=&quot;pet&quot;/&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="引入外部属性文件"><a href="#引入外部属性文件" class="headerlink" title="引入外部属性文件"></a>引入外部属性文件</h5><p>引入数据库连接池配置</p><p>1、引入依赖</p><p>2、配置context命名空间</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3、引入外部文件jdbc.properties</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>4、配置连接池</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;dbs&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; autowire=&quot;byName&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;prop.driverClass&#125;&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;url&quot; value=&quot;$&#123;prop.url&#125;&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;username&quot; value=&quot;$&#123;prop.userName&#125;&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;password&quot; value=&quot;$&#123;prop.password&#125;&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h5 id="注解创建对象"><a href="#注解创建对象" class="headerlink" title="注解创建对象"></a>注解创建对象</h5><p>bean管理中使用注解创建对象，在要放入spring容器的对象上加上<code>@Component</code>注解，按照mvc架构，它的衍生注解有<code>@Repository</code>、<code>@Service</code>、<code>@Controller</code>，属性值设置使用<code>@Value</code>（相当于property配置）。</p><p>1)引入aop依赖。</p><p>2）添加context命名空间，开启注解扫描。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.xxx&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3）在类上添加相关的bean注解，<code>@Component(value=&quot;xx&quot;)</code></p><p>默认beanid为类名，首字母小写。value值设置beanid。</p><p>其他注解：</p><p><code>@Nullable</code>，在方法上表示返回值可以为空；用在方法的参数上表示参数可空；用在属性上表示属性可为空。</p><p><code>@Scope</code> : 设置作用域。@Scope(“singleton”):单例模式。</p><p><code>@Configuration</code> : 代表这是一个配置类，就像我们之前看的beans.xml。配合@Bean使用将实体类注册，本质是一个<code>@Component</code>。</p><p><code>@Bean</code> : 注册一个bean，就相当于我们之前写的一个bean标签;这个方法的名字，就相当于bean标签中的id属性;这个方法的返回值，就相当于bean标签中的class属性。</p><p><code>@Import</code> : @Import(XXX.class)可以引入其他配置类，使其合并为一个总配置类，使用时通过AnnotationConfig上下文来获取总配置类即可。</p><p><code>@Data</code> : Lombok中的注解,放在实体类上会自己创建set和get方法，toString方法等。</p><p>自定义扫描哪些注解:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.xxx&quot;</span> <span class="attr">use-default-filter</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="注解注入属性"><a href="#注解注入属性" class="headerlink" title="注解注入属性"></a>注解注入属性</h5><p>常用注解：Autowired、Qualifier、Resource、Value(普通类型注入)。</p><p>1）添加context命名约束</p><p>2）开启注解配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.xxx&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>3）添加<code>@Autowired</code>，根据属性类型实现自动装配</p><p>通过属性名称完成属性装配，使用<code>@Qualifier(value=&quot;xxx&quot;)</code>注解指定bean对象。<code>@Resource</code>注解也可以完成自动装配，通过beanid和class类型寻找匹配，名称注入通过name。<code>@Value</code>注解对基本数据类型进行注入。</p><p><strong>@Autowired与@Resource的不同</strong></p><p>1）来源不同<br><code>@Autowired</code>是Spring定义的注解，而<code>@Resource</code>是JSR-250定义的注解。</p><p>2）参数不同<br><code>@Autowired</code>只包含一个参数：required，表示是否开启自动准入，默认是true。而<code>@Resource</code>包含七个参数，其中最重要的两个参数是：name 和 type。<code>@Autowired</code>如果要使用byName，需要使用<code>@Qualifier</code>一起配合。而<code>@Resource</code>如果指定了name，则用byName自动装配，如果指定了type，则用byType自动装配。</p><p>3）使用不同<br><code>@Autowired</code>能够用在：构造器、方法、参数、成员变量和注解上，而<code>@Resource</code>能用在：类、成员变量和方法上。</p><p>4）装配顺序<br><code>@Autowired</code>默认按byType自动装配，而<code>@Resource</code>默认byName自动装配。</p><p><strong>完全注解开发</strong></p><p>Config配置类代替xml文件实现自动装配，实际使用springboot也能完成类似操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan</span><br></pre></td></tr></table></figure><p>在一个类上加上注解<code>@Configuration</code> 代表这是一个配置类，配置类中加上<code>@ComponentScan</code>注解，扫描要注入的bean对象包，替代xml配置文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span>  <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(config.class);</span><br></pre></td></tr></table></figure><h4 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h4><p>面向切面编程，通过预编译方式和动态代理实现程序功能统一维护的一种技术。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p><p> 动态代理分为两大类：<u>基于接口的动态代理</u>，<u>基于类的动态代理</u></p><ul><li>基于接口 : JDK动态代理</li><li>基于类 : cglib</li><li>通过反射实现</li></ul><p><strong>专业术语：</strong></p><p>横切关注点：跨越应用程序多个模块的方法和功能，如日志、安全、缓存、事务。<br>切面aspect：增强的过程，被模块化的特殊对象，它是一个类。<br>通知advice：需要增强的代码逻辑部分。<br>切入点pointcut：实际增强的方法，必须定义。<br>连接点jointpoint：可增强的方法。<br>目标target：被通知的对象。<br>代理proxy：向目标对象通知后创建的对象。</p><p>使用AOP需要导入一个依赖包 :</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>   </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>   </span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="方式一-通过JDK接口实现"><a href="#方式一-通过JDK接口实现" class="headerlink" title="方式一 : 通过JDK接口实现"></a>方式一 : 通过JDK接口实现</h5><p>创建UserService接口和实现类UserServiceImpl，创建实现类的代理对象，并实现aop切入实现，注意导入约束。</p><p>通过Proxy的newProxyInstance方法创建代理对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line"></span><br><span class="line">public class MyProxy&#123;</span><br><span class="line"> public static void main(String[] args)&#123;</span><br><span class="line"> Class[] interfaces = &#123;UserService.class&#125;;</span><br><span class="line"> UserSerivce us = (UserService)Proxy.newProxyInstance(MyProxy.class.getClassLoader(),interfaces,new InvocationHandler()&#123;</span><br><span class="line"> @Override</span><br><span class="line"> public Object invoke(Object proxy,Method method,</span><br><span class="line"> Object[] args) throws Throwable&#123;</span><br><span class="line"> return null;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="方式二-通过AspectJ实现AOP"><a href="#方式二-通过AspectJ实现AOP" class="headerlink" title="方式二 : 通过AspectJ实现AOP"></a>方式二 : 通过AspectJ实现AOP</h5><p>AspectJ是一个独立的AOP框架，结合spring实现aop操作。需要引入aop、aspectj、cglib、aopalliance依赖。</p><p>切入点表达式：</p><p>execution([权限修饰符] [返回类型] [全类名] [方法名] ([参数列表]))</p><p>例：<code>expression=&quot;execution(* com.xxx.xx.UserServiceImpl.*(..))</code></p><p><strong>（1）xml方式实现：</strong></p><p>1）创建类及其增强类(代理对象类)</p><p>2）添加aop命名空间</p><p>3）xml中配置切入点</p><p>定义类：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class book &#123;   </span><br><span class="line">    public void buy()&#123;     </span><br><span class="line">    System.out.println(&quot;---buy-----&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义增强类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Proxy &#123;   </span><br><span class="line">    public void before()&#123;     </span><br><span class="line">    System.out.println(&quot;----方法执行前------&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">    public void after()&#123;     </span><br><span class="line">    System.out.println(&quot;----方法执行后------&quot;); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4）在Spring配置中增强(切入)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--创建两个类的对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.xx.config.book&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;Proxy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.xx.config.Proxy&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--aop的配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span>   </span><br><span class="line"><span class="comment">&lt;!--切入点--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;P&quot;</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">expression</span>=<span class="string">&quot;execution(* com.xx.config.book.buy(..))&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--切面,增强类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;Proxy&quot;</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--advice增强方法--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;p&quot;</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span>/&gt;</span>       </span><br><span class="line"><span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;p&quot;</span> <span class="attr">method</span>=<span class="string">&quot;after&quot;</span>/&gt;</span>   </span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>（2）注解方式实现：</strong></p><p><code>@Aspect</code>注解表示该类为为增强类或代理对象类。</p><p>1）创建类及其增强类(代理对象类)</p><p>2）添加aop命名空间</p><p>3）开启注解扫描和生成代理对象</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;                   http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.xxx&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;annotationProxy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.xxx.config.AnnotationProxy&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--开启aspectj代理对象生成--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>aop:aspectj-autoproxy有一个proxy-target-class属性，默认为false，默认使用jdk动态代理。当为true，表示使用CGLib动态代理。不过即使proxy-target-class设置为false，如果目标类没有声明接口，则spring将自动使用CGLib动态代理。</p><p>注：<code>@EnableAspectJAutoProxy</code>注解可以实现代理对象生成，效果一样。</p><p>4）使用注解创建类及增强类的对象</p><p>使用注解配置不同类型的advice通知（增强逻辑）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">public class AnnotationProxy&#123;</span><br><span class="line">    @Before(</span><br><span class="line">    &quot;execution(* com.x.service.UserServiceImpl.*(..))&quot;) </span><br><span class="line">    public void before()&#123;     </span><br><span class="line">    System.out.println(&quot;------方法执行前------&quot;);</span><br><span class="line">    &#125;   </span><br><span class="line">    @After(</span><br><span class="line">    &quot;execution(* com.x.service.UserServiceImpl.*(..))&quot;)  </span><br><span class="line">    public void after()&#123;       </span><br><span class="line">    System.out.println(&quot;-----方法执行后-------&quot;); </span><br><span class="line">    &#125;   </span><br><span class="line">    @Around(</span><br><span class="line">    &quot;execution(* com.x.service.UserServiceImpl.*(..))&quot;) </span><br><span class="line">    public void around(ProceedingJoinPoint jp) throws Throwable &#123;   </span><br><span class="line">    System.out.println(&quot;环绕前&quot;);  </span><br><span class="line">   System.out.println(&quot;签名:&quot;+jp.getSignature());   </span><br><span class="line">   //执行目标方法proceed     </span><br><span class="line">    Object proceed = jp.proceed();     </span><br><span class="line">    System.out.println(&quot;环绕后&quot;);    </span><br><span class="line">        System.out.println(proceed); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>五种advice通知(增强)类型：</strong></p><p><code>@Before</code>前置通知。</p><p><code>@Around</code>环绕通知</p><p><code>@After</code>最终通知</p><p><code>@AfterRetuning</code>后置通知</p><p><code>@AfterThrowing</code>异常通知</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">环绕之前...</span><br><span class="line">before...</span><br><span class="line">目标方法执行...</span><br><span class="line">环绕之后...</span><br><span class="line">after...</span><br><span class="line">afterReturning...</span><br></pre></td></tr></table></figure><p>提取公共切入点：定义一个方法，添加注解<code>@Pointcut(value=&quot;切入点表达式&quot;)</code>，在advice注解设置value值为方法名()。当有多个增强类对同一切入点增强，使用<code>@Order()</code>注解设置增强类优先级。</p><h4 id="JdbcTemplate"><a href="#JdbcTemplate" class="headerlink" title="JdbcTemplate"></a>JdbcTemplate</h4><p>它是spring对jdbc的封装。</p><p>1）导入mysql、druid、jdbc、tx、orm依赖包。</p><p>2）配置数据库连接池</p><p>在引入外部文件中已经配置过。</p><p>3）配置JdbcTemplate对象</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>4）开启注解扫描，在dao层注入jdbcTemplate对象</p><h4 id="Spring事务管理"><a href="#Spring事务管理" class="headerlink" title="Spring事务管理"></a>Spring事务管理</h4><p>Spring在不同的事务管理API之上定义了一个抽象层，使得开发人员不必了解底层的事务管理器API。Spring的声明事务管理底层原理使用aop。</p><p>Spring支持编程式事务管理和声明式的事务管理。声明式的事务管理有两种实现方式：注解和xml配置。</p><p><strong>注解方式</strong></p><p>1）使用Spring管理事务，导入tx事务依赖，命名空间导入 : tx。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;  http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">https://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/tx/spring-tx.xsd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2）创建事务管理器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span>      </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3）开启事务注解</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span></span></span><br><span class="line"><span class="tag"> = <span class="string">&quot;transactionManager&quot;</span>/&gt;</span>   </span><br></pre></td></tr></table></figure><p>4）在service类上添加事务注解</p><p><code>@Transactional</code>，添加在类上，类中方法开启事务。spring定义了7种事务传播行为。</p><p><strong>xml方式</strong></p><p>1）配置事务管理器</p><p>2）配置事务通知</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置事务通知--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span>      </span><br><span class="line"><span class="comment">&lt;!--配置哪些方法使用什么样的事务,配置事务的传播特性--&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;add&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span>       </span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;delete&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span>       </span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;update&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span>       </span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;search*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span>   </span><br><span class="line"> <span class="comment">&lt;!--该方法只读，无法对数据库进行操作--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;get&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span>   <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3）配置aop，切入点、切面</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置aop事务--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;txPointcut&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">expression</span>=<span class="string">&quot;execution(* com.x.dao.*.*(..))&quot;</span>/&gt;</span>   </span><br><span class="line"><span class="comment">&lt;!--配置切面--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;txPointcut&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>完全注解开发</strong></p><p>使用<code>@Configuration</code>、<code>@ComponentScan</code>、<code>@EnableTransactionManager</code>、<code>@Bean</code>注解完成事务。创建数据库连接池，事务管理器，jdbcTemplate。</p><h4 id="整合Mybatis"><a href="#整合Mybatis" class="headerlink" title="整合Mybatis"></a>整合Mybatis</h4><p><strong>编写实体类</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class User &#123; </span><br><span class="line">  private int id;  </span><br><span class="line">  private String name;    </span><br><span class="line">  private String pwd; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编写mybatis-config核心配置文件</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span>  <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span>  <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span>      </span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.x.pojo&quot;</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span>          </span><br><span class="line"><span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span>      </span><br><span class="line"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span>            </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=false<span class="symbol">&amp;amp;</span>useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span>/&gt;</span>             </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span>               </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span>          </span><br><span class="line"><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span>      </span><br><span class="line"><span class="tag">&lt;/<span class="name">environment</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span>       </span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.x.dao&quot;</span>/&gt;</span>   </span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>编写UserDao接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface UserMapper &#123;  </span><br><span class="line">   public List&lt;User&gt; selectUser();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编写接口对应的Mapper映射文件</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span>  <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span>   <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.xxx.dao.UserMapper&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUser&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span>   </span><br><span class="line">    select * from user   </span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>导入spring-webmvc、spring-jdbc、mybatis、mybatis-spring、mysql-connector-java、aspectjweaver包。</p><p>配置Maven静态资源过滤问题：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span>      </span><br><span class="line"><span class="tag">&lt;<span class="name">resource</span>&gt;</span>         </span><br><span class="line"><span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span>       </span><br><span class="line"><span class="tag">&lt;<span class="name">includes</span>&gt;</span>            </span><br><span class="line"><span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span>            </span><br><span class="line"><span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span>         </span><br><span class="line"><span class="tag">&lt;/<span class="name">includes</span>&gt;</span>        </span><br><span class="line"><span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span>      </span><br><span class="line"><span class="tag">&lt;/<span class="name">resource</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>Mybatis-Spring</strong></p><p>MyBatis-Spring 会帮助你将 MyBatis 代码无缝地整合到 Spring 中。它将允许 MyBatis 参与到 Spring 的事务管理之中，创建映射器 mapper 和 SqlSession 并注入到 bean 中，以及将 Mybatis 的异常转换为 Spring 的 DataAccessException。最终，可以做到应用代码不依赖于 MyBatis，Spring 或 MyBatis-Spring。</p><p>在 MyBatis-Spring 中，可使用SqlSessionFactoryBean来创建 SqlSessionFactory。要配置这个工厂 bean，只需要把下面代码放在 Spring 的 XML 配置文件中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="实现一"><a href="#实现一" class="headerlink" title="实现一"></a>实现一</h5><p>引入Spring配置文件beans.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span>   <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>      <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置数据源替换mybatis数据源</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置数据源：可以用第三方的，也可用Spring的--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true<span class="symbol">&amp;amp;</span>useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span>/&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置SqlSessionFactory，关联Mybatis</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置SqlSessionFactory--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span>   </span><br><span class="line"><span class="comment">&lt;!--关联Mybatis--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mybatis-config.xml&quot;</span>/&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperLocations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:com/kuang/dao/*.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注册sqlSessionTemplate，关联sqlSessionFactory</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--注册sqlSessionTemplate , 关联sqlSessionFactory--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSession&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionTemplate&quot;</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!--利用构造器注入--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sqlSessionFactory&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>增加Dao接口的实现类；私有化sqlSessionTemplate</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class UserDaoImpl implements UserMapper &#123;  </span><br><span class="line"> //sqlSession不用我们自己创建了，Spring来管理  </span><br><span class="line">private SqlSessionTemplate sqlSession;   </span><br><span class="line">public void setSqlSession(SqlSessionTemplate sqlSession) &#123;       </span><br><span class="line">this.sqlSession = sqlSession; </span><br><span class="line">&#125;   </span><br><span class="line">public List&lt;User&gt; selectUser() &#123;   </span><br><span class="line">UserMapper mapper = sqlSession.getMapper(UserMapper.class);    </span><br><span class="line"> return mapper.selectUser();  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册bean实现</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.x.dao.UserDaoImpl&quot;</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSession&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sqlSession&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当前Mybatis配置文件内容:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span>  <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span>  <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.x.pojo&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test2()&#123;    </span><br><span class="line">ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);    </span><br><span class="line">  UserMapper mapper = (UserMapper) context.getBean(&quot;userDao&quot;);</span><br><span class="line">  List&lt;User&gt; user = mapper.selectUser();    </span><br><span class="line">  System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="实现二"><a href="#实现二" class="headerlink" title="实现二"></a>实现二</h5><p>dao继承Support类 , 直接利用 getSqlSession() 获得 , 然后直接注入SqlSessionFactory . 比起方式一 , 不需要管理SqlSessionTemplate , 而且对事务的支持更加友好。</p><p>将UserDaoImpl修改一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class UserDaoImpl extends SqlSessionDaoSupport implements UserMapper &#123;  </span><br><span class="line">public List&lt;User&gt; selectUser() &#123;   </span><br><span class="line">UserMapper mapper = getSqlSession().getMapper(UserMapper.class);     </span><br><span class="line">return mapper.selectUser(); </span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><p>修改bean的配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.xx.dao.UserDaoImpl&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="WebFlux函数式编程"><a href="#WebFlux函数式编程" class="headerlink" title="WebFlux函数式编程"></a>WebFlux函数式编程</h4><p>spring5的新功能，类似springMVC，用于web开发，流行的异步非阻塞的响应式编程框架，基于Reactor的api实现。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Spring是一个开放源代码的JavaEE设计层面框架，解决了业务逻辑层和其他各层的松耦合问题，因此它将面向接口的编程思想贯穿整个系统应用，它的核心是IOC控制反转和AOP面向切面编程</summary>
    
    
    
    <category term="java" scheme="https://aachou.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>mybatisplus入门</title>
    <link href="https://aachou.github.io/2023/1225/"/>
    <id>https://aachou.github.io/2023/1225/</id>
    <published>2023-12-25T07:11:52.000Z</published>
    <updated>2023-12-31T10:25:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>Mybatis是一种关系型数据库的ORM持久化框架，封装了JDBC和sqlmap，使java代码和DAO分离，提高了开发效率。<span id="more"></span></p><h4 id="Mybatis和Hibernate对比"><a href="#Mybatis和Hibernate对比" class="headerlink" title="Mybatis和Hibernate对比"></a>Mybatis和Hibernate对比</h4><p>Hibernate和JPA：操作简便，开发效率高，不容易优化，反射操作太多影响性能。</p><p>Mybatis：轻量级，性能出色，开发效率稍低。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在resource文件夹下创建mybatis-config.xml配置文件。</p><p>—–表—–实体类——mapper接口—–映射文件–</p><p>java&#x3D;数据库概念关系：实体类&#x3D;表，类属性&#x3D;字段，对象&#x3D;记录&#x2F;行，保持一致。xml映射文件的namespace命名域需要与mapper接口的全类名一致，sql语句的id要与mapper接口中的方法名一致。通过调用接口的方法来执行对应sql语句！</p><p>mapper接口的名字和mapper映射文件的名字保存一致，所在包包名保存一致，最好为mapper。</p><p>mybatis提供一个操作数据库的对象SqlSession，通过SqlSession.getMap获取mapper接口实现类的对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from user where username like &quot;%&quot;#&#123;username&#125;&quot;%&quot;;</span><br><span class="line">select * from user where username like &#x27;%$&#123;username&#125;%&#x27;;</span><br></pre></td></tr></table></figure><p>在核心配置文件中mybaitis-plus配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line"><span class="comment">#控制台输出日志</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br><span class="line">    <span class="attr">map-underscore-to-camel-case:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.xxx.xxx.entity</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mapper/*.xml</span></span><br></pre></td></tr></table></figure><p>使用步骤：</p><p>1、导入依赖</p><p>2、配置依赖</p><p>3、创建pojo</p><p>4、继承BaseMapper，创建mapper接口。</p><p>5、在spring应用程序上添加<code>@MapperScan(&quot;xxx&quot;)</code>注解或在mapper接口上添加<code>@Mapper</code>注解。</p><p>6、在service层中继承实现类ServiceImpl&lt;BaseMapper, Object&gt;，实现自定义接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;ProductMapper, Product&gt;</span><br><span class="line"><span class="comment">//业务层帮我们创建mapper对象</span></span><br></pre></td></tr></table></figure><h4 id="主键自增策略"><a href="#主键自增策略" class="headerlink" title="主键自增策略"></a>主键自增策略</h4><p>mysql默认插入数据主键自增，可以在数据库中查看。为了弥补数据库默认自增的不足，比如会出现单点故障。MyBatis-Plus默认的主键策略是：ASSIGN_ID （使用了雪花算法）。mybaitis-plus需要在实体类属性上加上主键自增注解<code>@TableId(type=IdType.AUTO)</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableId(value = &quot;product_id&quot;,type = IdType.AUTO)</span></span><br></pre></td></tr></table></figure><p>type: AUTO自增、ID_WORKER默认唯一id、UUID全局唯一id。</p><p>字段主键<code>@TableField(exist = false) </code>：该字段在数据库中不存在。</p><h4 id="自动填充和乐观锁"><a href="#自动填充和乐观锁" class="headerlink" title="自动填充和乐观锁"></a>自动填充和乐观锁</h4><h5 id="自动填充"><a href="#自动填充" class="headerlink" title="自动填充"></a>自动填充</h5><p>项目中经常会遇到一些数据，每次都使用相同的方式填充，例如记录的创建时间，更新时间等。我们可以使用MyBatis Plus的自动填充功能，完成这些字段的赋值工作。</p><p> 实体上增加字段并添加自动填充注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableField(fill = FieldFill.INSERT)</span></span><br><span class="line"><span class="keyword">private</span> Date createTime;  </span><br><span class="line"><span class="comment">//create_time</span></span><br><span class="line"><span class="meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span></span><br><span class="line"><span class="keyword">private</span> Date updateTime; </span><br><span class="line"><span class="comment">//update_time</span></span><br></pre></td></tr></table></figure><p>实现元对象处理器接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMetaObjectHandler</span> <span class="keyword">implements</span> <span class="title class_">MetaObjectHandler</span> &#123;    </span><br><span class="line"> <span class="comment">//mp执行添加操作，这个方法执行    </span></span><br><span class="line"><span class="meta">@Override</span>   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertFill</span><span class="params">(MetaObject metaObject)</span> &#123;       </span><br><span class="line"><span class="built_in">this</span>.setFieldValByName(<span class="string">&quot;createTime&quot;</span>,<span class="keyword">new</span> <span class="title class_">Date</span>(),metaObject); </span><br><span class="line"><span class="built_in">this</span>.setFieldValByName(<span class="string">&quot;updateTime&quot;</span>,<span class="keyword">new</span> <span class="title class_">Date</span>(),metaObject);    &#125;    </span><br><span class="line"><span class="comment">//mp执行修改操作，这个方法执行    </span></span><br><span class="line"><span class="meta">@Override</span>    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateFill</span><span class="params">(MetaObject metaObject)</span> &#123;     </span><br><span class="line">  <span class="built_in">this</span>.setFieldValByName(<span class="string">&quot;updateTime&quot;</span>,<span class="keyword">new</span> <span class="title class_">Date</span>(),metaObject);    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h5><p>当要更新一条记录的时候，希望这条记录没有被别人更新，也就是说实现线程安全的数据更新。</p><p>取出记录时，获取当前version更新时，带上这个version执行更新时， set version </p><p>修改实体类，添加<code>@Version</code>注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Version</span></span><br><span class="line"><span class="keyword">private</span> Integer version;</span><br></pre></td></tr></table></figure><p>创建包config，创建文件MybatisPlusConfig.java， 此时可以删除主类中的 <code>@MapperScan</code>扫描注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.xxx.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MpConfig</span> &#123;   </span><br><span class="line">    <span class="meta">@Bean</span>    </span><br><span class="line"><span class="keyword">public</span> OptimisticLockerInterceptor  <span class="title function_">optimisticLockerInterceptor</span><span class="params">()</span> &#123;       </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OptimisticLockerInterceptor</span>(); &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="和-获取参数值"><a href="#和-获取参数值" class="headerlink" title="${}和#{}获取参数值"></a>${}和#{}获取参数值</h4><p>字段名和属性名一致：ResultType</p><p>字段名和属性名不一致：给字段起别名，别名为属性名；在mybatis中配置驼峰命名map-underscore-to-camel-case: true；定义一个resultMap，通过property和column字段绑定</p><h4 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h4><p>collection集合</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;DeptAndEmpResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Dept&quot;</span> <span class="attr">autoMapping</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;dept_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;deptId&quot;</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--属性emps集合中元素的类型--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;emps&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;eid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;empName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;emp_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p>分步查询：</p><p>select：设置分步查询的唯一标识，mapper接口的全类名和方法名。</p><p>column：查询的字段。</p><p>ofType：查询中的集合内的数据类型。</p><h4 id="多对一映射"><a href="#多对一映射" class="headerlink" title="多对一映射"></a>多对一映射</h4><p><code>resultMap级联属性赋值</code>;</p><p><code>&lt;association&gt;标签</code>；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;MinMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Moneyin&quot;</span> <span class="attr">autoMapping</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;in_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;inId&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--将查询出的账户的列数据和账户实体映射起来--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;zhanghu&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Zhanghu&quot;</span> <span class="attr">autoMapping</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--将查询出的收入分类的列数据和收入分类实体映射起来--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;categoryin&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Categoryin&quot;</span> <span class="attr">autoMapping</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>分步查询</code></p><p>优点：实现了延迟加载，避免执行过多的sql语句。配置文件配置如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">lazyLoadingEnabled</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">#开启时所有关联对象都延迟加载</span></span><br><span class="line"><span class="attr">aggressiveLazyLoading</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure><p>当开启全局延迟加载后，查询可通过fetchType属性实现eager立即加载或lazy延迟加载。</p><h4 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h4><p>尽管mybaitis-plus帮我们省去了动态sql的编写，但仍必要了解什么是动态sql。</p><p>本质：标签</p><p>作用：动态拼接sql语句</p><p>if标签</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmp&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;Emp&quot;</span> &gt;</span></span><br><span class="line">    select * from t_emp where 1=1</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;ename!=null and ename!=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">    ename = #&#123;ename&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age!=null and age!=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">    and age = #&#123;age&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email !=null and email!=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">    and email = #&#123;email&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引用定义好的sql语句--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;include refid=&quot;minSql&quot;&gt;&lt;/include&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>where标签</p><p>根据标签中的内容自动生成where关键字，并将条件内容前多余的and、or关键字去掉，后面的关键字无法忽略，如果没有内容则不会生成where。</p><p>trim标签</p><p>prefix|suffix，在标签内容的前后添加内容</p><p>choose、when标签</p><p>choose…when….otherwise &#x3D;switch….case… default </p><p>foreach标签</p><p>​collection：需要循环的数组和集合</p><p>​item：表示数组和集合中的每一个元素</p><p>​separator：循环之间的分割符</p><p>​批量删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;delete id=&quot;deleteMore&quot;&gt;</span><br><span class="line">    delete from t_emp where eid in(</span><br><span class="line">    &lt;foreach collection=&quot;eids&quot; item=&quot;eid&quot; separator=&quot;,&quot;&gt;</span><br><span class="line">    #&#123; eid &#125;</span><br><span class="line">    &lt;/foreach&gt;</span><br><span class="line">    )</span><br><span class="line">&lt;/delete&gt;</span><br></pre></td></tr></table></figure><p>​批量增加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id=&quot;insertMore&quot;&gt;</span><br><span class="line">    insert into t_emp values</span><br><span class="line">    &lt;foreach collection=&quot;emps&quot; item=&quot;emp&quot; separator=&quot;,&quot;&gt;</span><br><span class="line">    (null,#&#123; emp.empName &#125;,#&#123; emp.age &#125;,#&#123; emp.sex &#125;,#&#123; emp.email &#125;,null)</span><br><span class="line">    &lt;/foreach&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>sql标签</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--定义可以被复用的查询sql--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;minSql&quot;</span>&gt;</span></span><br><span class="line">    select</span><br><span class="line">        mi.in_id, mi.single_in, mi.zhanghu_id, mi.categoryin_id, mi.date, mi.beizhu,</span><br><span class="line">        z.zhanghu_name,</span><br><span class="line">        z.zhanghu_money,</span><br><span class="line">        z.create_time,</span><br><span class="line">        cin.categoryin_name</span><br><span class="line">    from moneyin mi</span><br><span class="line">    join zhanghu z</span><br><span class="line">    on mi.zhanghu_id=z.zhanghu_id</span><br><span class="line">    join categoryin cin</span><br><span class="line">    on mi.categoryin_id=cin.categoryin_id</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--引用定义好的sql语句--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;minSql&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>针对查询，将数据暂时保存起来以备下一次查询。cache hit ratio</p><h5 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h5><p>默认开启，sqlSession级别，对于同一的sqlSession的查询，会从缓存中取对象，如果是同一查询则能够成功取出对象，若两次查询之间进行了一次增删改操作则会失效(相当于清除缓存)，clearCache()手动清除缓存。</p><h5 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h5><p>sqlSeesionFactory级别，通过同一sqlSeesionFactory创建的sqlSeesion查询的结果会被缓存，此后再执行相同的查询就会从缓存中取。</p><p>二级缓存开启条件：在核心配置文件中配置cacheEnabled&#x3D;”true”；在映射文件中设置cache标签，在sqlSeesion关闭或提交后有效；查询的实体类型必须实现序列化接口。</p><p>查询顺序：先查二级缓存，没有命中再查一级缓存，最后查数据库 ，sqlSession关闭或提交后一级缓存保存到二级。</p><h5 id="第三方缓存"><a href="#第三方缓存" class="headerlink" title="第三方缓存"></a>第三方缓存</h5><p>代替二级缓存。</p><p>1）添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--在pom.xml中添加--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.caches<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--SLF4J是Simple Logging Facade for Java的简写，即Java简单日志门面，用来服务于各种各样的日志框架，比如java.util.logging、logback和log4j--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2）导入jar包</p><p>slf4j-api，mybatis-ehcache，ehcache，logback-classic。</p><p>3）配置第三方缓存配置文件ehchche.xml</p><p>4）设置二级缓存的类型</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--在映射文件中添加--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">&quot;第三方缓存全类名&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="pagehelper分页插件"><a href="#pagehelper分页插件" class="headerlink" title="pagehelper分页插件"></a>pagehelper分页插件</h4><p>1、添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&lt;!--分页--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、在核心配置文件中添加插件配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置分页</span></span><br><span class="line"><span class="comment">#pagehelper</span></span><br><span class="line"><span class="attr">pagehelper:</span></span><br><span class="line">  <span class="attr">helper-dialect:</span> <span class="string">mysql</span></span><br><span class="line">  <span class="attr">reasonable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">support-methods-arguments:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">params:</span> <span class="string">count=countSql</span></span><br></pre></td></tr></table></figure><p>分页插件的使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PageInfo&lt;Product&gt; <span class="title function_">listByPage</span><span class="params">(Integer page, Integer limit, String searchProductName)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">limit <span class="number">0</span>,<span class="number">10</span></span><br><span class="line"><span class="comment">--limit 起始下标index,pageSize页大小</span></span><br></pre></td></tr></table></figure><p>index当前页起始索引，pageSize每页显示条数，pageNum当前页码，total总记录数，pages页数，prePage上一页页码，nextPage下一页页码，navigatePages导航页码数，navigatepageNums导航分页页码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用PageHelper插件，设置分页参数</span></span><br><span class="line">PageHelper.startPage(page,limit);</span><br><span class="line"><span class="comment">//构建查询条件包装器</span></span><br><span class="line"><span class="type">QueryWrapper</span> <span class="variable">qw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>();</span><br><span class="line"><span class="keyword">if</span>(!Objects.isNull(searchProductName)) &#123;</span><br><span class="line">    qw.like(<span class="string">&quot;pro_name&quot;</span>, searchProductName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现条件查询</span></span><br><span class="line"><span class="type">List</span> <span class="variable">products</span> <span class="operator">=</span> <span class="built_in">this</span>.list(qw);</span><br><span class="line"><span class="comment">//使用分页对象封装查询结果</span></span><br><span class="line">PageInfo&lt;Product&gt; pi = <span class="keyword">new</span> <span class="title class_">PageInfo</span>&lt;&gt;(products);</span><br><span class="line"><span class="keyword">return</span> pi;</span><br></pre></td></tr></table></figure><p>pageinfo对象：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PageInfo<span class="punctuation">&#123;</span>pageNum=<span class="number">1</span><span class="punctuation">,</span> pageSize=<span class="number">5</span><span class="punctuation">,</span> size=<span class="number">2</span><span class="punctuation">,</span> startRow=<span class="number">1</span><span class="punctuation">,</span> endRow=<span class="number">2</span><span class="punctuation">,</span> total=<span class="number">2</span><span class="punctuation">,</span> pages=<span class="number">1</span><span class="punctuation">,</span> </span><br><span class="line">         list=Page<span class="punctuation">&#123;</span>count=<span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> pageNum=<span class="number">1</span><span class="punctuation">,</span> pageSize=<span class="number">5</span><span class="punctuation">,</span> startRow=<span class="number">0</span><span class="punctuation">,</span> endRow=<span class="number">5</span><span class="punctuation">,</span> total=<span class="number">2</span><span class="punctuation">,</span> pages=<span class="number">1</span><span class="punctuation">,</span> reasonable=<span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> pageSizeZero=<span class="literal"><span class="keyword">false</span></span><span class="punctuation">&#125;</span><span class="punctuation">[</span></span><br><span class="line">        Product(productId=<span class="number">1</span><span class="punctuation">,</span> proName=股票<span class="punctuation">,</span> proMoney=<span class="number">1000.00</span><span class="punctuation">,</span> description=)<span class="punctuation">,</span></span><br><span class="line">        Product(productId=<span class="number">2</span><span class="punctuation">,</span> proName=黄金<span class="punctuation">,</span> proMoney=<span class="number">1000.00</span><span class="punctuation">,</span> description=)</span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span> prePage=<span class="number">0</span><span class="punctuation">,</span> nextPage=<span class="number">0</span><span class="punctuation">,</span> isFirstPage=<span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> isLastPage=<span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> hasPreviousPage=<span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span> hasNextPage=<span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span> navigatePages=<span class="number">8</span><span class="punctuation">,</span> navigateFirstPage=<span class="number">1</span><span class="punctuation">,</span> navigateLastPage=<span class="number">1</span><span class="punctuation">,</span> navigatepageNums=<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><p>1）通过多个 id 批量查询</p><p> 完成了动态sql的foreach的功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//多个id批量查询</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelect1</span><span class="params">()</span> &#123;   </span><br><span class="line">List&lt;User&gt; users=userMapper.selectBatchIds(</span><br><span class="line">    Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));    </span><br><span class="line">    System.out.println(users);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）简单的条件查询</p><p> 通过map封装查询条件</p><p> 注意：map中的key对应数据库中的列名。如：数据库user_id，实体类是userId，这时map的key需要填写user_id</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单条件查询</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelect2</span><span class="params">()</span> &#123;    </span><br><span class="line">    Map&lt;String, Object&gt; columnMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();    </span><br><span class="line">    columnMap.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;Jack&quot;</span>);                  </span><br><span class="line">    columnMap.put(<span class="string">&quot;age&quot;</span>,<span class="number">20</span>);   </span><br><span class="line">    List&lt;User&gt; users = userMapper.selectByMap(columnMap);     </span><br><span class="line">    System.out.println(users);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="PaginationInterceptor分页"><a href="#PaginationInterceptor分页" class="headerlink" title="PaginationInterceptor分页"></a>PaginationInterceptor分页</h4><p> MyBatis Plus自带分页插件，只要简单的配置即可实现分页功能。</p><h5 id="添加分页插件"><a href="#添加分页插件" class="headerlink" title="添加分页插件"></a>添加分页插件</h5><p> 配置类中添加<code>@Bean</code>配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** * 分页插件 */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> PaginationInterceptor <span class="title function_">paginationInterceptor</span><span class="params">()</span> &#123;    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PaginationInterceptor</span>();&#125;</span><br></pre></td></tr></table></figure><h5 id="测试-selectPage-分页"><a href="#测试-selectPage-分页" class="headerlink" title="测试 selectPage 分页"></a>测试 selectPage 分页</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分页查询</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectPage</span><span class="params">()</span> &#123;       </span><br><span class="line">Page&lt;User&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>(<span class="number">1</span>,<span class="number">3</span>);      </span><br><span class="line">Page&lt;User&gt; userPage = userMapper.selectPage(page, <span class="literal">null</span>);      <span class="comment">//返回对象得到分页所有数据        </span></span><br><span class="line"><span class="type">long</span> <span class="variable">pages</span> <span class="operator">=</span> userPage.getPages(); </span><br><span class="line"><span class="comment">//总页数    </span></span><br><span class="line"><span class="type">long</span> <span class="variable">current</span> <span class="operator">=</span> userPage.getCurrent(); </span><br><span class="line"><span class="comment">//当前页       </span></span><br><span class="line">List&lt;User&gt; records = userPage.getRecords(); </span><br><span class="line"><span class="comment">//查询数据集合     </span></span><br><span class="line"><span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> userPage.getTotal();</span><br><span class="line"><span class="comment">//总记录数      </span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">hasNext</span> <span class="operator">=</span> userPage.hasNext(); </span><br><span class="line"> <span class="comment">//下一页        </span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">hasPrevious</span> <span class="operator">=</span> userPage.hasPrevious(); </span><br><span class="line"> <span class="comment">//上一页 </span></span><br><span class="line"> System.out.println(pages);        </span><br><span class="line">System.out.println(current);        </span><br><span class="line">System.out.println(records);     </span><br><span class="line">System.out.println(total);       </span><br><span class="line">System.out.println(hasNext);      </span><br><span class="line">System.out.println(hasPrevious);       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="测试-selecMapsPage-分页"><a href="#测试-selecMapsPage-分页" class="headerlink" title="测试 selecMapsPage 分页"></a>测试 selecMapsPage 分页</h5><p> 当指定了特定的查询列时，希望分页结果列表只返回被查询的列，而不是很多null值。</p><p> 测试selectMapsPage分页，结果集是Map</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectMapsPage</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//Page不需要泛型</span></span><br><span class="line">Page&lt;Map&lt;String, Object&gt;&gt; page = newPage&lt;&gt;(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">Page&lt;Map&lt;String, Object&gt;&gt; pageParam = userMapper.selectMapsPage(page, <span class="literal">null</span>);</span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; records = pageParam.getRecords();</span><br><span class="line">records.forEach(System.out::println);</span><br><span class="line">System.out.println(pageParam.getCurrent());</span><br><span class="line">System.out.println(pageParam.getPages());</span><br><span class="line">System.out.println(pageParam.getSize());</span><br><span class="line">System.out.println(pageParam.getTotal());</span><br><span class="line">System.out.println(pageParam.hasNext());</span><br><span class="line">System.out.println(pageParam.hasPrevious());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="性能分析插件"><a href="#性能分析插件" class="headerlink" title="性能分析插件"></a>性能分析插件</h4><p>性能分析拦截器，用于输出每条SQL语句及其执行时间，可以设置最大执行时间，超过时间会抛出异常，该插件只用于开发环境，不建议生产环境使用。在MP中提供了对SQL执行的分析的插件，可用作阻断全表更新、删除的操作。</p><p>注意：该插件仅适用于开发环境，不适用于生产环境。</p><p>1、配置springboot：SQL分析插件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;com.baomidou.mybatisplus.extension.plugins.PerformanceInterceptor&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxTime&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;format&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectById</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setId(<span class="number">2L</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> user.selectById();</span><br><span class="line">    System.out.println(user1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="条件构造器"><a href="#条件构造器" class="headerlink" title="条件构造器"></a>条件构造器</h4><p>Wrapper ： 条件构造抽象类，最顶端父类</p><p>AbstractWrapper ： 用于查询条件封装，生成 sql 的 where 条件</p><p>QueryWrapper ： 查询条件封装</p><p>UpdateWrapper ： Update 条件封装</p><p>AbstractLambdaWrapper ： 使用Lambda 语法</p><p>LambdaQueryWrapper ：用于Lambda语法使用的查询Wrapper</p><p>LambdaUpdateWrapper ： Lambda 更新封装Wrapper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">QueryWrapper&lt;user&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">wrapper.notLike(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;e&quot;</span>).likeRight(<span class="string">&quot;email&quot;</span>,<span class="string">&quot;t&quot;</span>);</span><br><span class="line">List&lt;Map&lt;String,Object&gt;&gt; maps=userMapper.selectMaps(wrapper);</span><br><span class="line">maps.forEach(System.out::println);</span><br><span class="line"><span class="comment">//id排序</span></span><br><span class="line">QueryWrapper&lt;user&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">wrapper.orderByDesc(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">List&lt;User&gt; users = userWrapper.selectList(wrapper);</span><br><span class="line">users.forEach(System.out::println);</span><br></pre></td></tr></table></figure><h4 id="MBG逆向工程"><a href="#MBG逆向工程" class="headerlink" title="MBG逆向工程"></a>MBG逆向工程</h4><p>正向工程：先创建java实体类，框架负责根据实体类生成数据库表。</p><p>逆向工程：先创建数据库表，框架根据表生成java实体类，mapper接口和映射文件。</p><h4 id="代码生成器"><a href="#代码生成器" class="headerlink" title="代码生成器"></a>代码生成器</h4><p>1、依赖导入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>最新版本<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、引入相应包</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.AutoGenerator;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.</span><br><span class="line">    GlobalConfig</span><br></pre></td></tr></table></figure><p>3、创建一个代码自动生成器对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AutoGenerator</span> <span class="variable">mpg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AutoGenerator</span>();</span><br><span class="line"><span class="comment">//全局配置</span></span><br><span class="line"><span class="type">GlobalConfig</span> <span class="variable">gc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GlobalConfig</span>();</span><br><span class="line"><span class="type">String</span> <span class="variable">projectPath</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.dir&quot;</span>);</span><br><span class="line">gc.setOutputDir(projectPath+<span class="string">&quot;/src/main/java&quot;</span>);</span><br><span class="line">gc.setAuthor(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">gc.setFileOverride(<span class="literal">false</span>);</span><br><span class="line">gc.setOpen(<span class="literal">false</span>);</span><br><span class="line">gc.setServiceName(<span class="string">&quot;%sService&quot;</span>);<span class="comment">//去前缀I</span></span><br><span class="line">gc.getIdType(IdType.ID_WORKER);</span><br><span class="line">gc.setDateType(Date.ONLY_DATE);</span><br><span class="line">mpg.setGlobalConfig(gc);</span><br><span class="line"><span class="comment">//设置数据源</span></span><br><span class="line"><span class="type">DataSourceConfig</span> <span class="variable">dsc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceConfig</span>();</span><br><span class="line">dsc.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/xxx?</span></span><br><span class="line"><span class="string">     useSSL=false&amp;useUnicode=utf8&quot;</span>);</span><br><span class="line">dsc.setDriverName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">dsc.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">dsc.password(<span class="string">&quot;xxxxxx&quot;</span>);</span><br><span class="line">dsc.setDbType(DbType.MYSQL);</span><br><span class="line">mpg.setDataSource(dsc);</span><br><span class="line"><span class="comment">//java源码包</span></span><br><span class="line"><span class="type">PackageConfig</span> <span class="variable">pc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PackageConfig</span>();</span><br><span class="line">pc.setModuleName(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">pc.setParentName(<span class="string">&quot;com.xxx&quot;</span>);</span><br><span class="line">pc.setEntity(<span class="string">&quot;entity&quot;</span>);</span><br><span class="line">pc.setMapper(<span class="string">&quot;mapper&quot;</span>);</span><br><span class="line">pc.setService(<span class="string">&quot;service&quot;</span>);</span><br><span class="line">pc.setController(<span class="string">&quot;controller&quot;</span>);</span><br><span class="line">mpg.setPackageInfo(pc);</span><br><span class="line"><span class="comment">//设置策略</span></span><br><span class="line"><span class="type">StrateryConfig</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StrateryConfig</span>();</span><br><span class="line">sc.setInclude(<span class="string">&quot;xxx&quot;</span>,<span class="string">&quot;xxx&quot;</span>,<span class="string">&quot;xxx&quot;</span>);<span class="comment">//要映射的表名</span></span><br><span class="line">sc.setNaming(NamingStratery.underline_to_camel);</span><br><span class="line">sc.setColumnNaming(NamingStratery.underline_to_camel);</span><br><span class="line">sc.setEntityLombokModel(<span class="literal">true</span>);<span class="comment">//使用lombok</span></span><br><span class="line">sc.setLogicDeleteFieldName(<span class="string">&quot;deleted&quot;</span>);</span><br><span class="line"><span class="comment">//配置自动填充</span></span><br><span class="line"><span class="type">TableFill</span> <span class="variable">xxCreate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TableFill</span>(<span class="string">&quot;xx_create&quot;</span>,FiledFill.INSERT);</span><br><span class="line"><span class="type">TableFill</span> <span class="variable">xxModified</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TableFill</span>(<span class="string">&quot;xx_modified&quot;</span>,FiledFill.INSERT);</span><br><span class="line">ArrayList&lt;TableFill&gt; tfs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">tfs.add(xxCreate);</span><br><span class="line">tfs.add(xxModified);</span><br><span class="line">sc.setTableFillList(tfs);</span><br><span class="line"><span class="comment">//乐观锁</span></span><br><span class="line">sc.setVersionFieldName(<span class="string">&quot;version&quot;</span>);</span><br><span class="line">sc.setRestControllerStyle(<span class="literal">true</span>);<span class="comment">//rest风格</span></span><br><span class="line"><span class="comment">//sc.setControllerMappingHyphenStyle(true);</span></span><br><span class="line">mpg.setStratery(sc);</span><br><span class="line">mpg.execute();</span><br></pre></td></tr></table></figure><p>注意：以上为旧版本，mybatis-plus-generator 3.5.1 及其以上版本对历史版本不兼容！3.5.1 以上的请参考 <a href="https://baomidou.com/pages/779a6e/#%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8">代码生成器新</a>和<a href="https://baomidou.com/pages/981406/#%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE">相关配置</a>。</p><p>目前支持两套生成的方式,一套使用SQL查询的方式是兼容旧的代码生成器核心逻辑使用,另一套使用驱动规范来读取元数据的方式,默认的使用元数据查询方式来生成代码,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">FastAutoGenerator.create(<span class="string">&quot;url&quot;</span>, <span class="string">&quot;username&quot;</span>, <span class="string">&quot;password&quot;</span>)</span><br><span class="line">    .globalConfig(builder -&gt; &#123;</span><br><span class="line">        builder.author(<span class="string">&quot;xxx&quot;</span>) <span class="comment">// 设置作者</span></span><br><span class="line">            .enableSwagger() <span class="comment">// 开启 swagger 模式</span></span><br><span class="line">            .fileOverride() <span class="comment">// 覆盖已生成文件</span></span><br><span class="line">            .outputDir(<span class="string">&quot;D://&quot;</span>); <span class="comment">// 指定输出目录</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .dataSourceConfig(builder -&gt; builder.typeConvertHandler((globalConfig, typeRegistry, metaInfo) -&gt; &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">typeCode</span> <span class="operator">=</span> metaInfo.getJdbcType().TYPE_CODE;</span><br><span class="line">        <span class="keyword">if</span> (typeCode == Types.SMALLINT) &#123;</span><br><span class="line">            <span class="comment">// 自定义类型转换</span></span><br><span class="line">            <span class="keyword">return</span> DbColumnType.INTEGER;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> typeRegistry.getColumnType(metaInfo);</span><br><span class="line"></span><br><span class="line">    &#125;))</span><br><span class="line">    .packageConfig(builder -&gt; &#123;</span><br><span class="line">        builder.parent(<span class="string">&quot;com.baomidou.mybatisplus.samples.generator&quot;</span>) <span class="comment">// 设置父包名</span></span><br><span class="line">            .moduleName(<span class="string">&quot;system&quot;</span>) <span class="comment">// 设置父包模块名</span></span><br><span class="line">            .pathInfo(Collections.singletonMap(OutputFile.xml, <span class="string">&quot;D://&quot;</span>)); <span class="comment">// 设置mapperXml生成路径</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .strategyConfig(builder -&gt; &#123;</span><br><span class="line">        builder.addInclude(<span class="string">&quot;t_xxx&quot;</span>) <span class="comment">// 设置需要生成的表名</span></span><br><span class="line">            .addTablePrefix(<span class="string">&quot;t_&quot;</span>, <span class="string">&quot;c_&quot;</span>); <span class="comment">// 设置过滤表前缀</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .templateEngine(<span class="keyword">new</span> <span class="title class_">FreemarkerTemplateEngine</span>()) <span class="comment">// 使用Freemarker引擎模板，默认的是Velocity引擎模板</span></span><br><span class="line">    .execute();</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Mybatis是一种关系型数据库的ORM持久化框架，封装了JDBC和sqlmap，使java代码和DAO分离，提高了开发效率。</summary>
    
    
    
    <category term="java" scheme="https://aachou.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL入门</title>
    <link href="https://aachou.github.io/2023/1215/"/>
    <id>https://aachou.github.io/2023/1215/</id>
    <published>2023-12-15T08:15:23.000Z</published>
    <updated>2023-12-15T08:12:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍了什么是sql和nosql以及两者区别；介绍了mysql的特点、函数和SQL语句操作数据库；讲解了mysql事务及ACID原则和事务的4种隔离级别，索引的作用和原理；mysql的权限管理和数据备份恢复；数据库的设计和三大范式；SQL注入问题和避免；JDBC以及DBCP连接池连接数据库。<span id="more"></span></p><h4 id="sql与nosql"><a href="#sql与nosql" class="headerlink" title="sql与nosql"></a>sql与nosql</h4><p>关系型数据库SQL是使用关系模式组织数据的结构化数据库系统。</p><p>非关系型数据库（NoSQL）是一类用于存储和管理非结构化数据的数据库系统。</p><p>关系数据库和非关系数据库区别体现在三个方面：数据存储方式不同；扩展方式不同；对事务性的支持不同。具体可参考：<a href="https://zhuanlan.zhihu.com/p/604736447">区别</a></p><p>关系型数据库的实现：Mysql，SQLserver，Oracle等。</p><p>非关系数据库实现：Redis（键值对），Mongodb（文档型），hbase（列存储），neo4j（Graph图像）。</p><h4 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h4><p>SQL语言的特点：高度非过程化、面向集合操作、可移植性强、简洁灵活、支持三级模式结构、<a href="https://blog.csdn.net/qq_40036754/article/details/110098896">ACID</a>（原子性，一致性，隔离性，持久性）。</p><p>SQL语言支持三级模式结构，通过外模式对应视图、基本表对应存储文件，以及内模式对应存储文件的方式实现。</p><p>Mysql默认不支持中文，在my.ini中配置编码<code>character-set-server=utf8</code>或，编写sql代码时加上<code>DEFAULT CHARSET=UTF8</code>。Mysql默认localhost本地连接，root为最高权限用户，默认数据库引擎为Innodb（支持事务，行级锁，外键，但是占用空间大）。</p><p><strong>注释</strong>：–，&#x2F;**&#x2F;</p><p>数据库数值类型：tinyint(1byte)、smallint(2byte)、int(4byte)、float(4byte)、double(8byte)、decimal、varchar(0-65535)、text文本串、null</p><p>date：YYYY-MM-DD</p><p>time:  HH:mm:ss</p><p>datetime：YYYY-MMM-DD HH:mm:ss</p><p>timestamp：时间戳，1970到现在的毫秒数</p><p>文档：<a href="https://dev.mysql.com/doc/refman/8.2/en/non-typed-operators.html">reference</a></p><h5 id="DDL定义"><a href="#DDL定义" class="headerlink" title="DDL定义"></a>DDL定义</h5><p>数据定义语言（DDL）：create，drop，alter</p><p>创建数据库：<code>create database 数据库名</code></p><p>切换数据库：USE DATABASE</p><p>修改表：<code>alter table &#39;表名&#39; rename as xxx</code></p><p>增加字段：<code>alter table &#39;表名&#39; add Phone INT(11)</code></p><p>修改字段：<code>alter table &#39;表名&#39; modify Phone VARCHAR(11)</code>；</p><p>修改字段名：<code>alter table &#39;表名&#39; change Phone Phone1 INT(11)</code></p><p>删除字段：<code>alter table &#39;表名&#39; drop Phone INT(11)</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--创建表---</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> `categoryin`</span><br><span class="line">(</span><br><span class="line">categoryin_id <span class="type">INT</span>(<span class="number">20</span>) <span class="keyword">NOT NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;收入分类id&#x27;</span>,</span><br><span class="line">categoryin_name <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">CHARACTER SET</span> utf8 COMMENT <span class="string">&#x27;收入分类名&#x27;</span>,</span><br><span class="line"><span class="keyword">PRIMARY KEY</span> (categoryin_id)</span><br><span class="line">)</span><br><span class="line">ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">3</span> <span class="keyword">CHARACTER SET</span> <span class="operator">=</span> utf8 COMMENT<span class="operator">=</span><span class="string">&#x27;收入分类&#x27;</span>;</span><br></pre></td></tr></table></figure><h5 id="DML操作管理"><a href="#DML操作管理" class="headerlink" title="DML操作管理"></a>DML操作管理</h5><p>数据操作语言（DML）：insert , delete , update，truncate</p><p><code>insert into 表名 (字段1,字段2) values(值1，值2);</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> `categoryin` <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="string">&#x27;工资&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> `categoryin` <span class="keyword">VALUES</span> (<span class="number">2</span>,<span class="string">&#x27;彩票&#x27;</span>);</span><br></pre></td></tr></table></figure><p><code>update 表名 set &#39;字段1&#39;=&#39;值1&#39;,&#39;字段2&#39;=&#39;值2&#39; where id=xxx; </code></p><p>where条件运算符：&#x3D;，!&#x3D;(&lt;&gt;)， &gt;，&lt;，between  and，and，or。</p><p><code>delete from 表名 where [条件]</code></p><p>清空表（自增变量归0）：<code>truncate table &#39;表名&#39;</code></p><h5 id="DQL查询"><a href="#DQL查询" class="headerlink" title="DQL查询"></a>DQL查询</h5><p>数据查询语言（DQL）：select</p><p><code>select 字段1,字段2 from 表名 as 别名</code></p><p>字段去重，<code>select distinct &#39;字段&#39; from 表名</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--查询系统版本</span></span><br><span class="line"><span class="keyword">select</span> version();</span><br><span class="line"><span class="comment">--计算</span></span><br><span class="line"><span class="keyword">select</span> <span class="number">2</span><span class="operator">*</span><span class="number">3</span>;</span><br><span class="line"><span class="comment">--查询变量</span></span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@auto_increment_increment</span></span><br><span class="line"><span class="comment">--函数</span></span><br><span class="line"><span class="keyword">select</span> 函数</span><br></pre></td></tr></table></figure><p>模糊查询：</p><p><code>select 字段 from 表名 where xxx like &#39;a__&#39;</code></p><p><code>select 字段 from 表名 where xxx like &#39;%a%&#39;</code></p><p><code>select 字段 from 表名 where xxx in (xxx,xxx,xxx)</code></p><p><code>select 字段 from 表名 where xxx is &#39;xxx&#39;</code></p><p>多表查询：</p><p>联接查询：<code>join 表名 as 别名 on [条件]</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>  mi.in_id, mi.single_in, mi.zhanghu_id,            mi.categoryin_id, mi.date, mi.beizhu,</span><br><span class="line">        z.zhanghu_name,z.zhanghu_money,</span><br><span class="line">        z.create_time,</span><br><span class="line">        cin.categoryin_name</span><br><span class="line">        <span class="keyword">from</span> moneyin <span class="keyword">as</span> mi</span><br><span class="line">        <span class="keyword">join</span> zhanghu <span class="keyword">as</span> z</span><br><span class="line">        <span class="keyword">on</span> mi.zhanghu_id<span class="operator">=</span>z.zhanghu_id</span><br><span class="line">        <span class="keyword">join</span> categoryin cin</span><br><span class="line">        <span class="keyword">on</span> mi.categoryin_id<span class="operator">=</span>cin.categoryin_id</span><br></pre></td></tr></table></figure><p>inner join：只返回两个表中联结字段相等的行。</p><p>left join：返回左表所有值，即使没有匹配(使用null填充)。</p><p>right join：返回右表所有值，即使没有匹配(使用null填充)。</p><p>注意顺序：</p><p>where指定结果满足条件；</p><p>group by按照哪个字段分组 ；</p><p>having过滤分组满足的次要条件；</p><p>order by排序；</p><p>limit分页。</p><p><strong>分页limit和排序order by:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--ASC升序--DESC降序</span></span><br><span class="line"><span class="keyword">where</span> ....</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> xxx <span class="keyword">desc</span></span><br><span class="line">limit <span class="number">0</span>,<span class="number">10</span></span><br><span class="line"><span class="comment">--limit 起始下标,pageSize页大小</span></span><br></pre></td></tr></table></figure><p>子查询：</p><p>在where ..(select …)中嵌套一个查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sName</span><br><span class="line"><span class="keyword">from</span> Student</span><br><span class="line"><span class="keyword">where</span> sId <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">distinct</span> sId <span class="keyword">from</span> score <span class="keyword">where</span> tId<span class="operator">=</span>(<span class="keyword">select</span> tId <span class="keyword">from</span> teacher <span class="keyword">where</span> tName<span class="operator">=</span><span class="string">&#x27;Alice&#x27;</span>))</span><br></pre></td></tr></table></figure><h5 id="DCL控制"><a href="#DCL控制" class="headerlink" title="DCL控制"></a>DCL控制</h5><p>数据控制语言（DCL）：grant，revoke 。</p><h5 id="五个约束"><a href="#五个约束" class="headerlink" title="五个约束"></a>五个约束</h5><p>主键约束（唯一约束）（Primay Key Counstraint）：唯一性，非空性。</p><p>唯一约束（Unique Counstraint）：唯一性，可以空，但只能有一个。</p><p>检查约束 (Check Counstraint)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter table</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">add constraint</span> CK_Sex <span class="keyword">check</span> (sex<span class="operator">=</span><span class="string">&#x27;男&#x27;</span> <span class="keyword">or</span> sex<span class="operator">=</span><span class="string">&#x27;女&#x27;</span>)</span><br></pre></td></tr></table></figure><p>默认约束 (Default Counstraint)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter table</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">add constraint</span> df_age <span class="keyword">default</span> (<span class="string">&#x27;0&#x27;</span>) <span class="keyword">for</span> age</span><br></pre></td></tr></table></figure><p>外键约束 (Foreign Key Counstraint)</p><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>usage:  <code>select [函数];</code></p><p>常用函数：</p><p>abs绝对值，floor向下取整，celling向上取整，rand产生0-1随机数，char_length字符串长度，concat拼接，sign符号函数，current_date当前日期，now当前时间，localtime本地时间，sysdate系统时间，md加密。</p><p>first：返回指定的字段中第一个记录的值；</p><p>last：返回指定的字段中最后一个记录的值；</p><p>len：返回文本字段中值的长度；</p><p>聚合函数(计算最大、最小、平均值)：</p><p>count计数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(字段或p<span class="operator">-</span>k) <span class="keyword">from</span> stduent;<span class="comment">--忽略null</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> student;<span class="comment">--不会忽略null</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">from</span> student;<span class="comment">--不忽略null，本质：计算行数</span></span><br></pre></td></tr></table></figure><p>sum求和；avg求平均；max；min</p><p>select sum(‘字段’) as 总和 from 表;<br>select avg(‘字段’) as 平均 from 表;<br>select max(‘字段’) as 最大 from 表;<br>select min(‘字段’) as 最小 from 表;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--查询不同课程的平均分&gt;80，最高分，最低分</span></span><br><span class="line"><span class="keyword">select</span> subjectName,<span class="built_in">avg</span>(studentResult) <span class="keyword">as</span> 平均分,<span class="built_in">max</span>(studentResult) <span class="keyword">as</span> 最高分,<span class="built_in">min</span>(studentResult) <span class="keyword">as</span> 最低分 </span><br><span class="line"><span class="keyword">from</span> <span class="keyword">result</span> r</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> <span class="string">&#x27;subject&#x27;</span> sub </span><br><span class="line"><span class="keyword">on</span> r.<span class="string">&#x27;subjectNo&#x27;</span><span class="operator">=</span>sub.<span class="string">&#x27;subjectNo&#x27;</span></span><br><span class="line"><span class="comment">--根据不同课程分组</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> r.<span class="string">&#x27;subjectNo&#x27;</span></span><br><span class="line"><span class="keyword">having</span> 平均分<span class="operator">&gt;</span><span class="number">80</span></span><br></pre></td></tr></table></figure><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p>数据库事务(Transaction)：指由一个或多个数据库操作组成的逻辑单位。</p><p>mysql默认开启事务自动提交！</p><p><code>set autocommit=0;</code>设置手动提交事务。</p><p><code>start transaction</code>开启事务。</p><p><code>commit</code>事务提交，事务一旦提交，数据将持久化，回滚也无法恢复。</p><p><code>rollback</code>事务回滚。</p><p><strong>事务原则ACID</strong></p><p><a href="https://blog.csdn.net/qq_40036754/article/details/110098896">ACID</a>（原子性，一致性，隔离性，持久性）。</p><p>原子性atomic：事务要么所有的操作都执行成功,要么所有的操作都不执行,保证数据库的一致性和完整性。</p><p>一致性consistency：事务完成后符合逻辑运算，数据前后状态要一致。</p><p>持久性durability：事务没有提交则数据恢复原状，事务提交则数据不可逆，不会因宕机外部因素丢失数据。</p><p>隔离性isolation：排除其他事务对本次事务的影响。</p><p><strong>事务隔离级别</strong></p><p>脏读：一个事务读取另一个事务未提交的数据。</p><p>不可重复读：一次事务内多次读取某行的数据不同。</p><p>虚读(幻读)：一次事务中读取了其他事务插入的数据。</p><p> 4 种隔离级别：读未提交 (READ UNCOMMITTED)、读已提交 (READ COMMITTED)、可重复读 (REPEATABLE READ)、串行化 (SERIALIZABLE)。</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交</td><td>可能</td><td>可能</td><td>可能</td></tr><tr><td>读提交</td><td>不可能</td><td>可能</td><td>可能</td></tr><tr><td>可重复读</td><td>不可能</td><td>不可能</td><td>可能</td></tr><tr><td>串行化</td><td>不可能</td><td>不可能</td><td>不可能</td></tr></tbody></table><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p>索引定义：：Index是帮助MySQL高效获取数据的数据结构。<br>索引作用：通过索引可以大大的提高数据库的检索速度，提高数据库的性能。</p><h5 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h5><p>唯一索引unique：唯一，可重复(多个列都可以标识为unique)</p><p>主键索引primary：唯一，不可重复(一张表只能有一个)。定义表主键的时候，会自动创建主键索引。</p><p>常规索引key：默认</p><p>全文索引FullText：快速定位数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--1、创建表时添加索引</span></span><br><span class="line"><span class="comment">--2、alter </span></span><br><span class="line"><span class="keyword">alter table</span> 表名 <span class="keyword">add</span> Index_TYPE index <span class="string">&#x27;索引名&#x27;</span>(<span class="string">&#x27;字段&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--3、create</span></span><br><span class="line"><span class="comment">-- 索引名：id_表名_字段名</span></span><br><span class="line"><span class="keyword">create</span> index 索引名 <span class="keyword">on</span> 表(<span class="string">&#x27;字段&#x27;</span>);</span><br></pre></td></tr></table></figure><p>聚集索引clustered index：表中各行的物理顺序与键值的逻辑顺序相同，每个表只能有一个。在聚集索引中，表中各行的物理顺序与键值的逻辑（索引）顺序相同。表只能包含一个聚集索引。</p><p>非聚集索引：非聚集索引指定表的逻辑顺序，数据存储在一个位置，索引存储在另一个位置，索引中包含指向数据存储位置的指针。</p><p>一个表只能创建1个聚集索引，多个非聚集索引。设置某列为主键，该列就默认为聚集索引。</p><p>索引数据结构：InnoDB使用聚集索引，数据记录本身被存于一棵B+树的叶子节点上，同一个叶子节点内的各条数据记录按主键顺序存放。每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子，则开辟一个新的页（节点）。</p><h4 id="权限与DCL"><a href="#权限与DCL" class="headerlink" title="权限与DCL"></a>权限与DCL</h4><p>数据库mysql中user表记录了root、mysql.sys、mysql.session等用户的操作权限、访问主机host（默认localhost，只能本地连接）和各自密码(加密)。其中，root用户为最高权限用户，只有root有grant授权权限。</p><p>创建用户：<code>create user xxx identified by &#39;PASSWORD&#39;;</code></p><p>删除用户：<code>drop user xxx;</code></p><p>修改密码：<code>update user set password=&#39;123456&#39; where user=&#39;root&#39;;</code></p><p><code>set password for root = password(&#39;123456&#39;);</code></p><p>修改当前用户密码：<code>set password = password(&#39;123456&#39;);</code></p><p>重命名用户：<code>rename user xxx to xx;</code></p><p><u>数据控制语言（DCL）：grant，revoke 。</u></p><p>授权：<code>grant 某权限[all privileges] on 库.表 to 用户; </code></p><p>查看权限：<code>show grants for xxx</code></p><p>特殊的<code>show grants for root@localhost</code></p><p>撤销权限：<code>revoke 权限[privileges] on 库.表(*.*) from 用户;</code></p><p>当出现1130-host “xxx” is not allowed to connetced to this Mysql错误提示，表示访问拒绝非本地连接，需要修改host为%，可执行以下步骤。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--1. use mysql;</span></span><br><span class="line"><span class="comment">--2. update user set host=&#x27;%&#x27; where user=&#x27;root&#x27;;</span></span><br><span class="line"><span class="comment">--3. flush privileges;</span></span><br><span class="line"><span class="comment">/*在不重启mysql下使修改生效*/</span></span><br></pre></td></tr></table></figure><h4 id="备份恢复"><a href="#备份恢复" class="headerlink" title="备份恢复"></a>备份恢复</h4><p><strong>备份</strong></p><p>方式一、物理拷贝</p><p>直接将mysql中的data目录下的文件数据拷贝出去。</p><p>方式二、mysqldump命令</p><p><code>mysqldump -h 主机 -u 用户 -p 密码 数据库 表名&gt; 导出位置/xx.sql </code></p><p><code>mysqldump -h 主机 -u 用户 -p 密码 数据库&gt; 导出位置/xx.sql </code></p><p>例：<code>mysqldump -u root -p 123456 mydb &gt; /home/db.bak</code></p><p>方式三、sqlyog可视化导出转储</p><p><strong>恢复</strong></p><p>登录数据库，使用source命令导入备份的sql或bak数据。</p><p><code>source 备份文件</code></p><p>或未登录下</p><p><code>mysqldump -h 主机 -u 用户 -p 密码 数据库&lt; xx.sql </code></p><h4 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h4><p>良好的设计将节省内存，提高查询速度，便于系统开发。</p><p>注意点：表名命名清晰、表结构合理、表关系(实体关系)设计、字段命名规范(不要大小写，统一小写加下划线)、字段类型及长度、主键设计、数据库引擎使用(通常为innodb)、字符集规范utf8。</p><h4 id="三大范式"><a href="#三大范式" class="headerlink" title="三大范式"></a>三大范式</h4><p>数据库三大范式包含：</p><p><strong>第一范式(1NF)</strong>：属性不可分割，每一列都是不可分的原子数据项。</p><p><strong>第二范式(2NF)</strong>：满足第一范式，且不存在部分依赖，每一列必须和主键相关。非码属性必须完全依赖于候选码。</p><p><strong>第三范式(3NF)</strong>：满足第二范式，且不存在传递依赖，每一列必须和主键直接相关，不存在间接相关。任何非主属性不依赖于其它非主属性，即在2NF基础上消除传递依赖。</p><p>设计注意事项：关联性查询最好不要超过三张表，设计时应该考虑性能与规范的问题。</p><h4 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h4><p>Java DataBase Connectivity（Java数据库连接），是 JavaEE 平台下的技术规范， 定义了在 Java 语言中连接数据库，执行数据库操作的标准 ，可以为多种关系数据库提供统一访问，其本质是sun公司制定的一套接口。</p><p>因为每一个数据库的底层实现原理都不一样，每一个数据库产品都有自己独特的实现原理！所以为了方便java的开发，制定一个统一的连接数据库的规范势在必行，这就是JDBC。只要数据库厂商面向JDBC编写驱动，就能让开发者使用JDBC方便地操作各种数据库。</p><p>其中，java.sql.*；javax.sql.*里定义了与数据库操作有关的接口和方法。mysql-connector-java-8.0.11.jar包是标准JDBC的驱动程序，用于连接数据库。JdbcUtils工具类封装加载驱动，获取连接，释放资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载驱动，执行静态代码块</span></span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"><span class="comment">//url，数据库信息</span></span><br><span class="line">String url=<span class="string">&quot;jdbc:mysql://localhost:3360/数据库?useSSL=true&amp;</span></span><br><span class="line"><span class="string">   characterEncoding=utf-8 &amp; serverTimezone=Asia/Shanghai&quot;</span>;</span><br><span class="line">String user=<span class="string">&quot;root&quot;</span>;</span><br><span class="line">String password=<span class="string">&quot;123456&quot;</span>;</span><br><span class="line"><span class="comment">//数据库连接对象</span></span><br><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span></span><br><span class="line">DriverManager.getConnection(url,user,password);</span><br><span class="line"><span class="comment">//定义statement对象</span></span><br><span class="line">Statement statement=connection.createStatement();</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user&quot;</span>;</span><br><span class="line"><span class="comment">//定义结果集</span></span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> statement.executeQuery(sql);</span><br><span class="line"><span class="keyword">while</span>(resultSet.next())&#123;</span><br><span class="line"> System.ou.println(<span class="string">&quot;id=&quot;</span>+resultSet.getObject(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//释放连接</span></span><br><span class="line">resultSet.close();</span><br><span class="line">statement.close();</span><br><span class="line">connection.close();</span><br><span class="line"><span class="comment">//jdbcUtils.release(connetcion,statement,resultSet);</span></span><br></pre></td></tr></table></figure><p>oracle数据库连接：<code>jdbc:oracle:thin:@//&lt;host&gt;:&lt;port&gt;/&lt;SERVICE_NAME&gt; </code></p><p>sid连接：<code>jdbc:oracle:thin:@localhost:1521:sid</code></p><p><a href="https://blog.csdn.net/qq_42588990/article/details/111803099">JDBC参考资料</a></p><h4 id="SQL注入问题"><a href="#SQL注入问题" class="headerlink" title="SQL注入问题"></a>SQL注入问题</h4><p>指攻击者在查询信息的结尾上添加额外的SQL语句以实现非法操作，执行非授权的任意查询，实质是web应用对用户输入的数据合法性判断不严。</p><p>Statement 采取直接编译 SQL 语句的方式，扔给数据库去执行，而 PreparedStatement 则先将 SQL 语句预编译一遍，再填充参数，这样效率会高一些。</p><p>Statement对象可能进行字符串与变量的拼接，很容易进行 SQL 注入攻击。采用PreparedStatement访问数据库不仅能防止sql注入，还是预编译的，不用重新编译整个sql语句，效率高。此外执行查询语句得到的结果集是离线的，连接关闭后，仍然可以访问结果集。</p><p>注意：PreparedStatement防止sql注入实质是将传入的参数看作字符串处理。${}是拼接，#{}整体当做字符串处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除表中id=1且name=admin的记录</span></span><br><span class="line"></span><br><span class="line">Class.forName(com.mysql.jdbc.Driver);     </span><br><span class="line"><span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> DriverManager.getConnection(</span><br><span class="line">    <span class="string">&quot;jdbc:mysql://localhost:3306/xxx...&quot;</span>); </span><br><span class="line"><span class="comment">//以？作为占位符，值待设置</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;delete from user where id=? and name=?&quot;</span>;</span><br><span class="line"><span class="comment">//创建PreparedStatement时就传入sql语句，实现了预编译 </span></span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">p</span> <span class="operator">=</span> con.prepareStatement(sql);    </span><br><span class="line"><span class="comment">//传入参数</span></span><br><span class="line">p.setString(<span class="number">1</span>,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">p.setString(<span class="number">2</span>,<span class="string">&quot;admin&quot;</span>);</span><br><span class="line"><span class="comment">//设置sql语句的占位符的值，注意第一个参数位置是1不是0</span></span><br><span class="line">p.execute(); <span class="comment">//执行</span></span><br></pre></td></tr></table></figure><p>同时，mybatis-plus框架也会进行sql的预编译。Mybatis（plus）使用参数化查询，<code>#&#123;xxx&#125;</code> 是参数化查询的占位符，它将传入的参数插入到占位符中，而不会将其解释为 SQL 代码。在自定义查询语句时，为确保参数化查询，须使用 <code>@Param</code> 注解将参数传递给 sql查询。这些措施让Mybatis-plus能防止sql注入。</p><p><a href="https://blog.csdn.net/QGhurt/article/details/107012843">文章：PreparedStatement防止SQL注入原因</a></p><p>​<a href="https://blog.csdn.net/yanghezheng/article/details/133156660">MybatisPlus如何解决SQL注入</a></p><p>​<a href="https://zhuanlan.zhihu.com/p/652655607">Mybatis-plus sql注入及防止sql注入详解</a></p><h4 id="DBCP数据库连接池"><a href="#DBCP数据库连接池" class="headerlink" title="DBCP数据库连接池"></a>DBCP数据库连接池</h4><p>DBCP连接池提高资源利用率，避免重复创建和销毁连接资源，减少系统开销。使用DBCP连接池后，免去了编写连接数据库的代码。使用DBCP需要导入dbcp相关jar包，导入依赖到项目中。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">commons-dbcp-1.4.jar</span><br><span class="line">commons-pool-1.5.4jar</span><br></pre></td></tr></table></figure><p>创建多个dbcp.properties文件，存储多个不同的连接池</p><p>连接池的工作原理：<br>①使用连接池前：用jdbc连接数据库时，先getConnection获取连接，用完后要release释放连接，再次连接重复前两步，对程序性能影响很大。<br>②使用连接池后：在程序开始之前，先创建几个连接，将连接放入到连接池中，连接池中缓存了一定量的Connection对象，当用户需要使用连接时，从连接池中获取，使用完毕之后将连接还回连接池。</p><p>连接池的种类：DBCP，C3P0，Druid，Tmcat内置连接池等。</p><p>dhcp配置:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#导入dbcp的配置文件dbcp.properties</span></span><br><span class="line"><span class="attr">driverclassName</span>=<span class="string">com.mysql.jbcp.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/xxx?useUnicode=true</span></span><br><span class="line"><span class="attr">&amp;characterEncoding</span>=<span class="string">utf-8</span></span><br><span class="line"><span class="attr">user</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">123456</span></span><br><span class="line"><span class="attr">initialSize</span>=<span class="string">10 #初始连接数量</span></span><br><span class="line"><span class="attr">maxActive</span>=<span class="string">50 #最大活跃连接数量</span></span><br><span class="line"><span class="attr">maxIdle</span>=<span class="string">20 #最大空间连接数</span></span><br><span class="line"><span class="attr">minIdle</span>=<span class="string">5 #最小空间连接数</span></span><br><span class="line"><span class="attr">maxWait</span>=<span class="string">60000 </span></span><br><span class="line"><span class="comment">#最大等待时间ms（毫秒），从连接池获取连接，如果连接池空了，等待的最大时间</span></span><br><span class="line"><span class="attr">connectionProperties</span>=<span class="string">useUnicode=true;characterEncoding=utf-8</span></span><br><span class="line"><span class="attr">defaultAutoCommit</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">defaultTransactionIsolation</span>=<span class="string">READ_COMMITTED</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> xxx.class.getClassLoader().</span><br><span class="line">    getResourceAsStream(<span class="string">&quot;dbcp.properties&quot;</span>);</span><br><span class="line"><span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">pro.load(in);</span><br><span class="line"><span class="comment">//声明连接池</span></span><br><span class="line"><span class="keyword">static</span> DataSource datasource=<span class="literal">null</span>;</span><br><span class="line"><span class="comment">//创建连接池</span></span><br><span class="line">datasource=BasicDataSourceFactory.createDataSource(pro);</span><br><span class="line"><span class="comment">//从连接池获取连接</span></span><br><span class="line">conn=datasource.getConnection()；</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/weixin_43908649/article/details/110239301">DBCP参考资料</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文介绍了什么是sql和nosql以及两者区别；介绍了mysql的特点、函数和SQL语句操作数据库；讲解了mysql事务及ACID原则和事务的4种隔离级别，索引的作用和原理；mysql的权限管理和数据备份恢复；数据库的设计和三大范式；SQL注入问题和避免；JDBC以及DBCP连接池连接数据库。</summary>
    
    
    
    <category term="mysql" scheme="https://aachou.github.io/categories/mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>linux正则表达式与三剑客</title>
    <link href="https://aachou.github.io/2023/1211/"/>
    <id>https://aachou.github.io/2023/1211/</id>
    <published>2023-12-11T09:45:23.000Z</published>
    <updated>2023-12-25T07:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍了如何使用linux正则表达式结合命令处理文本和awk,grep,sed三种文本工作命令。<span id="more"></span></p><p>正则表达式（regular expression）</p><p>使用一些特殊字符+字母和或数字按照某个规则组合成一 个公式用来表示某个意思这就叫正则表达式。正则表达式是一种方法，很多命令可以采用这种方法：vim ，grep，sed，awk等都支持正则表达式，grep通常打印结果行。</p><h4 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h4><p>元字符：有特殊含义的字符，可以表示其他的含义</p><h5 id="“-“-开头"><a href="#“-“-开头" class="headerlink" title="“ ^ “ 开头"></a>“ ^ “ 开头</h5><p>匹配后面的某开头字符。</p><p><code>cat a.txt | grep &quot;^a&quot;</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a bc</span><br><span class="line">abc</span><br></pre></td></tr></table></figure><h5 id="“-“-结尾"><a href="#“-“-结尾" class="headerlink" title="“ $ “ 结尾"></a>“ $ “ 结尾</h5><p>匹配前面的某结尾字符。</p><p><code>cat a.txt | grep &quot;b$&quot;</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aa aab</span><br><span class="line">bbb</span><br></pre></td></tr></table></figure><h5 id="“-“单个"><a href="#“-“单个" class="headerlink" title="“ . “单个"></a>“ . “单个</h5><p>匹配任意单个字符，长度不为0。</p><p>“a.{2}” 表示匹配以a开头的后面任意两个单个字符，至少两个，包括空格。</p><p><code>cat a.txt| egrep &quot;a.&#123;2&#125;&quot;</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a b</span><br><span class="line">aaaa  abc</span><br><span class="line">bbb afc</span><br></pre></td></tr></table></figure><p>“a.{4,6}” 表示匹配以a开头的后面任意4 - 6个单个字符，包括空格。</p><p><code>cat a.txt| egrep &quot;a.&#123;4,6&#125;&quot;</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bbb aaaaa</span><br><span class="line">abd efddd</span><br><span class="line">kkk baccccd</span><br></pre></td></tr></table></figure><h5 id="“-“-任意"><a href="#“-“-任意" class="headerlink" title="“ * “ 任意"></a>“ * “ 任意</h5><p>匹配前面的字符出现0次或者任意，贪婪模式, 匹配*号前面的字符任意次，<code>.</code> *表示任意长度任意字符，包括空格。</p><p> <code>cat a.txt| egrep &quot;aa.*&quot;</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aad da</span><br><span class="line">ABC baa</span><br></pre></td></tr></table></figure><h5 id="“-“-至少一次"><a href="#“-“-至少一次" class="headerlink" title="“ + “ 至少一次"></a>“ + “ 至少一次</h5><p>表示前面字符出现1次以上.</p><p> <code>cat a.txt | egrep &quot;[abc]+&quot;</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">abcde</span><br><span class="line">ade</span><br><span class="line">bbb</span><br></pre></td></tr></table></figure><p>相当于 <code>cat a.txt| egrep &quot;[abc]&quot;</code></p><p> <code>cat a.txt | egrep &quot;abc+&quot;</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">abc</span><br><span class="line">abccc d</span><br><span class="line">dd abc</span><br></pre></td></tr></table></figure><h5 id="“-“-可有可无"><a href="#“-“-可有可无" class="headerlink" title="“ ? “ 可有可无"></a>“ ? “ 可有可无</h5><p>匹配其前面的字符0或1次,即前面的字符可有可无。</p><p><code>cat a.txt| egrep &quot;ab?&quot;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ab</span><br><span class="line">a</span><br><span class="line">dd aad</span><br></pre></td></tr></table></figure><h5 id="“-”次数区间"><a href="#“-”次数区间" class="headerlink" title="“{ }”次数区间"></a>“{ }”次数区间</h5><p>注意，在使用grep基本正则表达式要带<code>\</code>转义字符，即<code>\&#123;4,6\&#125;</code>，这里以拓展正则表达式为例，就不用带转义字符。</p><p>{m}    ，匹配前面的字符m次。<br>{m,n} ，匹配前面字符至少m次，最多n次。</p><p><code>cat a.txt| egrep &quot;abcd&#123;2,3&#125;&quot;</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ef abcdd</span><br><span class="line">abcdddef</span><br></pre></td></tr></table></figure><h5 id="“-“或者"><a href="#“-“或者" class="headerlink" title="“ | “或者"></a>“ | “或者</h5><p> <code>cat a.txt| egrep &quot;a|bc&quot;</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bc as</span><br><span class="line"><span class="built_in">dd</span> bcd</span><br></pre></td></tr></table></figure><h5 id="patten-模式匹配"><a href="#patten-模式匹配" class="headerlink" title="^patten$  模式匹配"></a>^patten$  模式匹配</h5><p> <code>^a$</code>表示只匹配以a这个字符开头和结尾的行。</p><p><code>cat a.txt | egrep &quot;^a$&quot;</code></p><h4 id="“-“-转义"><a href="#“-“-转义" class="headerlink" title="“\“ 转义"></a>“\“ 转义</h4><p>“\“表示是转义字符，就是把元字符转义为普通字符，比如<code>\\</code>表示普通符号”\“，把普通字符转换为特殊意义符号，比如”\n”表示把普通字符n转义为换行符。</p><p>\&lt;或\b    　　　，单词左侧，表示以该单词为词首<br>\&gt;或\b    　　    ，单词右侧，表示以该单词为词尾<br>\&lt;PATTERN\&gt;   ，匹配整个单词</p><h4 id="“-”方括号表达式"><a href="#“-”方括号表达式" class="headerlink" title="“[ ]”方括号表达式"></a>“[ ]”方括号表达式</h4><p>[abc] 表示 a，b，c任意一个，实际上，[abc] &#x3D; “a|b|c”&#x3D;(a|b|c)。</p><p>示例：</p><p>[a-z] 表示小写字母</p><p>[A-Z] 表示大写字母</p><p>[0-Z] 表示数字和字母</p><p><code>egrep (ab|ba) a.txt</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">abd efg</span><br><span class="line">acd baef</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">([0-9])|([0][0-9])|([1][0-9])</span><br><span class="line">#表示匹配0-9或者00-09或者10-19范围的字符。</span><br></pre></td></tr></table></figure><h5 id="在方括号里面和外面的区别"><a href="#在方括号里面和外面的区别" class="headerlink" title="^在方括号里面和外面的区别"></a>^在方括号里面和外面的区别</h5><p>方括号里面：表示对字符取反，排除某些字符。</p><p>方括号外面：表示以某字符开头。</p><p><u>示例：查找不是以数字开头的行</u></p><p>行开头可能是字母或特殊字符。</p><p><code>cat a.txt| egrep &quot;^[^0-9]&quot;</code></p><p><strong>[]和 {}组合使用</strong></p><p>[0-9]{2} 表示0-9里面可以取2次的意思。</p><p>[0-9]{2,5} 表示从0-9里可以取2-5次的数字，至少2个数字，最多5个。</p><p>[0-9]{2,} 表示从0-9里可以取两次以上，最少2次</p><p>a{2} 表示花括号前面的a连续出现两次。</p><p>abc{2}表示abc中的c出现2次。</p><p><strong>案例：从文本里面过滤出所有邮箱地址</strong></p><p>root@localhost lianxi]# cat mail.txt<br>a  <a href="mailto:&#97;&#49;&#64;&#x71;&#x71;&#x2e;&#x63;&#111;&#x6d;">a1@qq.com</a>  aa<br>b <a href="mailto:&#x32;&#98;&#64;&#115;&#105;&#110;&#97;&#x2e;&#99;&#x6f;&#x6d;">2b@sina.com</a> bb<br>c  <a href="mailto:&#99;&#x33;&#x40;&#49;&#54;&#51;&#46;&#x63;&#111;&#x6d;">c3@163.com</a> cc<br>d <a href="mailto:&#52;&#x64;&#x40;&#x31;&#54;&#x33;&#46;&#99;&#111;&#109;">4d@163.com</a> dd</p><p>写一个表示邮箱的正则，过滤邮箱。邮箱地址：字符串1@字符串2.字符串3</p><p>字符串1：a-Z_0-9</p><p>字符串2：0-Z</p><p>字符串3：a-Z</p><p><code>cat mail.txt | grep -o &quot;[0-Z$_]+@[0-z]+.[0-z]+&quot;</code></p><h4 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h4><p>-F，字段分隔符，默认为空格</p><p>-f，从脚本中读取命令</p><p>1）以冒号为分割，显示第一列和第三列的内容：</p><p><code>awk -F ：&#39;&#123;print $1 &quot;\t&quot; $3&#125;&#39; a.txt</code></p><p>2）以冒号为分割，显示UID大于500的用户信息：</p><p><code>awk -F : &#39;$3&gt;500&#39; /etc/passwd</code></p><p>3）以冒号为分割，搜索含root关键字的所有行：</p><p><code>awk -F &#39;/root/&#39; /etc/passwd</code></p><p>4）以冒号为分割，搜索UID大于500的用户，并显示sh</p><p><code>awk -F : &#39;$3&gt;500&#123;print $7&#125;&#39; /etc/passwd</code></p><p>5)BEGIN AND</p><p><code>awk -F : &#39;BEGIN&#123;print &quot;name \t uid&quot;&#125;&#123;print $1 &quot;\t&quot; $3&#125;END&#123;print&quot;from /etc/passwd&quot;&#125;&#39; /etc/passwd</code></p><h4 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h4><p>用法: grep  [选项]  PATTERN [FILE]</p><p>在每个 FILE 或是标准输入中查找 PATTERN。默认的 PATTERN 是一个基本正则表达式(缩写为 BRE)，也可以是拓展正则表达式。</p><p>例如: grep -i ‘hello world’ menu.h main.c</p><p><strong><u>options:</u></strong></p><p>-e :  使用正则表达式，用于指定多个搜索模式。</p><p>-E：使用拓展表达式</p><p>-i :  ignore-case忽略大小写</p><p>-v:  反转匹配。</p><p>-w, –word-regexp ，强制 PATTERN 仅完全匹配字词。</p><p>-x：完全匹配整行内容，包括行首行尾空格内容都要完全匹配。</p><p>-f :  指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式。</p><p>-c： 输出每个文件所匹配到的行数。</p><p>-r：递归搜索匹配内容</p><p>-L：列出不满足匹配要求的文件名，不输出行内容</p><p>-l ： 列出满足匹配要求的文件名，不输出行内容。</p><p>-z ：匹配一个 0 字节的数据行，但不是空行。</p><p>-m n：当匹配内容的行数达到n行后停止搜索,并输出停止前搜索到的匹配内容。</p><p>-o: 只输出匹配的具体字符串,匹配行中其他内容不会输出。</p><p>-q：安静模式,不会有任何输出内容,<code>echo $?</code>查找到匹配内容会返回0,未查找到匹配内容就返回非0</p><p>-s：不会输出查找过程中出现的任何错误消息。</p><p><u>输出线前缀控制：</u></p><p>-b：输出每一个匹配行或字符串时附上偏移量(从文件第一个字符到该匹配内容之间的字节数)</p><p>-n：输出匹配内容的同时输出其所在行号。</p><p>-H：在每一个匹配行之前加上文件名一起输出。</p><p>-h：不带文件名输出。</p><p>-T：在匹配信息和其前的附加信息之间加入tab以使格式整齐。</p><p><u>上下文线控制选项：</u></p><p>-A n：匹配到搜索到的行以及该行下面的n行</p><p>-B n：匹配到搜索到的行以及该行上面的n行</p><p>-C n：匹配到搜索到的行以及上下各n行</p><p>案例1：在&#x2F;home目录下查找所有内容含abc的文件名</p><p><code>grep -rl abc * </code></p><p>案例2：统计在passwd和shadow文件中含root的行数</p><p><code>grep -c root /etc/passwd /etc/shadow</code></p><h4 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h4><p> sed 全名为 stream editor，流编辑器，用程序的方式来编辑文本，功能相当的强大。是贝尔实验室的 Lee E.M 在 1974年开发完成，目前可以在大多数操作系统中使用。与vim等编辑器不同，sed 是一种非交互式编辑器，它使用预先设定好的编辑指令对输入的文本进行编辑，完成之后再输出编辑结构。</p><p>sed会一次处理一行内容，处理时，把当前处理的行存储在临时缓冲区中，成为”模式空间”pattern space，接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾，文件内容并没有改变。</p><p><strong>用法</strong>：sed [options]  ‘command’   file，options有-n，-e，-i，-f，-r选项。</p><p>-n      使用安静模式，加入-n 后只打印被匹配的行。<br>-e      多重编辑，命令顺序会影响结果。<br>-r       使用扩展正则表达式。<br>-i       将操作结果写入文档，不在屏幕上输出。<br>-f       指定一个 sed 脚本文件到命令行执行。</p><p>COMMNAD:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">a        在当前行后添加一行或多行</span><br><span class="line">c        用新文本修改（替换）当前行中的文本</span><br><span class="line">d        删除行</span><br><span class="line">i        在当前行之前插入文本</span><br><span class="line">p        从暂存区打印行</span><br><span class="line">s        用一个字符串替换另一个</span><br><span class="line">h        把模式空间里的内容复制到暂存缓存区</span><br><span class="line">H        把模式空间里的内容追加到暂存缓存区</span><br><span class="line">g       取出暂存缓冲区里的内容，将其复制到模式空间，覆盖该处原有内容</span><br><span class="line">G       取出暂存缓冲区里的内容，将其复制到模式空间，追加在原有内容后面</span><br><span class="line">l        列出非打印字符</span><br><span class="line">n       读入下一输入行，并从下一条命令而不是第一条命令开始处理</span><br><span class="line">q        结束或退出 sed</span><br><span class="line">r        从文件中读取输入行</span><br><span class="line">！       对所选行之外的所有行应用命令</span><br></pre></td></tr></table></figure><p>1）安静打印</p><p><code>sed -n &#39;p&#39; a.txt</code></p><p>或<code>sed &#39;r&#39; a.txt</code></p><p>2）每行打印两遍输出</p><p><code>sed &#39;p&#39; a.txt</code></p><p>3）只输出第2到5行，原文件内容不变</p><p><code>sed -n &#39;2,5p&#39; a.txt</code></p><p>4）打印第4行后退出</p><p><code>sed &#39;4q&#39; a.txt</code></p><p>5）<u>搜索</u>指定内容并打印</p><p>找到含abc的行并把该行输出：</p><p><code>sed -n &#39;/abc/p&#39; a.txt</code></p><p>注意与<code>sed &#39;/abc/p&#39; a.txt</code>的区别，这是全部输出并把这行打印2遍。</p><p>6）<u>删除</u></p><p>删除第2,到4行的数据：</p><p><code>sed &#39;2,4d&#39; a.txt</code></p><p>删除含abc的行：</p><p><code>sed &#39;/abc/d&#39; a.txt</code></p><p>7）追加a和插入i</p><p>在第二行下插入abc</p><p><code>sed &#39;2a abc&#39; a.txt</code></p><p>在第二行上插入abc</p><p><code>sed &#39;2i abc&#39; a.txt</code></p><p>8）整行替换</p><p>替换2,3,4行为abc</p><p><code>sed &#39;2,4c abc&#39; a.txt</code></p><p>9）字符串替换</p><p>全局替换将文件中的abc替换为a字符,g(global)</p><p><code>sed &#39;s/abc/a/g&#39; a.txt</code></p><p>仅换将文件中第3行的abc替换为a字符</p><p><code>sed &#39;3s/abc/a/g&#39; a.txt</code></p><p><u><strong>多条件替换</strong></u>：</p><p>将abc和def替换为a字符</p><p><code>sed -e &#39;s/abc/a/g;s/def/a/g&#39; a.txt</code></p><p>10）结果写入</p><p>使用-i选项，将原本输出到屏幕的结果写入文档。</p><p><code>sed -i &#39;/abc/p&#39; a.txt</code></p><p>11）从文件读入</p><p>子命令r，类似于a，也是将内容追加到指定行的后边，只不过r是将指定文件内容读取并追加到指定行下边。 </p><p>例：<code>sed &#39;2r b.txt&#39; a.txt</code></p><p>将b.txt文件内容读取并插入到a.txt文件第2行的下边。</p><h4 id="其他文本处理命令"><a href="#其他文本处理命令" class="headerlink" title="其他文本处理命令"></a>其他文本处理命令</h4><h5 id="nl-编写行号"><a href="#nl-编写行号" class="headerlink" title="nl 编写行号"></a>nl 编写行号</h5><p>nl  [options]  [file]，默认空行不统计</p><p>-b，选择样式，a所有、t非空行、n不显示、BRE正则(正则匹配的行才显示行号)</p><p>-n，–number-format&#x3D;格式，根据指定格式插入行号。</p><p> -w, –number-width&#x3D;数字，为行号使用指定的栏数。</p><p>-s, –number-separator&#x3D;字符串，可能的话在行号后添加字符串。</p><p>格式是下列之一:</p><p>  ln左对齐，空格不用0 填充<br>  rn 右对齐，空格不用0 填充<br>  rz 右对齐，空格用0 填充</p><p><code>nl -b a a.txt</code>，统计a.txt中所有行，</p><h5 id="wc词数统计"><a href="#wc词数统计" class="headerlink" title="wc词数统计"></a>wc词数统计</h5><p>wc [options]  [file]</p><p><code>wc a.txt</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">7 14 74 a.txt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">行数 字（单词）数 字节数</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1 1111 aaa</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">2 22222 bbb</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">3 33333  cccc</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">4 44444 ddd</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">5 bbb aaaaa</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">6 abd efddd</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">7 kkk baccccd</span></span><br></pre></td></tr></table></figure><p>options:</p><p>-w，只统计文件中单词数</p><p>-m，字符数</p><p>-c，统计字节数</p><p>-L，显示最长行长度（可见字符加空格）</p><p>-l，行数</p><h5 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h5><p><code>sort a.txt</code>，文本排序，默认按首字母、第一个数字顺序排序。</p><p>options:</p><p>-n，按数值大小排序。</p><p>-r，逆序排列。</p><p>-t，指定分隔符</p><p>-k，选取分隔后的哪一列</p><p>案例：按a.txt文件中第三列数字大小进行排序输出</p><p><code>sort -k 3 -n a.txt</code></p><h5 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h5><p><code>uniq a.txt</code>，去连续重行。</p><p>-d，只打印重复的行</p><p>-u，只打印不重复的行</p><p>-c，统计重复行的出现次数</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文介绍了如何使用linux正则表达式结合命令处理文本和awk,grep,sed三种文本工作命令。</summary>
    
    
    
    <category term="linux" scheme="https://aachou.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Git入门</title>
    <link href="https://aachou.github.io/2023/1201/"/>
    <id>https://aachou.github.io/2023/1201/</id>
    <published>2023-12-01T07:16:09.000Z</published>
    <updated>2023-12-27T04:16:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍的git版本控制、配置、命令操作、分支和文件状态等内容<span id="more"></span></p><h4 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h4><p>本地版本控制：在本地记录每一次版本更新。</p><p>集中版本控制：版本数据都保存在单一服务器，不联网就看不到版本信息。SVN</p><p>分布式版本控制：所有的版本信息都同步到本地的每个用户，可以离线在本地提交，只需在联网时push。Git</p><p><u>SVN与Git的区别：</u></p><ul><li>SVN 是集中式的；Git 是分布式的</li><li>SVN 的分支操作成本（创建&#x2F;删除&#x2F;合并）比 Git 高</li><li>SVN 是存储变更差异；Git 是存储文件快照</li><li>SVN必须联网操作，只有服务器上的版本控制；Git支持离线操作，有本地的版本控制</li></ul><h4 id="git配置"><a href="#git配置" class="headerlink" title="git配置"></a>git配置</h4><p>1）git\mingw64\etc\gitconfig ，–system系统级</p><p>2）C:\Users\用户\.gitconfig ，–global全局</p><p>Git branch 获取分支列表 ，列表保存到refs&#x2F;heads&#x2F;master 下面。</p><p><code>git config -l</code>，配置清单</p><p><code>git config --system --list</code>，系统配置</p><p><code>git config --global --list</code>，全局配置（用户配置）</p><p>安装好git后，设置用户名和邮箱（必要）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;xxx&quot;</span><br><span class="line">git config --global user.email &quot;xxx@qq.com&quot;</span><br></pre></td></tr></table></figure><p><strong>配置ssh公私钥连接远程仓库：</strong></p><p>在c:&#x2F;Users&#x2F;用户&#x2F;.ssh下打开git bash，运行<code>ssh-kengen</code>生成公私钥，将pub公钥粘贴到远程仓库配置中。</p><h4 id="工作区域"><a href="#工作区域" class="headerlink" title="工作区域"></a>工作区域</h4><p>git本地有四个工作区域：工作目录、暂存区(stage&#x2F;index)、资源库(repository)、远程仓库(remote repository)。</p><p>工作区：平时写代码项目文件的目录。</p><p>index&#x2F;stage：存放提交的文件列表信息的文件。</p><p>Local R本地仓库：存放提交的所有版本信息，HEAD指针总是指向当前分支。</p><p>Remote：托管代码的远程服务器。</p><h4 id="文件状态"><a href="#文件状态" class="headerlink" title="文件状态"></a>文件状态</h4><p>untracked：未加入到本地库中，不参与版本控制，使用git add变为staged状态</p><p>unmodify：文件已入库，未修改。被修改则变为modified文件或git rm移除版本库变为untracked状态。</p><p>modified：文件已修改。通过git add变为staged状态，或通过git checkout放弃修改回到unmodify状态。</p><p>staged：暂存状态。执行git commit提交到版本库中，文件变为unmodify状态，执行git reset HEAD filename取消暂存，文件变为modified状态。</p><h4 id="git对象模型"><a href="#git对象模型" class="headerlink" title="git对象模型"></a>git对象模型</h4><p>在git系统中有四种对象：   </p><p>commit：指向一个tree，纪录了文件操作，作者，提交者信息；  </p><p>tree：对象关系树，管理tree和blob的关系；   </p><p>blob：保存文件内容；   </p><p>tag：标记提交。</p><h4 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h4><p><code>git init</code>，本地创建一个新的项目。</p><p><code>git clone [url]</code>，克隆远程仓库上的项目代码。</p><p><code>git rm/mv [file]</code>，删除移动文件</p><p><code>git status [xx]</code>，查看文件状态。</p><p><code>git commit -m xxx</code>，提交暂存区中的内容到本地仓库，-v提交时显示diff信息。</p><p><code>git branch</code>，查看本地分支，-r查看远程，-d [name]删除分支，-rd删除远程分支</p><p><code>git branch [bname]</code>，新建分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 新建一个分支，与指定的远程分支建立追踪关系</span><br><span class="line">$ git branch --track [branch] [remote-branch]</span><br></pre></td></tr></table></figure><p><code>git merge [branch]</code>，合并分支到当前分支。</p><p><code>git checkout [branch]或git switch</code>，切换到指定分支，实际是移动HEAD指针。</p><p><code>git checkout [file]</code>，恢复暂存区文件到工作区。</p><p><code>git reset --hard [版本号]</code>，版本穿梭(切换版本)。</p><p><code>git log</code>，显示当前分支版本历史，-S [key]根据关键词搜索提交历史，–follow [file]显示某文件的版本历史，–oneline简洁显示。</p><p><code>git reflog</code>，显示当前分支的最近几次提交。</p><p><code>git shortlog -sn</code>，显示所有提交过的用户。</p><p><code>git blame [file]</code>，显示文件被什么人什么时间修改。</p><p><code>git diff</code>，显示工作区和暂存区的差异。</p><p><code>git show [commit]</code>，显示某次提交的时间和内容变化。</p><p><code>git fetch [remote]</code>，下载远程仓库变动到本地版本库。</p><p><code>git remote -v</code>，显示所有远程仓库，add添加仓库，remove删除。</p><p><code>git pull [remote] [branch]</code>，取回远程仓库分支的变化并与本地合并。</p><p><code>git push [remote] [branch]</code>，推送本地分支到远程仓库。</p><p>master分支主要用于发布新版本，常用工作分支使用dev等分支。</p><p>推送失败，因为最新提交和你试图推送的提交有冲突，两者对同一文件同一地点进行了<strong>修改</strong>。先用git pull把最新提交从origin&#x2F;dev抓下来，然后在本地合并，解决冲突再推送或者进行git reset回滚。git pull也失败了，原因是没有指定本地dev分支与远程origin&#x2F;dev分支的链接，根据提示，设置dev和origin&#x2F;dev的链接。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --set-upstream-to=origin/dev dev</span><br></pre></td></tr></table></figure><p>这回git pull成功，但是合并有冲突，需要手动合并，即vim编辑冲突的文件，删除特殊符号，决定保留哪些内容，wq保存后，提交暂存区，提交本地库，再push。</p><h4 id="gitignore忽略文件"><a href="#gitignore忽略文件" class="headerlink" title=".gitignore忽略文件"></a>.gitignore忽略文件</h4><p>在目录下创建.gitignore文件，将某些文件排除在版本控制外。</p><p><code>#</code>：注释。</p><p><code>tmp/*.txt</code>：忽略tmp目录所有以.txt结尾的文件，不包括<code>tmp/d/*.txt</code>。</p><p><code>!</code>：除了这个文件外忽略所有</p><p><code>/tmp</code>：忽略除tmp文件夹外的其他文件</p><p><code>tmp/</code>：忽略tmp目录下的所有文件</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">HELP.md</span><br><span class="line">target/</span><br><span class="line">!.mvn/wrapper/maven-wrapper.jar</span><br><span class="line">!**/src/main/**/target/</span><br><span class="line">!**/src/test/**/target/</span><br><span class="line"></span><br><span class="line">### STS ###</span><br><span class="line">.apt_generated</span><br><span class="line">.classpath</span><br><span class="line">.factorypath</span><br><span class="line">.project</span><br><span class="line">.settings</span><br><span class="line">.springBeans</span><br><span class="line">.sts4-cache</span><br><span class="line"></span><br><span class="line">### IntelliJ IDEA ###</span><br><span class="line">.idea</span><br><span class="line">*.iws</span><br><span class="line">*.iml</span><br><span class="line">*.ipr</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="IDEA集成Git"><a href="#IDEA集成Git" class="headerlink" title="IDEA集成Git"></a>IDEA集成Git</h4><p>将所有克隆下来的git项目或新创建的git项目文件拷贝到IDEA项目中即可。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文介绍的git版本控制、配置、命令操作、分支和文件状态等内容</summary>
    
    
    
    <category term="git" scheme="https://aachou.github.io/categories/git/"/>
    
    
  </entry>
  
  <entry>
    <title>在windows下安装linux多系统</title>
    <link href="https://aachou.github.io/2023/1128/"/>
    <id>https://aachou.github.io/2023/1128/</id>
    <published>2023-11-28T01:16:09.000Z</published>
    <updated>2023-12-09T19:36:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>windows上安装linux系统等系统大致步骤如下，这里以安装kali为例：<span id="more"></span></p><p>1、准备好系统文件和存储空间</p><p>首先下载kali镜像文件，其次在windows磁盘管理上划出一块空闲的磁盘分区，至少10G。在一块磁盘上选择压缩卷，输入空间大小，完成后可以看到一块黑色未格式化的磁盘。</p><p>2、需要一个U盘制作系统启动盘</p><p>先格式化u盘，保证U盘中没有数据。再使用rufus、软碟通或win32diskImage等软件将iso镜像文件写入u盘。其次通过win+r键输入msinfo32查看BIOS模式，现通常为UEFI模式，也可能为Legacy模式启动(需要分配一个MBR启动分区)。</p><p>若为UEFI模式，在安装时可以不选择UEFI安装也可以强制UEFI安装。通过UEFI安装，在磁盘分区手动分配时需要分配一个efi系统启动分区，可启动标志为开。</p><p>3、完成后插入U盘</p><p>重启电脑，按F12或其他BIOS按键进入启动选择管理界面，选择U盘安装启动。</p><p>4、进入安装引导界面安装。</p><p>磁盘分区挂载时选择windows上的空闲分区，不要选U盘，因为我们要把系统安装在主机磁盘上。若只有U盘没有显示其他空闲分区，则终止安装，重启系统按F2或Delete进入系统BIOS配置界面，将Storage磁盘存储模式改为AHCI模式，而不是RST模式！重启再次进入安装程序，可以看到系统已经能识别主机磁盘了。</p><p>5、设置中文界面</p><p>需要root权限，在命令行输入<code>dpkg-reconfigure locales</code>打开配置界面，取消en_US.UTF-8选项，勾选zh_CN.UTF-8。Tab选择ok回车，并设置默认系统环境，上下键选择zh_CN.UTF-8，选ok回车。</p><p>6、配置软件源</p><p>找到&#x2F;etc&#x2F;apt目录下的sources.list文件，将默认软件源注释掉，写入阿里云软件源，或者清华、中科大镜像源都行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/kali kali-rolling main contrib non-free non-free-firmware</span><br><span class="line">deb-src http://mirrors.aliyun.com/kali kali-rolling main contrib non-free non-free-firmware</span><br></pre></td></tr></table></figure><p>使用apt update更新软件源。</p><p>7、安装中文输入法</p><p>需要root用户权限，首先安装中文字体ttf-wqy-zenhei，安装fcitx输入法和拼音，补全安装apt –fix-broken install。</p><p><code>apt install fcitx fcitx-pinyin</code></p><p>打开设置，找到input输入法，设置输入法为fcitx选项。再在设置中找到fcitx配置，添加中文拼音输入，设置默认键盘为汉语，然后重启系统即可。另外，激活输入法快捷键为ctrl+space，切换为ctri+shift。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;windows上安装linux系统等系统大致步骤如下，这里以安装kali为例：</summary>
    
    
    
    <category term="linux" scheme="https://aachou.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>docker实战</title>
    <link href="https://aachou.github.io/2023/1122/"/>
    <id>https://aachou.github.io/2023/1122/</id>
    <published>2023-11-22T03:38:31.000Z</published>
    <updated>2023-11-22T03:42:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文将讲述如何使用docker制作tomcat镜像并上传至阿里云，部署redis和springboot项目。<span id="more"></span></p><h4 id="制作tomcat镜像"><a href="#制作tomcat镜像" class="headerlink" title="制作tomcat镜像"></a>制作tomcat镜像</h4><p>通过dockerfile制作一个tomcat镜像并发布到阿里云镜像仓库。</p><p>1、在用户工作的主目录中创建一个build&#x2F;tomcat文件夹</p><p>2、准备tomcat和jdk安装包上传到该文件夹下</p><p>3、在文件夹下创建一个README.txt文件并编写Dockerfile文件</p><p><code>touch README.txt</code></p><p><code>vim Dockerfile</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">FROM centos#本地基础镜像docker images查看是否有该镜像否则将失败</span><br><span class="line">MAINTAINER zzh&lt;xxxx@qq.com&gt;</span><br><span class="line">COPY README.txt /usr/local/</span><br><span class="line">ADD /root/build/tomcat/apache-tomcat-8.5.94.tar.gz /usr/local/</span><br><span class="line">ADD /root/build/tomcat/jdk-8u151-linux-x64.tar.gz /usr/local/</span><br><span class="line"></span><br><span class="line">RUN yum -y install vim</span><br><span class="line">RUN yum -y install net-tools</span><br><span class="line"></span><br><span class="line">ENV MYPATH /usr/local</span><br><span class="line">WORKDIR $MYPATH</span><br><span class="line"></span><br><span class="line">ENV JAVA_HOME /usr/local/jdk1.8.0_151</span><br><span class="line">ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools/jar</span><br><span class="line">ENV CATALINA_HOME /usr/local/apache-tomcat-8.5.94</span><br><span class="line">ENV CATALINA_BASH /usr/local/apache-tomcat-8.5.94</span><br><span class="line">ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin</span><br><span class="line"></span><br><span class="line">EXPOSE 8080</span><br><span class="line"></span><br><span class="line">CMD /usr/local/apache-tomcat-8.5.94/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-8.5.94/logs/catalina.out</span><br></pre></td></tr></table></figure><p>4、构建diytomcat镜像</p><p><code>docker build -t diytomcat .</code></p><p>5、创建容器运行</p><p><code>docker run -d -p 3355:8080 --name mytomcat01 -v /root/build/tomcat/test:/usr/local/apache-tomcat-8.5.94/webapps/test -v /root/build/tomcat/logs:/usr/local/apache-tomcat-8.5.94/logs diytomcat</code></p><p>6、测试运行</p><p>在linux主机测试：curl localhost:3355或直接访问。</p><p>7、上传至阿里云镜像仓库</p><p><code>docker login --username=xxx registry.cn-shanghai.aliyuncs.com</code></p><p>#重命名镜像</p><p><code>docker tag 镜像 registry.cn-shanghai.aliyuncs.com/命名空间/仓库名:tag</code></p><p><code>docker push registry.cn-shanghai.aliyuncs.com/命名空间/仓库名:tag</code></p><h4 id="Redis集群部署"><a href="#Redis集群部署" class="headerlink" title="Redis集群部署"></a>Redis集群部署</h4><p>1、创建网络</p><p><code>docker network create redis --subnet 172.17.0.0/16</code></p><p>2、通过脚本创建redis配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">for port in $(seq 1 6); \</span><br><span class="line">do \</span><br><span class="line">mkdir -p /mydata/redis/node-$&#123;port&#125;/conf</span><br><span class="line">touch /mydata/redis/node-$&#123;port&#125;/conf/redis.conf</span><br><span class="line">cat &lt;&lt; EOF &gt;/mydata/redis/node-$&#123;port&#125;/conf/redis.conf</span><br><span class="line">port 6379</span><br><span class="line">bind 0.0.0.0</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file node.conf</span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line">cluster-announce-ip 172.17.0.1$&#123;port&#125;</span><br><span class="line">cluster-announce-port 6379</span><br><span class="line">cluster-announce-bus-port 16379</span><br><span class="line">appendonly yes</span><br><span class="line">EOF</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">docker run -p 637$&#123;port&#125;:6379 -p 16371:16379 --name redis-$&#123;port&#125; \</span><br><span class="line">-v /mydata/redis/node-$&#123;port&#125;/data:/data \</span><br><span class="line">-v /mydata/redis/node-$&#123;port&#125;/conf/redis.conf:/etc/redis/redis.conf \</span><br><span class="line">-d --net redis --ip 172.17.0.1$&#123;port&#125; redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>docker run -p 6371:6379 -p 16371:16379 --name redis-1 \ -v /mydata/redis/node-1/data:/data \ -v /mydata/redis/node-1/conf/redis.conf:/etc/redis/redis.conf \ -d --net redis --ip 172.17.0.11 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf</code></p><p>3、查看redis容器，进入容器</p><p><code>docker ps</code></p><p><code>docker exec -it redis-1 /bin/sh</code></p><p>3、创建redis集群</p><p><code>redis-cli --cluster create 172.17.0.11:6379 172.17.0.12:6379 172.17.0.13:6379 172.17.0.14:6379 172.17.0.15:6379 172.17.0.16:6379 --cluster-relicas 1 </code></p><p>4、查看集群</p><p><code>redis-cli -c</code></p><p><code>cluster info</code></p><p><code>cluster nodes</code></p><h4 id="SpringBoot微服务打包docker镜像"><a href="#SpringBoot微服务打包docker镜像" class="headerlink" title="SpringBoot微服务打包docker镜像"></a>SpringBoot微服务打包docker镜像</h4><p>1、将springboot项目打包为xxx.jar</p><p>2、编写Dockerfile文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM java:8</span><br><span class="line">MAINTAINER z&lt;xx@qq.com&gt;</span><br><span class="line"></span><br><span class="line">COPY *.jar  /app.jar</span><br><span class="line">EXPOSE 8080</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]</span><br></pre></td></tr></table></figure><p>3、构建镜像</p><p><code>docker build -t myApp .</code></p><p>4、发布镜像，下载镜像运行</p><p><code>docker push myApp</code></p><p><code>docker pull myApp</code></p><p><code>docker run -d -p 8080:8080 --name X-WEB-APP myApp</code></p><p>5、测试</p><p><code>curl localhost:8080</code></p><h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><p>compose、swarm、Jenkins</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将讲述如何使用docker制作tomcat镜像并上传至阿里云，部署redis和springboot项目。</summary>
    
    
    
    <category term="docker" scheme="https://aachou.github.io/categories/docker/"/>
    
    
  </entry>
  
  <entry>
    <title>docker入门</title>
    <link href="https://aachou.github.io/2023/1121/"/>
    <id>https://aachou.github.io/2023/1121/</id>
    <published>2023-11-21T02:17:40.000Z</published>
    <updated>2023-12-04T00:09:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>什么是Docker</p><p>Docker是内核级别的虚拟化，可以在一个物理机上可以运行很多的容器实例。服务器的性能可以被压榨到极致。Docker是基于Go语言开发的，开源项目。<span id="more"></span></p><p><strong>镜像（image）：</strong><br>docker镜像就好比是一个模板，可以通过这个模板来创建容器服务，镜像&#x3D;&gt;run&#x3D;&gt;容器，通过这个镜像可以创建多个容器（最终服务运行或者项目运行就是在容器中的）。</p><p><strong>容器（container）：</strong><br>Docker利用容器技术，独立运行一个或者一个组应用，通过镜像来创建的。启动，停止，删除。</p><p><strong>仓库（repository）：</strong><br>仓库就是存放镜像的地方。</p><p>官网：<a href="https://www.docker.com/">https://www.docker.com/</a><br>文档地址：<a href="https://docs.docker.com/">https://docs.docker.com/</a><br>Doker镜像仓库地址：<a href="https://hub.docker.com/">https://hub.docker.com/</a></p><h4 id="Linux下安装docker"><a href="#Linux下安装docker" class="headerlink" title="Linux下安装docker"></a>Linux下安装docker</h4><p>1、需要的安装包</p><p>yum install -y yum-utils</p><p>2、设置镜像的仓库</p><p><code>yum config-manager  --add-repo  http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</code></p><p>3、更新yum软件包索引。</p><p>yum makecache</p><p>4、安装</p><p><code>yum install docker-ce docker-ce-cli containerd.io</code></p><p>5、启动docker</p><p>systemctl start docker&#96;</p><p>6、使用docker version查看是否安装成功</p><p>docker run hello-world</p><h4 id="配置阿里云镜像加速"><a href="#配置阿里云镜像加速" class="headerlink" title="配置阿里云镜像加速"></a>配置阿里云镜像加速</h4><p>登录阿里云，找到容器服务。找到镜像加速地址，配置使用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json   &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">&quot;registry-mirrors&quot;: [&quot;https://xxx.xxx.xxx.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h4 id="docker命令"><a href="#docker命令" class="headerlink" title="docker命令"></a>docker命令</h4><p><code>docker --help</code> 帮助</p><p><code>docker version</code> 版本</p><p><code>docker info</code> 详细信息</p><p><code>docker stats</code>实时查看容器运行情况 </p><p><code>docker history IMAGEID</code>查看镜像构建记录</p><p><strong>镜像命令</strong>：</p><p><code>docker images  [-a所有镜像,-q只要镜像ID]</code>查看本机镜像</p><p><code>docker tag 镜像id 新镜像名:tag标签</code> 克隆命名新的镜像</p><p><code>docker search xxx </code> 搜素镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search mysql --filter=STARS=3000</span><br></pre></td></tr></table></figure><p>[root@CentOS7 docker]# docker search mysql –filter&#x3D;STARS&#x3D;3000<br>NAME      DESCRIPTION                                      STARS     OFFICIAL   AUTOMATED<br>mysql     MySQL is a widely used, open-source…   14616     [OK]<br>mariadb   MariaDB Server is a high performing…   5573      [OK]   </p><p><code>docker pull xx</code>  <strong><u>下载镜像</u></strong>，默认最新版（分层下载，节省开销，加快速度）</p><p>指定版本下载：docker pull mysql:5.7  </p><p><code>docker rmi [-f] 镜像名/镜像ID</code>  删除镜像</p><p>**<u>删除所有镜像</u>**文件： <code>docker rmi -f $(docker images -aq)</code> </p><p><strong><u>生成镜像</u></strong></p><p><code>docker commit 容器id xx镜像名</code>，根据容器的changes生成一个镜像，-a，作者名；-m，信息。</p><p><code>docker build [options] 生成路径path</code>，根据dockerfile生成镜像。</p><p>docker build [选项] 镜像名[:标签]或者上下文路径或者URL  所执行目录（.表示在当前目录执行）</p><p>例：<code>docker build -f mydockerfile -t mytomcat .</code></p><p><u><strong>上传提交镜像</strong></u></p><p><code>docker push [OPTIONS] NAME[:TAG]</code>，上传一个镜像到远程仓库。</p><p>Options:<br>  -a, –all-tags，将所有版本的镜像提交。<br>      –disable-content-trust   忽略镜像提示。<br>  -q, –quiet  ，简洁生成。</p><p><u>上传到dockerhub</u></p><p>1）在hub.docker.com创建账号</p><p>2）登录账户：docker login -u  xxx  -p </p><p>3）上传镜像</p><p><code>docker push 镜像:tag</code></p><p><u>上传到阿里云</u></p><p>1）登录到阿里云，找到容器镜像服务</p><p>2）创建命名空间</p><p>3）创建容器镜像仓库</p><p>4）查看仓库基本信息，获取ip地址，按照操作指南执行</p><p>5）比如登录：</p><p><code>sudo docker login --usename xxx registry.cn-beijing.aliyuncs.com</code></p><p><strong>容器命令</strong>：</p><p>有了镜像才能创建容器。</p><p><strong><u>运行容器</u></strong></p><p><code>docker run [options] 镜像 </code>，创建容器运行镜像</p><p><code>--name</code>， 命名容器，Repository:Tag</p><p><code>--rm</code>，退出时删除容器</p><p><code>-d</code> ，以后台方式运行，若容器不向客户端提供服务则停止运行</p><p><code>-it</code> ，交互方式运行，启动进入容器查看内容</p><p>exit或ctrl+d退出停止运行；ctrl + p + q退出不停止</p><p><code>-p</code> ，指定容器端口，主机端口：容器端口</p><p>例1：交互式运行centos</p><p><code>docker run -it centos /bin/bash</code> #会进入容器的交互终端</p><p><code>docker run -itd centos /bin/bash</code> #以后台交互方式运行容器，不会进入容器</p><p>后面的&#x2F;bin&#x2F;bash的作用是表示运行bash ,docker中必须要保持一个进程的运行，这个&#x2F;bin&#x2F;bash就表示启动容器后启动bash。</p><p>例2：以脚本方式运行centos镜像，每隔1秒启动容器。</p><p><code>docker run -d centos /bin/bash -c &quot;while true;do echo xxx;sleep 1 ; done&quot;</code></p><p>例3：以后台方式创建容器运行nginx镜像，并向外开放3344端口</p><p><code>docker run -d --name nginx01 -p 3344:80 nginx</code></p><p><strong><u>查看容器</u></strong></p><p><code>docker ps  [options]</code>，查看正在运行的容器</p><p><code>-a</code>查看运行记录，<code>-n=?</code>显示最近运行的容器，<code>-q</code>显示ID</p><p><code>docker container ls</code></p><p><strong><u>删除容器</u></strong></p><p><code>docker rm 容器id</code>，删除容器；-f，强制删除</p><p>例：删除所有容器</p><p><code>docker rm -f $(docker ps -aq)</code></p><p><strong><u>启动和停止容器</u></strong></p><p><code>docker start 容器id</code></p><p><code>docker restart 容器id</code></p><p><code>docker stop 容器id</code> </p><p><code>docker kill id</code>，强制停止运行</p><p><strong><u>（生成）镜像</u></strong></p><p><code>docker container commit 容器id xx镜像名</code>，<code>-a</code>，作者名，<code>-m</code>，信息。</p><p><code>docker build [options] 生成路径path</code>，根据dockerfile生成镜像。</p><p>docker build [选项] 镜像名[:标签]或者上下文路径或者URL  所执行目录（.表示在当前目录执行）</p><p>-f指定dockerfile文件，-t命名镜像</p><p>例1：提交容器3fdf3rfe4生成镜像tomcat01</p><p><code>docker commit -a=&quot;xxx&quot; -m=&quot;xxx&quot; 3fdf3rfe4 tomcat01:1.0</code></p><p>例2：根据dockerfile生成镜像保存到当前目录</p><p><code>docker build -f /home/dockerfile -t myimage:1.0 .</code></p><p><strong>其他命令：</strong></p><p><code>docker logs [options] 容器id</code>，查看日志</p><p>Options:<br> –details，显示详细信息<br>-f, –follow  ，实时输出日志<br>–since ，显示在某个时间后的日志<br>-n, –tail ，展示最后n行日志<br>-t, –timestamps   ,显示时间<br>–until  ,显示一个时间前的日志</p><p><code>docker top 容器id</code>，查看<u>正在运行的容器中</u>的进程</p><p><code>docker inspect 容器id</code>，查看容器的元数据(返回的JSON格式)</p><p><code>docker exec -it 容器id /bin/bash</code>，以新终端进入正在运行的容器</p><p><code>docker attach 容器id</code>，进入容器正在运行的终端</p><p><code>docker cp 容器id:文件绝对路径 主机目的路径</code>，从容器中拷贝文件到主机</p><p><code>docker pause 容器id</code>  悬挂中断</p><p><code>docker unpause 容器id</code>  </p><h4 id="部署安装Tomcat、ES"><a href="#部署安装Tomcat、ES" class="headerlink" title="部署安装Tomcat、ES"></a>部署安装Tomcat、ES</h4><p><u>tomcat</u></p><p>1、下载镜像</p><p><code>docker pull tomcat:9.0</code></p><p>2、启动镜像</p><p><code>docker run -d --name tomcat01 -p 3355:8080 tomcat:9.0</code></p><p>3、进入tomcat容器中，配置&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;webapps目录</p><p><code>docker exec -it tomcat01 /bin/bash</code></p><p><code>cp -r webapps.dist webapps</code></p><p>4、访问测试</p><p><code>docker ps</code></p><p><code>curl localhost:3355</code></p><p><u>ES</u></p><p><code>docker run -d  --name es01 -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; -e ES_JAVA_OPTS=&quot;-Xms64m -Xmx512m&quot; elasticsearch:7.7.0</code></p><h4 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h4><p>让容器内的文件数据与linux主机或容器之间同步互通，形成共享，修改容器配置文件时可直接在主机服务器上修改，不需要进入容器，实现容器数据持久化。</p><p><strong>方式一、-v卷挂载命令</strong></p><p>例：<code>docker run -it -v 主机路径:容器内路径 centos /bin/bash</code></p><p>在主机上通过docker inspect 容器，查看mount挂载情况。</p><p>例：安装mysql同步数据</p><p><code>docker pull mysql:5.7</code></p><p><code>docker run -d -p 3304:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql_01 mysql:5.7</code></p><p>参数说明：-d后台运行，-p端口映射，-v卷映射，-e环境配置。</p><p>容器启动成功后在本地连接3304端口连接数据库。</p><p><u>匿名挂载：-v  容器内路径</u></p><p><code>docker run -d -p --name nginx01 -v /etc/nginx nginx</code></p><p><u>具名挂载：-v  卷名:容器内路径</u></p><p><code>docker run -d -p --name nginx01 -v nginx_01:/etc/nginx nginx</code></p><p>默认卷挂载到本地的<code>/var/lib/docker/volumes/</code></p><p><u>指定路径挂载：-v  本地路径:容器路径</u></p><p><code>docker run -d -p --name nginx01 -v /home/nginx01/:/etc/nginx nginx</code></p><p><strong>卷管理</strong></p><p><code>docker volume [options]</code>，管理数据卷，参数说明：</p><p>create ，创建一个卷；<br>inspect，查看卷详细信息；<br>ls，列出所有卷；<br>prune，删除未使用的本地卷；<br>rm，删除卷  </p><p><strong>方式二、dockerfile</strong></p><p>1、创建一个dockerfile文件</p><p><code>vim dockerfile</code></p><p>2、编写dockerfile</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">VOLUME [&quot;volume01&quot;]</span><br><span class="line">CMD echo &quot;----end----&quot;</span><br><span class="line">CMD /bin/bash</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">解释</span></span><br><span class="line">FROM 镜像名:标签 #FROM指定基础镜像，其必须为Dcokerfile中第一条指令</span><br><span class="line">RUN 命令   #在该镜像中执行命令，如果执行多个命令用 &amp;&amp;连接起来</span><br></pre></td></tr></table></figure><p>3、docker build 生成镜像文件</p><p><code>docker build -f /home/dockerfile -t 镜像名(repo):版本标签(tag) .</code></p><p><strong>方式三、容器之间–volumes-from</strong></p><p>创建一个容器docker02与其他容器共享数据。</p><p><code>docker run -it --name docker02 --volumes-from docker01 nginx</code></p><p>删除容器docker01数据依旧存在，因为它的数据在本地&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volume下。</p><h4 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h4><p>dockerfile用来构建镜像文件，命令脚本。</p><p><u>dockerfile指令</u>：</p><p>FROM  #基础镜像<br>MAINTAINER  #维护者，姓名+邮箱<br>RUN  #<u>镜像构建时需要运行的命令</u><br>ADD  #添加文件，若是压缩包则自动解压<br>WORKDIR #镜像工作目录<br>VOLUME  #挂载目录<br>EXPOSE #保留端口配置<br>CMD #指容器启动需要运行的命令，只有最后一个生效，追加命令会覆盖<br>ENTRYPOINT #指定容器运行时需要的命令，可以docker run时追加命令<br>ONBUILD #当构建一个被继承的dockerfile时触发onbuild指令<br>COPY #将主机文件拷贝到制作的镜像中<br>ENV  #构建时设置环境变量</p><p>例：编写一个mycentos镜像文件，生成镜像</p><p><code>vim mydockerfile-centos</code></p><p><code>FROM centos</code><br><code>MAINTAINER z&lt;zzh@163.com&gt;</code><br><code>ENV MYWORKPATH /usr/local</code><br><code>WORKDIR $MYWORKPATH</code><br><code>RUN yum -y install vim</code><br><code>RUN yum -y install net-tools </code><br><code>EXPOSE 80</code><br><code>CMD echo $MYWORKPATH</code><br><code>CMD echo &quot;---end---&quot;</code><br><code>CMD /bin/bash</code></p><p><code>docker build -f mydockerfile-centos -t mycentos:1.0 . </code></p><p><strong>CMD与ENTRYPOINT比较</strong></p><p>相同点：</p><p>1、只能写一条，如果写了多条，那么只有最后一条生效</p><p>2、容器启动时才运行，运行时机相同</p><p>不同点：</p><p>ENTRYPOINT不会被运行的command覆盖，而CMD则会被覆盖，如果我们在Dockerfile种同时写了ENTRYPOINT和CMD，并且CMD是一个完整的指令，那么它们两个会互相覆盖，谁在最后谁生效。</p><h4 id="docker网络"><a href="#docker网络" class="headerlink" title="docker网络"></a>docker网络</h4><p>docker网络是一种虚拟网络，网络为成对的bridge桥接模式。主机可与创建的容器进行通信，但是容器之间通信需要额外的操作。docker默认给容器分配一个虚拟内部ip地址，网络为docker0。</p><p>例：<code>docker exec -it tomcat01 ping tomcat01</code></p><p>无法ping通，因为容器在docker0网络，无法通过容器名ping通。</p><p><u>ping不同的另一种原因：</u></p><p><code>OCI runtime exec failed: exec failed: unable to start container process: exec: &quot;ping&quot;: executable file not found in $PATH: unknown</code></p><p>以上报错是因为docker创建的容器相当于一个miniLinux，很多命令和软件没有安装，包括network这一网络工具都没有。下载软件包只能通过apt-get或wget和curl命令。</p><p><strong>docker network网络管理</strong></p><p><code>docker network [options]</code>，options如下：</p><p>connect，连接容器到网络</p><p>create，创建网络</p><p>inspect ，查看网络</p><p>ls ，列出所有网络</p><p>rm ，删除网络</p><p><strong>–link实现单向通信</strong></p><p>运行tomcat02容器，使其能够与tomcat01通信。原理是在容器的&#x2F;etc&#x2F;hosts文件中配置了主机名与ip地址映射。</p><p><code>docker run -d --name tomcat02 --link tomcar01 tomcat</code></p><p><strong>自定义网络</strong></p><p>自定义网络支持通过容器名通信，<u>创建一个自定义网络</u>：</p><p><code>docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 Mynet</code></p><p><strong>–net指定网络</strong></p><p>使用自定义网络创建容器，在该网络中为容器分配ip：</p><p><code>docker run -d --name tomcat02 --net Mynet tomcat</code></p><p>在该网络中的容器可以相互通信，可ping tomcat02。</p><p><strong>容器-网络连接</strong></p><p>如何让一个容器连接到另一个网络或者与另一个网络中的容器通信，可使用docker network connect，原理是将容器添加到该网络中。</p><p>docker network connect [OPTIONS] NETWORK CONTAINER</p><p>Options:<br>      –alias          为网络添加作用范围scope<br>      –driver-opt      选择网络模式driver<br>      –ip     指定一个容器ip地址<br>      –link list   添加到另一个容器的连接<br>      –link-local-ip 为容器添加一个本地ip地址</p><p><code>docker network connect Mynet tomcat02</code>，将tomcat02挂到Mynet网络。</p><p>可使用docker network inspect 查看网络中有哪些容器。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;什么是Docker&lt;/p&gt;
&lt;p&gt;Docker是内核级别的虚拟化，可以在一个物理机上可以运行很多的容器实例。服务器的性能可以被压榨到极致。Docker是基于Go语言开发的，开源项目。</summary>
    
    
    
    <category term="docker" scheme="https://aachou.github.io/categories/docker/"/>
    
    
  </entry>
  
  <entry>
    <title>linux进阶</title>
    <link href="https://aachou.github.io/2023/1114/"/>
    <id>https://aachou.github.io/2023/1114/</id>
    <published>2023-11-14T01:11:52.000Z</published>
    <updated>2023-12-24T10:19:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇介绍linux日志管理、内核升级、数据备份与恢复的相关内容。<span id="more"></span></p><p>linux系统文件结构：</p><p>&#x2F; 根目录<br>&#x2F;bin 存放必要的命令<br>&#x2F;boot 存放内核以及启动所需的文件<br>&#x2F;dev 存放设备文件<br>&#x2F;etc 存放系统配置文件<br>&#x2F;home 普通用户的宿主目录，用户数据存放在其主目录中lib 存放必要 的运行库<br>&#x2F;mnt 存放临时的映射文件系统，通常用来挂载使用<br>&#x2F;proc 存放存储进程和系统信息<br>&#x2F;root 超级用户的主目录<br>&#x2F;sbin 存放系统管理程序<br>&#x2F;tmp 存放临时文件<br>&#x2F;usr 存放应用程序，命令程序文件、程序库、手册和其它文档。<br>&#x2F;var 系统默认日志存放目录录</p><h4 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h4><p>rsyslogd日志管理服务，配置文件&#x2F;etc&#x2F;rsyslog.conf，各日志文件有：</p><p>&#x2F;var&#x2F;log&#x2F;boot.log系统启动日志</p><p>&#x2F;var&#x2F;log&#x2F;cron记录定时任务</p><p>&#x2F;var&#x2F;log&#x2F;lastlog记录最后一次登录信息</p><p>&#x2F;var&#x2F;log&#x2F;message记录系统重要信息</p><p>&#x2F;var&#x2F;log&#x2F;secure记录验证授权信息</p><p>&#x2F;var&#x2F;log&#x2F;wtmp和&#x2F;var&#x2F;log&#x2F;btmp 记录登录和失败登录信息</p><p>&#x2F;var&#x2F;tuned&#x2F;ulmp&#x2F;记录当前登录用户的信息</p><h5 id="日志类型"><a href="#日志类型" class="headerlink" title="日志类型"></a>日志类型</h5><p>auth      #pam产生的日志</p><p>authpriv    #ssh\ftp等登录产生的日志</p><p>cron  #时间任务</p><p>kern  #内核</p><p>lpr  #打印</p><p>mail  #邮件</p><p>mark  #服务内部信息</p><p>user  #用户程序信息</p><p>uucp  #主机通信</p><p>local 1-7   #自定义设备</p><h5 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h5><p>由低到高：</p><p>debug  调试信息</p><p>info   一般信息</p><p>notice 重要信息</p><p>warning 警告</p><p>err  错误</p><p>crit 严重错误</p><p>alert 修改</p><p>emerge 内核崩溃</p><p>none  不记录</p><h4 id="日志轮替"><a href="#日志轮替" class="headerlink" title="日志轮替"></a>日志轮替</h4><p>创建新的日志文件，删除旧的日志，日志轮替配置文件&#x2F;etc&#x2F;logrotate.conf。日志轮替依赖于系统定时任务，在&#x2F;etc&#x2F;cron.daily&#x2F;目录下有logrotate可执行文件。</p><p>keep 4 weeks worth of backlogs<br>rotate 4</p><p>#共保存 4 份日志文件,当建立新的日志文件时,旧的将会被删。</p><p>use date as a suffix of the rotated file</p><p>dateext</p><p>#以日期为后缀</p><h5 id="自定义日志轮替"><a href="#自定义日志轮替" class="headerlink" title="自定义日志轮替"></a>自定义日志轮替</h5><p>自定义日志轮替规则，如：</p><p>&#x2F;var&#x2F;log&#x2F;wtmp {<br>    monthly<br>    create 0664 root utmp<br>minsize 1M<br>    rotate 1<br>}</p><p>1）直接在&#x2F;etc&#x2F;logrotate.conf中写入该日志轮替规则。</p><p>2）在&#x2F;etc&#x2F;logrotate.d&#x2F;目录中建立新的日志文件，在文件中写入轮替策略。</p><p>参数说明：</p><p>daily，每天轮替</p><p>weekly，每周轮替</p><p>monthly ， 每月轮替</p><p>rotate  数字， 保留日志文件个数</p><p>compress ，轮替时对旧的日志压缩</p><p>create mode  owner  group ， 创建新日志时指定权限所有者所在组</p><p>mail  address ，日志轮替时输出内容到指定邮件地址</p><p>missingok ， 若日志不存在则忽略该日志警告</p><p>notifepmty ，  若日志为空则不轮替</p><p>minsize  大小 ，日志大小达到最小值才会轮替</p><p>size  大小，日志只有大于指定大小才进行轮替</p><p>dateext ，使用日期作为日志文件后缀</p><p>sharedscripts， 在此关键字后脚本只执行一次</p><p>prerotate&#x2F;endscript，在日志轮替之前执行脚本</p><p>postrotate&#x2F;endscript ，在日志轮替之后执行脚本</p><h4 id="内存日志"><a href="#内存日志" class="headerlink" title="内存日志"></a>内存日志</h4><p>journalctl   查看内存日志</p><p>journalctl  -n   3，查看最近3条</p><p>journalctl  –since   1:00  –until   1:30   ，查看某时间段日志</p><p>journalctl  -p   err，查看报错日志</p><p>journalctl  -o  verbose ，查看详细信息</p><p>journalctl _PID&#x3D;xxx  _COMM&#x3D;sshd ，查看带某参数信息的日志</p><p>journalctl  | grep sshd</p><h4 id="内核升级"><a href="#内核升级" class="headerlink" title="内核升级"></a>内核升级</h4><p>将linux系统的内核升级到兼容的版本</p><p><code>uname -a</code>：查看当前内核</p><p><code>yum info kernel -q</code>：检测内核版本</p><p><code>yum update kernel</code>：升级内核</p><p><code>yum list kernel -q</code>：查看已安装的内核</p><h4 id="数据备份和恢复"><a href="#数据备份和恢复" class="headerlink" title="数据备份和恢复"></a>数据备份和恢复</h4><p>2种方式：</p><p>1）把需要的文件用tar打包</p><p>2）dump和restore指令</p><p>若没有两个指令需要安装</p><p>yum  -y  install dump</p><p>yum  -y  install restore</p><h5 id="dump"><a href="#dump" class="headerlink" title="dump"></a>dump</h5><p>分区备份，增量备份，备份上次增加或修改过的文件</p><p><code>dump -cu -[123456789] -f 备份后的文件 -T 日期 [目录或文件系统]</code></p><p>参数说明：</p><p>-c，创建新的备份文件</p><p>-[0,1,2,3,4,5,6,7,8,9]，备份的层级，0为完整备份，0以上则备份上次修改或新增的文件，9以后再次轮替。</p><p>-f，指定备份后的文件名</p><p>-j，使用bizlib库压缩</p><p>-T，指定开始备份的时间和日期</p><p>-u，备份后在&#x2F;etc&#x2F;dumpdares中记录备份的文件系统，层级、日期时间</p><p>-t，指定文件名，若文件已备份则列出名称</p><p>-W，显示需要备份的文件及最后一次备份的层级时间</p><p>-w，只显示需要备份的文件</p><p>查看备份时间文件：cat  &#x2F;etc&#x2F;dumpdates</p><p>应用案例：</p><p>案例1：将&#x2F;boot分区所有内容备份到&#x2F;opt&#x2F;boot.bak.bz2文件中，备份的层级为0</p><p><code>dump -0uj -f /opt/boot.bak.bz2 /boot/</code> </p><p>案例2：在&#x2F;boot下创建一个新的文件hello.txt，增量备份，备份层级为1</p><p><code>vi hello.txt</code></p><p><code>dump -1uj -f /opt/boot.bak1.bz2  /boot/</code></p><p><strong>注意，dump不支持文件和目录的增量备份，只能0级备份</strong></p><p>例：备份&#x2F;etc目录到&#x2F;opt&#x2F;etc.bak.bz2</p><p><code>dump -0j -f /opt/etc.bak.bz2  /etc/</code></p><h5 id="restore"><a href="#restore" class="headerlink" title="restore"></a>restore</h5><p>恢复dump备份的数据文件。</p><p>restore  [模式mode]  [选项option]</p><p>首先指定一种模式执行，<code>-C</code>对比，<code>-i</code>交互，<code>-r</code>还原，<code>-t</code>查看文件。</p><p>选项：-f  备份文件，从dump备份文件中读取数据。</p><p>案例1：比较备份文件和原文件</p><p><code>restore -C -f /opt/boot.bak.bz2</code></p><p>案例2：查看备份了那些文件</p><p><code>restore -t -f /opt/boot.bak.bz2</code></p><p>案例3：还原备份文件&#x2F;opt&#x2F;boot.bak0.bz2到&#x2F;opt&#x2F;boottmp&#x2F;下</p><p><code>mkdir /opt/boottmp</code></p><p><code>cd /opt/boottmp</code></p><p>#恢复到第一次完全备份状态</p><p><code>restore -r -f /opt/boot.bak0.bz2</code></p><p>#若有增量备份文件boot.bak1.bz2则需要进行恢复，有几个恢复几个</p><p><code>restore -r -f  /opt/boot.bak1.bz2</code></p><h4 id="可视化管理"><a href="#可视化管理" class="headerlink" title="可视化管理"></a>可视化管理</h4><p>bt宝塔可视化管理面板可以帮助运维人员提高效率，支持一键安装集群和数据库。</p><p>安装：</p><p><code>yum install -y wget &amp;&amp; wget -O install.sh  http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh</code></p><p>安装成功后显示用户名和密码。</p><h4 id="权限安全"><a href="#权限安全" class="headerlink" title="权限安全"></a>权限安全</h4><p>尽量使用普通用户登录服务器，执行root命令时使用sudo操作。对于重要的系统文件可以进行锁定，<code>chattr +i /etc/passwd</code>，使自己和他人无法操作文件。</p><p>使用SUID、SGID、Sticky设置特殊权限</p><p>使用chkrootkit&#x2F;rootkit hunter工具检查系统文件是否被修改或异常，监测root脚本，下载地址chkrootkit.org。</p><p>使用Tripwire检测系统文件完整性。</p><h4 id="IO读写监控"><a href="#IO读写监控" class="headerlink" title="IO读写监控"></a>IO读写监控</h4><p>iotop可以监控磁盘读写情况，首先安装iotop，yum install iotop，iotop。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇介绍linux日志管理、内核升级、数据备份与恢复的相关内容。</summary>
    
    
    
    <category term="linux" scheme="https://aachou.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>找回mysql密码</title>
    <link href="https://aachou.github.io/2023/1113/"/>
    <id>https://aachou.github.io/2023/1113/</id>
    <published>2023-11-13T06:16:30.000Z</published>
    <updated>2023-11-13T06:20:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章记录了如何在Linux和windows下找回mysql密码。<span id="more"></span></p><h4 id="linux下找回Mysql密码"><a href="#linux下找回Mysql密码" class="headerlink" title="linux下找回Mysql密码"></a>linux下找回Mysql密码</h4><p>1、修改&#x2F;etc&#x2F;my.cnf文件</p><p>2、插入<code>skip-grant-tables</code></p><p>3、重启mysqld服务</p><p><code>service restart mysqld</code></p><p>4、进入mysql</p><p><code>mysql -u root  -p</code></p><p>5、修改mysql数据库中user表的authentication_string字段</p><p><code>use  mysql;</code></p><p><code>update user set authentication_string=password(&quot;12345678&quot;) where user=&#39;root&#39;;</code></p><p>#刷新权限</p><p><code>flush  privileges;</code></p><p>6、退出mysql，再次修改my.cnf配置文件</p><p><code>#skip-grant-tables</code></p><h4 id="windows下找回mysql密码"><a href="#windows下找回mysql密码" class="headerlink" title="windows下找回mysql密码"></a>windows下找回mysql密码</h4><p>1、停止MySQL服务</p><p>首先，我们需要停止MySQL服务。</p><p>net stop mysql</p><p>2、修改配置文件</p><p>在MySQL停止的情况下，我们需要修改MySQL的配置文件以跳过密码验证。在MySQL的安装目录中，找到名为my.ini或my.cnf的配置文件，使用文本编辑器打开该文件。在配置文件中找到[mysqld]部分，在该部分下添加以下一行代码：<br>skip-grant-tables</p><p>3、重启MySQL服务</p><p>现在，我们需要重新启动MySQL服务，并且由于我们已经修改了配置文件，MySQL将不再需要密码进行验证。以下是重启MySQL服务的步骤：</p><p>net start mysql</p><p>4、登录MySQL并修改密码</p><p>登录MySQL数据库并修改账户密码。</p><p>mysql -u root</p><p>如果使用的是其他账户，请将root替换为其他账户名。登录成功后，我们可以使用以下命令来修改密码：</p><p><code>ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;new_password&#39;;</code></p><p>修改密码成功后，可以退出MySQL数据库。</p><p>5、恢复配置文件</p><p>打开MySQL的安装目录，打开之前修改的配置文件（my.ini或my.cnf），删除或注释掉之前添加的一行。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这篇文章记录了如何在Linux和windows下找回mysql密码。</summary>
    
    
    
    <category term="mysql" scheme="https://aachou.github.io/categories/mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux常用指令</title>
    <link href="https://aachou.github.io/2023/1112/"/>
    <id>https://aachou.github.io/2023/1112/</id>
    <published>2023-11-12T09:49:23.000Z</published>
    <updated>2023-12-21T03:00:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>在学习linux的过程中，有一些指令经常使用，下面是学习笔记。<span id="more"></span></p><h4 id="登录注销"><a href="#登录注销" class="headerlink" title="登录注销"></a>登录注销</h4><p>su - 用户名，logout 注销用户登录（运行级别3下有效）</p><h4 id="关机重启"><a href="#关机重启" class="headerlink" title="关机重启"></a>关机重启</h4><p>shutdown -h now 立刻关机<br>shutdown -h   1  1分钟后关机，默认一分钟<br>shutdown  -r  now  现在重启<br>shutdown -c 取消关机，取消重启<br>halt关机<br>reboot重启<br>sync同步内存数据</p><h4 id="Vim编辑器快捷键"><a href="#Vim编辑器快捷键" class="headerlink" title="Vim编辑器快捷键"></a>Vim编辑器快捷键</h4><p>拷贝当前行 ：yy<br>粘贴：p<br>删除当前行: dd，删除以下5行：5dd<br>查找某个单词：命令行下&#x2F;关键词，回车，n查找下一个。<br>设置文件行号：命令行set nu<br>撤销：一般模式下，u<br>移动到20行：一般模式下，输入20,然后shift+g<br>移动到最末行最首行：一般模式下G， gg</p><h4 id="文件目录类"><a href="#文件目录类" class="headerlink" title="文件目录类"></a>文件目录类</h4><p>ls :显示当前目录下的文件，-a 所有文件,-l 列表展示信息,-h 方便浏览<br>cat xxx:安全打开，只读<br>vi xxx:用vim编辑器打开文件<br>more: 分页打开<br>less： 打开大文件<br>head -n  11 xx  打开文件开头11行，默认10行<br>tail -n 11  xxx  打开文件末尾11行 </p><p><code>tail -f xxx实时监控文件</code></p><p>history: 命令执行记录<br><code>history 10</code>最近执行的10条指令<br><code>!488</code>执行第488条指令</p><p>rm: 删除文件 -f 强制删除, -r逐层递归删除文件<br>cp: 复制文件或覆盖，-r递归复制整个文件夹 ，&#x2F;cp强制覆盖<br>mv: 移动文件、重命名<br>touch：创建空文件<br>mkdir:创建文件夹<br>rmdir:删除文件夹<br>ln: 符号连接，软连接<br><code>ln -s /root/ myroot </code>  </p><h4 id="打包、解包、压缩和解压指令"><a href="#打包、解包、压缩和解压指令" class="headerlink" title="打包、解包、压缩和解压指令"></a>打包、解包、压缩和解压指令</h4><p>Linux 主要有3种压缩方式，zip，gzip，xz是压缩解压指令。<br>gzip：压缩速度最快，应用广泛<br>bzip2：压缩成的文件小<br>xz：最新的方式，提供最佳的压缩率</p><p>tar是打包指令：</p><p>-c，进行打包<br>-v，显示详细信息<br>-f，指定压缩或解压的文件包<br>-z，支持gzip压缩和解压，-j支持bzip压缩，-J支持xz压缩<br>-x，解包文件<br>-t，显示文件的内容<br>-k，保留原有文件不覆盖<br>-C，切换到指定目录</p><p>案例1：压缩多个文件</p><p>tar -zcvf  pc.tar.gz  &#x2F;home&#x2F;pig.txt  &#x2F;home&#x2F;cat.txt  </p><p>案例2：将&#x2F;home文件夹压缩</p><p>tar  -zcvf  myhome.tar,gz  &#x2F;home&#x2F;</p><p>案例3：将myhome.tar.gz解压到当前目录</p><p>tar -zxvf myhome.tar.gz</p><p>案例4：将myhome.tar.gz解压到&#x2F;opt&#x2F;tmp2下</p><p>mkdir  &#x2F;opt&#x2F;tmp2<br>tar  -zxvf  &#x2F;home&#x2F;myhome.tar.gz  -C  &#x2F;opt&#x2F;tmp2</p><p>1、tar<br>打包：tar cvf   xxx.tar  xxx文件<br>解包：tar xvf   xxx.tar</p><p>2、.gz<br>压缩：gzip  xxx<br>解压：gunzip xxx.gz</p><p>3、.tar.gz 和 .tgz<br>压缩：tar zcvf xxx.tar.gz  xxxx<br>解压：tar zxvf xxx.tar.gz</p><p>4、.tar.bz2<br>压缩：tar jcvf xxx.tar.bz2  xxx<br>解缩：tar jxvf xxx.tar.bz2 </p><p>5、.zip<br>压缩：zip   xxx.zip  xxx<br>解压：unzip xxx.zip</p><p>例：<br>zip  -r  myhome.zip  &#x2F;home&#x2F;把home文件夹及子文件压缩<br>unzip  -d  &#x2F;opt&#x2F;tmp   myhome.zip  把myhome.zip解压到&#x2F;opt&#x2F;tmp</p><p>6、.rar<br>压缩：rar a xxx.rar xxx<br>解压：rar   x xxx.rar</p><p>7、.bz2<br>压缩： bzip2 -z xxxx<br>解压1：bzip2 -d &#x2F;xxx  xxx.bz2<br>解压2：bunzip2 xxx.bz2</p><h4 id="输出重定向-和追加-指令"><a href="#输出重定向-和追加-指令" class="headerlink" title="输出重定向&gt;和追加&gt;&gt;指令"></a>输出重定向<code>&gt;</code>和追加<code>&gt;&gt;</code>指令</h4><p>ls -l &gt; info.txt<br>cat 文件1&gt; 文件2<br>echo “xxx”&gt;文件</p><p><code>echo $PATH $HOSTNAME</code></p><h4 id="时间日期类"><a href="#时间日期类" class="headerlink" title="时间日期类"></a>时间日期类</h4><p>date: 打印当前时间</p><p><code>date &quot;+%Y-%m-%D&quot;</code>打印年月日<br><code>date set &quot;+%Y-%m-%D %H:%M:%S&quot;</code></p><p>cal :打印当前日历</p><p><code>cal 2023</code>打印2023年日历</p><h4 id="搜索查找类"><a href="#搜索查找类" class="headerlink" title="搜索查找类"></a>搜索查找类</h4><p>find :-name  ；-user； -size</p><p><code>find /home -name hello.txt -user root找到/home目录下用户名为root的hello.txt文件</code><br><code>find /  -size +200M  在根目录下找大于200M的文件</code></p><p>locate: 无需遍历整个系统，查询快</p><p><code>updatedb</code><br><code>locate hello.txt 定位hello.txt所在的目录</code></p><p>grep: 过滤查找</p><p><code>cat hello.txt | grep -n &quot;hello&quot;  </code>   打开hello.txt并查找hello所在行</p><p>案例1：在&#x2F;home目录下查找所有内容含cat的文件名</p><p><code>grep -r &quot;cat&quot; /home | cut -d &quot;:&quot; -f 1 </code></p><p>案例2：请统计&#x2F;home目录下所有文件个数及文件的总行数</p><p><code>find -r /home -name &quot;*.*&quot; | wc -l</code></p><p><code>find -r /home -name &quot;*.*&quot; |xargs wc -l</code></p><h4 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h4><p>添加用户：useradd xxx<br>删除用户：userdel xxx<br>修改用户所在组：usermod -g 新组名 user<br>修改用户登录目录：usermod -d 目录 user<br>查看用户是否存在：id user<br>查看当前用户：whoami</p><h4 id="文件所有者所在组"><a href="#文件所有者所在组" class="headerlink" title="文件所有者所在组"></a>文件所有者所在组</h4><p>添加&#x2F;删除组：groupadd&#x2F;groupdel<br>查看了文件的所有者：ls -ahl  xxx<br>改变文件的所有者：chown  新用户  文件名&#x2F;目录<br>改变文件所在组：chgrp  新组名 文件名&#x2F;目录<br>改变文件目录所有者所在组：chown  newowner:newgroup</p><p><strong>加上参数-R将目录下所有文件都会改变</strong> </p><h4 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h4><p><code>-rw-r--r--. 1 root root  239 10月 24 10:13 hello.java</code> （1）<br><code>drwxr-xr-x. 2 root root 4096 10月 23 13:56 桌面</code>               （2）<br> r:读 w:写 x:执行    [4,2,1]  r+w+x&#x3D;7</p><p><code>0~9位：</code></p><p>1）<code>0位：文件类型，-文件，d目录，c字符设备(键盘鼠标)，b块设备(硬盘)</code><br>2）<code>1~3位：所有者权限</code><br>3）<code>4~6：所在组权限</code><br>4）<code>7~9：其他组权限</code></p><p>[rwx]作用于文件<br>r:只读cat； w:写修改但不能删除 ；x:可执行<br>[rwx]作用于目录<br>r: 查看目录内容ls，但对文件有独立的权限;  w：可在目录内创建、删除文件 ; x：可进入目录cd</p><p>注（1）中数字1表示文件数或子目录数，第一个root为用户，第二个为用户组，239为文件大小单位字节，“10月 24 10:13”为最后修改日期。</p><h4 id="变更权限"><a href="#变更权限" class="headerlink" title="变更权限"></a>变更权限</h4><p>chmod修改文件目录的权限, u所有者，g所在组，o其他组，a所有人<br>(1)+ ，-， &#x3D;<br>chmod  u&#x3D;rwx,g&#x3D;rx,o&#x3D;x   文件名&#x2F;目录 ：给用户rwx，所在组rx，其他组x<br>chmod  o+x  文件名&#x2F;目录  ：给其他组执行权限<br>chmod   a-x   文件名&#x2F;目录  ：所有人剥夺执行权限</p><p>(2)通过数字变更</p><p>r：4 w：2 x：1  </p><p>rwx&#x3D;7，rw：6，rx:5，r：4，wx：3，w：2，x：1  无权限：0</p><p><code>chmod  u=rwx,g=rx,o=x  文件名/目录</code>相当于<code>chmod 751 文件名/目录</code></p><h4 id="crond任务时间调度"><a href="#crond任务时间调度" class="headerlink" title="crond任务时间调度"></a>crond任务时间调度</h4><p>设置任务调度文件：&#x2F;etc&#x2F;crontab</p><p>设置个人调度任务：执行crontab -e指令，接着输入任务到调度文件。如：</p><p> <code>*/1 * * * * ls -l /etc &gt; /tmp/to.txt</code> </p><p>每小时每分钟执行<code>ls -l /etc &gt; /tmp/to.txt</code> </p><p>五个占位符参数：</p><p>第一个*：一小时中第几分钟，0~59</p><p>第二个*：一天中第几小时，0~23</p><p>第三个*：一个月中第几天，1~31</p><p>第四个*：一年中第几个月，1~12</p><p>第五个*：一周中星期几，0~7（0,7为星期日）</p><p>crond相关指令：</p><p><code>-r</code>终止任务调度（删除），<code>-e</code>编辑任务，<code>-l</code>列出任务</p><p><code>service crond restart</code>重启crond调度</p><p>特殊符号说明：</p><p><code>*</code> ：任何时间，若第一个为*表示每分钟执行。</p><p><code>,</code>：逗号代表不连续的时间，<code>0 8,12,16 * * *</code>表示每天8点12点16点0分执行。</p><p><code>-</code>：表示连续时间范围，<code> 0 5 ** 1-6</code>周一到周六凌晨五点执行。</p><p><code>*/n</code>：表示每隔多久执行，<code>*/10 </code>表示每隔10分钟执行。</p><p>案例1：<br><u>每隔一分钟将当前时间和日期追加到&#x2F;home&#x2F;mycal中</u><br>1）vim my.sh写入<code>date &gt;&gt; /home/mycal和cal &gt;&gt; /home/mycal</code><br>2)   给my.sh增加执行权限，<code>chmod u+x my.sh</code><br>3)  crontab -e写入任务<code>*/1 * * * *  /home/my.sh</code></p><p>案例2：<br><u>每天凌晨2点备份数据库mydb</u><br>1）crontab -e<br>2）0 2 * * *  mysqldump -u root -p 123456  mydb &gt; &#x2F;home&#x2F;db.bak</p><h4 id="at定时任务"><a href="#at定时任务" class="headerlink" title="at定时任务"></a>at定时任务</h4><p>at命令是一次性定时任务，at的守护进程atd检查作业队列，以后台模式运行，每60秒检查一次，若时间与当前时间匹配则运行。使用at要保证atd在运行，使用以下命令查看进程：</p><p><code>ps -ef | grep atd</code></p><p>at [选项] [时间]</p><p>atq查询任务，atrm删除<br>Ctrl+D结束命令输入</p><p>at时间格式：<br>1）hh:mm(04:00)当天或第二天执行<br>2）midnight&#x2F;noon&#x2F;teatime<br>3）12小时制，如9am ,3pm<br>4）指定具体日期：month day或mm&#x2F;dd&#x2F;yy或dd.mm.yy，指定日期必须在时间后面04:00 2023-11-1<br>5）相对计时：<code>now  + count time-units</code>，now是当前时间，count是数量，tim-units是时间单位，minutes,hours,days,months,weeks。</p><p><code>now + 5 days</code>五天后<br><code>5pm + 2 days</code>两天后下午五点</p><p>6）today、tommorow</p><p>案例1：<br>每天下午5点，把时间输入到&#x2F;root&#x2F;data.log里</p><ol><li><code>at 5pm tommorow</code></li><li><code>date  &gt; /root/data.log</code></li></ol><p>案例2：<br>2天后五点执行&#x2F;bin&#x2F;ls &#x2F;home<br>1)<code>at 5pm + 2 days</code><br>2)<code>/bin/ls /home</code></p><p>案例3：<br>删除5号at任务<br><code>atrm 5</code></p><h4 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h4><p>磁盘分区和文件系统之间通过挂载mount联系起来，分区构成整个文件系统。</p><p>查看设备挂载情况：<code>lsblk  -f</code></p><p>Linux硬盘分为IDE和SCSI类型，目前主要为SCSI。</p><p>对于IDE硬盘，驱动器标识符为<code>hdx~</code>，hd表示IDE设备类型，x表示盘号(a主盘，b从属盘,c…)，<code>~</code>表示分区，前四个分区用1-4数字表示，5开始为逻辑分区。如hda2表示第一个IDE硬盘的第二个分区。</p><p>对于SCSI&#x2F;SATA硬盘，标识为“sdx~”，sd为SCSI硬盘类型，其余和IDE表示类似。</p><p>对于NVMe硬盘，以nvme0n开头，nvme0n1p1是第一块硬盘的第一个分区，而nvme0n2p3则是第二块硬盘的第三个分区。</p><p><u>案例：挂载一块硬盘</u></p><p>1.虚拟机添加硬盘</p><p>在虚拟机设置中在设备列表里添加一块硬盘，完成后重启才能识别。</p><p>2.分区</p><p><code>fdisk /dev/sdb</code></p><p>m 显示命令列表<br>p 显示磁盘分区，fdisk -l<br>n 新增分区<br>d 删除分区<br>w写入并退出<br>q 直接退出</p><p>3.格式化</p><p>格式化文件系统获得UUID：<code>mkfs -t ext4 /dev/sdb1</code></p><p>4.挂载</p><p>将分区和文件目录联系起来：mount 设备名 文件目录</p><p><code>mount /dev/sdb1  /newdisk</code></p><p>umount 设备名或挂载目录(mountpoint)</p><p><code>umount  /dev/sdb1</code>或<code>umount /newdisk</code></p><p>但是重启后失效</p><p>5.设置自动挂载</p><p>实现永久挂载，修改&#x2F;etc&#x2F;fstab文件，添加设备，重启或执行mount -a立刻生效。</p><p><code>/dev/sdb1              /newdisk                    0.0</code></p><h4 id="磁盘情况查询"><a href="#磁盘情况查询" class="headerlink" title="磁盘情况查询"></a>磁盘情况查询</h4><p>1）查看磁盘整体使用情况 ：<code>df -h</code></p><p>2）查询指定目录的磁盘占用情况</p><p><code>du -h</code> 默认当前目录</p><p>-s  占用大小汇总<br>-h 带计量单位<br>-a 带上文件<br>–max-depth&#x3D;1子目录深度<br>-c 列出明细，增加汇总值</p><p>案例1：查询&#x2F;opt目录下一层子目录的磁盘使用情况</p><p><code>du -h --max-depth=1 /opt</code></p><p>3）查看内存使用情况：<code>free -h</code></p><ol start="4"><li>查看系统负载命令：<code>uptime</code><br>-p，显示系统运行时间，-s，显示系统启动时间</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">15:32:56 up  6:59,  2 users,  load average: 0.04, 0.03, 0.05</span><br><span class="line">15:32:56当前时间，up运行时间，2个用户，过去1、5、15分钟负载</span><br></pre></td></tr></table></figure><p>5）虚拟内存状态、io状态<br>vmstat\iostat</p><h4 id="工作实用指令"><a href="#工作实用指令" class="headerlink" title="工作实用指令"></a>工作实用指令</h4><p>1）统计&#x2F;opt文件夹下文件的个数</p><p><code>ls -l /opt | grep &quot;^-&quot; | wc -l</code> </p><p>2）统计&#x2F;opt文件夹下目录的个数</p><p><code>ls -l /opt | grep &quot;^d&quot; | wc -l</code></p><p>3）统计&#x2F;opt文件夹下文件的个数，包括子文件夹下的文件</p><p><code>ls -lR /opt | grep &quot;^-&quot; | wc -l</code> </p><p>4）统计&#x2F;opt文件夹下目录的个数，包括子文件夹下</p><p><code>ls -lR /opt | grep &quot;^d&quot; | wc -l</code> </p><p>5）树状显示目录结构</p><p><code>yum install tree</code><br><code>tree /opt</code></p><h4 id="Linux网络配置"><a href="#Linux网络配置" class="headerlink" title="Linux网络配置"></a>Linux网络配置</h4><p>查看网络配置：ifconfig或ip addr<br>测试网络连通：ping ip地址</p><p>1）DHCP动态路由分配</p><p>自动分配，ip不会冲突，但是不固定。</p><p>2）静态分配IP(固定IP)</p><p>修改网卡配置文件，<code>vi /etc/sysconfig/network-scripts/ifcfg-ens33</code>，将ip地址配置成静态的，添加固定ip如下。</p><p>DEVICE&#x3D;ens33 (设备网卡名)<br>HWADDR&#x3D;00:0c:2x:6x:0x:xx  (MAC地址)<br>TYPE&#x3D;ethernet  (网络类型)<br>UUID&#x3D;029ad-d12e-dw23-32da-1d2c (随机id)<br>ONBOOT&#x3D; yes  (系统启动时网络接口是否开启)<br>BOOTPROTO&#x3D;static  (ip配置方法)[none;static;dhcp;bootp]<br>IPADDR&#x3D;192.168.157.129 (ip地址)<br>GATEWAY&#x3D;192.168.157.2  (网关)<br>DNS1&#x3D;192.168.157.2   (DNS解析器)</p><p>在虚拟机中找到虚拟网络编辑器，找到该网络如vmnet8，修改子网ip地址为192.168.157.0，修改NAT配置中网关地址，点击确定再点击应用。之后重启系统或者输入<code>service network restart</code>生效。</p><h4 id="设置主机名和HOST映射"><a href="#设置主机名和HOST映射" class="headerlink" title="设置主机名和HOST映射"></a>设置主机名和HOST映射</h4><p>查看主机名：hostname<br>修改主机名：<code>vi /etc/hostname</code>，重启</p><p>设置HOST映射：</p><p>1）在windows的”C:\Windows\System32\drivers\etc\hosts”下添加ip与主机名的映射：192.168.157.129    CentOS7</p><p>ping CentOS7可ping通。<br>windows cmd窗口<code>ipconfig /displaydns</code>列出本地dns缓存，<code>ipconfig /flushdns</code>清除缓存。</p><p>2）linux在&#x2F;etc&#x2F;hosts文件修改</p><h4 id="监控网络状态"><a href="#监控网络状态" class="headerlink" title="监控网络状态"></a>监控网络状态</h4><p>netstat  [options]，选项说明：</p><p>-an，按一定顺序输出  ；-p，显示哪个进程在调用</p><p>例如：查看sshd服务的信息</p><p><code>netstat -anp |grep sshd</code></p><p>ping  ip，监测网络连接。</p><p>案例：统计连接到服务器的各个ip情况，并按连接数从大到小排</p><p><code>netstat -an | grep ESTABLISHED | awk  -F  &quot; &quot;   &#39;&#123;print $5&#125;&#39;  | cut  -d  &quot;:&quot;  -f  1 | sort |uniq -c | sort -nr</code> </p><p>案例：使用tcpdump监听本机来自192.168.300.1，端口为22的通信，并保存到tcpdump.log</p><p><code>tcpdump -i ens33 host 192.168.300.1 and port 22 &gt;&gt; /opt/tcpdump.log</code></p><h4 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h4><p>1、查看进程信息</p><p>ps指令：</p><p>ps -A 显示当前所有进程信息<br>ps -a 显示所有终端机下执行的程序<br>ps -u 以用户的格式显示进程信息<br>ps  -x 显示后台进程运行的参数<br>ps -aux | grep sshd 查看也没有sshd服务</p><p>USER进程执行用户，PID进程号，%CPU进程占CPU百分比，%MEM进程占物理内存的百分比，VSZ进程占虚拟内存的大小，RSS进程占物理内存的大小KB，TTY终端名称，STAT进程状态(S睡眠，R正在运行，Z僵尸进程，D短期等待，T被跟踪或被停止，&gt;高优先级)，START进程开始执行时间，TIME占用CPU时间，COMMAND启动进程的命令或参数。</p><p>ps -ef 以全格式显示所以进程，不会截断，System V格式。</p><p><code>ps -ef | grep sshd</code></p><p>UID用户ID，PID进程号，PPID父进程PID，TTY终端设备号。</p><p>&#x2F;&#x2F;查找进程状态信息<br>cat &#x2F;proc&#x2F;pid&#x2F;status<br>&#x2F;&#x2F;查找进程启动命令行<br>cat &#x2F;proc&#x2F;pid&#x2F;cmdline</p><p>2、终止进程</p><p>kill  [option]  PID  ，终止进程，option&#x3D;-9表示强制终止。<br>killall 进程名  ，终止该进程及子进程。</p><p><u>案例1：踢掉某个非法登录用户tom</u><br>root       1143      1  0 16:23 ?        00:00:00 &#x2F;usr&#x2F;sbin&#x2F;sshd -D<br>root       1741   1143  0 16:23 ?        00:00:00 sshd: root@pts&#x2F;0<br>root       5031   1143  1 20:03 ?        00:00:00 sshd: tom [priv]<br>tom        5043   5031  0 20:03 ?        00:00:00 sshd: tom@pts&#x2F;1</p><p><code>kill  5031</code></p><p>案例2：终止远程登录服务器sshd，合适时重启服务</p><p><code>kill 1143</code><br><code>/bin/systemctl start sshd.service</code></p><p>案例3：终止多个gedit</p><p><code>killall gedit</code></p><p>案例4：强制杀死终端</p><p>root       5277   5267  0 20:16 pts&#x2F;1    00:00:00 bash</p><p><code>kill -9 5277</code></p><p>3、查看进程树</p><p>pstree ，-p 显示进程号，-u显示用户</p><p>4、<u>top动态监控进程（性能监视器，任务管理器）</u></p><p>top: 实时显示进程信息<br>top -d 秒数，几秒后刷新<br>top -i，不显示闲置和僵尸进程<br>top -p PID，指定某进程ID监控进程</p><p>top交互操作说明，输入：</p><p>P，以CPU使用率排序，默认<br>N，以PID排序<br>M，以内存使用率排序<br>q，退出<br>u，接着输入用户名，回车即可查看某用户相关进程<br>k，接着输入进程号，回车即可终止某进程</p><p>案例1：监控用户tom的相关进程</p><p>top，输入u，接着输入tom</p><p>案例2：终止指定进程，踢掉tom</p><p>PID   USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM   TIME+ COMMAND<br>2060  tom       20   0    160988   2372   1028 S   0.0    0.1     0:00.01     sshd<br>2064  tom       20   0    116876   3296   1676 S   0.0     0.2    0:00.04    bash </p><p>top，输入u回车，输入tom回车，输入k回车，输入2064回车。</p><h4 id="Service服务管理"><a href="#Service服务管理" class="headerlink" title="Service服务管理"></a>Service服务管理</h4><p>查看系统服务：</p><p>1）setup，系统服务。<br>2）service指令管理服务在&#x2F;etc&#x2F;init.d查看，<code>ls -l /etc/init.d/</code></p><p><u>service指令：</u></p><p>service  服务名  [start|stop|restart|reload|status]</p><p>CentOS7以后，大多服务不使用service，而使用systemctl。<br>[使用service关闭network服务，一旦关闭，将无法连接SSH服务]</p><p>服务运行级别，在&#x2F;etc&#x2F;initab查看，<code>systemctl get-default</code>查看当前运行级别，<code>systemctl set-default T.target</code>设置默认级别。</p><p><u>chkconfig指令：</u></p><p>查看服务：chkconfig –list<br>设置服务在level级别开启：<code>chkconfig  --level  [0/1/2/3/4/5/6]  服务名  on/off</code></p><p>如设置network在3级别打开或关闭：<code>chkconfig --level 3 network on/off</code>，之后重启系统即可生效。</p><p><u>systemctl指令：</u></p><p>systemctl   [start |stop |restart |status |enable |disable]  服务名</p><p>该指令管理的服务在&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system查看。</p><p>systemctl  list-unit-files，查看服务开机启动状态<br>systemctl  enable  服务名 ，设置服务开机启动<br>systemctl  disable  服务名，关闭服务自启动<br>systemctl   is-enabled  服务名 ，查看某个服务是否自启动</p><p>案例1：查看当前防火墙状态，关闭和打开防火墙服务</p><p><code>systemctl  list-unit-files  | grep  firewalld</code>  或<br><code>systemctl is-enabled firewalld</code>  或<br><code>systemctl  status firewalld</code><br><code>systemctl  stop firewalld</code><br><code>systemctl  start firewalld</code></p><p>【systemctl start&#x2F;stop 服务，服务在系统重启后恢复原样】</p><p>案例2：防火墙打开和关闭指定端口111</p><p>打开打开：<code>firewall-cmd --permanent  --add-port=端口/协议</code><br>关闭打开：<code>firewall-cmd  --permanent  --remove-port=端口/协议</code><br>重载生效：<code>firewall-cmd  --reload</code><br>查询端口是否开放：<code>firewall-cmd  --query-port=端口/协议</code><br>查看那些已添加端口：<code>firewall-cmd --list-port</code></p><p><code>firewall-cmd --permanent  --add-port=111/tcp</code><br><code>firewall-cmd --reload</code></p><h4 id="RPM和YUM"><a href="#RPM和YUM" class="headerlink" title="RPM和YUM"></a>RPM和YUM</h4><p>rpm</p><p>rpm是linux常用的下载和打包安装工具，生成.rpm结尾的文件。</p><p>软件包名基本格式：firefox-68.10.0-1.el7.centos.x86_64，名称：firefox，版本：68.10.0，适用操作系统：el7.centos.x86_64，norach表示32位64位通用。<br>1）查询<br>查询已安装的rpm包列表：rpm -qa | grep xxx<br>查询所有rpm包：rpm -qa<br>查询软件包是否安装：rpm  -q  软件包名<br>查询软件包信息：rpm -qi  软件包名<br>查询软件包中的安装文件：rpm -ql  软件包名<br>查询文件所属软件包：rpm -qf  文件全路径<br>例：rpm -qf &#x2F;etc&#x2F;passwd<br>2）安装<br>安装软件包：rpm  -ivh   软件包全路径，-i安装，-h显示进度，-v显示安装信息<br>例：rpm -ivh &#x2F;opt&#x2F;firefox-68.10.0-1.el7.centos.x86_64<br>3）卸载<br>卸载安装包：rpm  -e  xx软件包名 [erase]<br>强制卸载：rpm -e –nodeps  xxx</p><p>yum</p><p>yum是一个Shell前端软件包管理器，基于rpm，能够从服务器中下载rpm包并安装，可以自动处理依赖关系，并一次性安装所以依赖，但需要连接网络。</p><p>-y:代替手动输入yes，自动执行安装<br>查询服务器是否有可安装的xx软件：yum  list | grep xxx<br>查看可更新的软件：yum list updates<br>查看已安装的软件：yum list installed<br>安装包：yum install   xxx<br>删除软件：yum remove  xxx<br>更新所以软件：yum update<br>更新一个软件：yum update xxx<br>检查更新的包：yum check-update<br>清除缓存目录下的软件包：yum clean all<br>更新软件包缓存：yum makecache<br>搜寻软件包：yum  search  xxx<br>查看软件包信息：yum info xxx<br>设置镜像的仓库：<br><code>yum config-manager  --add-repo  http://mirrors.aliyun.com/repo/Centos-7.repo</code></p><p>影响yum使用的主要文件:<br>基本设置： &#x2F;etc&#x2F;yum.conf<br>仓库软件源集： &#x2F;etc&#x2F;yum.repo.d&#x2F;*.repo<br>日志文件： &#x2F;var&#x2F;log&#x2F;yum.log</p><p>*.repo的基本配置项：App-Stream BaseOS Extras<br>[base]：名称，可以随意取<br>name：描述repo含义<br>baseurl：后面接地址，是指定一个固定地址<br>enabled:是否启用此频道（1为启动，0为不启用）<br>gpgcheck：是否需要查阅RPM文件内数字证书<br>gpgkey：数字证书公钥文件所在位置，使用默认值</p><p>开启软件缓存 nano  &#x2F;etc&#x2F;yum.conf</p><p>案例：使用yum安装firefox<br>rpm -e firefox<br>yum list | grep firefox<br>yum install  firefox</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在学习linux的过程中，有一些指令经常使用，下面是学习笔记。</summary>
    
    
    
    <category term="linux" scheme="https://aachou.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Shell编程</title>
    <link href="https://aachou.github.io/2023/1111/"/>
    <id>https://aachou.github.io/2023/1111/</id>
    <published>2023-11-11T04:58:45.000Z</published>
    <updated>2024-01-15T03:08:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>Shell是一个命令解释器，它提供一个向内核发送请求的界面系统级程序。<span id="more"></span></p><h5 id="1、shell入门"><a href="#1、shell入门" class="headerlink" title="1、shell入门"></a>1、shell入门</h5><p>脚本格式要求：以#!&#x2F;bin&#x2F;bash开头，脚本要有可执行权限。</p><p>编写一个shell脚本：</p><p>vim  hello.sh<br><code>#!/bin/bash</code><br><code>echo &quot;hello java~&quot;</code></p><p>脚本执行方式：</p><p>1）输入脚本的绝对或相对路径，前提要有执行权限</p><p>.&#x2F;hello.sh</p><p>2）sh +脚本，没有权限也能执行</p><p>sh  .&#x2F;hello.sh</p><h5 id="2、变量"><a href="#2、变量" class="headerlink" title="2、变量"></a>2、变量</h5><p>shell变量分为系统变量和自定义变量，变量名称可以由字母、数字、下划线组成，字母一般大写。</p><p>系统变量：<code>$PATH $HOME $PWD $USER $SHELL</code><br>显示当前所有变量：set<br>定义变量：变量名&#x3D;值（等号不要空格）<br>撤销变量：unset 变量<br>声明静态变量：readonly  变量（不可以unset）</p><p><code>#!/bin/bash</code><br><code>A=10</code><br><code>echo &quot;A=$A&quot;</code></p><p>将命令的返回值赋值给变量：A&#x3D;`date`或A&#x3D;$(date)</p><p><u>设置环境变量:</u></p><p>export  变量名&#x3D;变量值  （将shell变量输出为环境变量\全局变量）<br>source  配置文件<br>echo  $变量名</p><p>案例：在&#x2F;etc&#x2F;profile中定义TOMCAT_HOME环境变量，查看环境变量的值，在另一个shell程序中使用<code>TOMCAT_HOME</code></p><p>在profile文件中写入：export TOMCAT_HOME&#x3D;&#x2F;opt&#x2F;tomcat<br>更新环境变量：source  &#x2F;etc&#x2F;profile</p><p><u>位置参数变量：</u></p><p>在执行脚本时可以传入相应的参数，如：.&#x2F;myshell.sh  100 200</p><p>基本语法：</p><p><code>$&#123;&#125;</code>：获取变量的值，{}可省略；<br><code>$n</code>：(n代表数字，<code>$0</code>为命令本身，<code>$1-9</code>代表第一到第九个参数，10以上用大括号<code>$&#123;10&#125;</code>)；<br><code>$@</code>：代表所有参数，但区分每个参数；<br><code>$#</code> ：命令行中参数个数；<br><code>$*</code> ：代表所有参数，所有参数看为一个整体</p><p><u>预定义变量：</u></p><p>$$:当前进程的进程号<br>$!：后台运行的最后一个进程的进程号<br>$?：最后一次执行命令的返回状态，0代表执行成功，非0失败</p><p><code>#!/bin/bash</code><br><code>echo   &quot;当前执行进程的id=$$&quot;</code></p><p>#以后台运行一个脚本，并获取它的进程号。</p><p>.&#x2F;myshell.sh 100 200  &amp;<br><code>echo  &quot;最后一个执行进程id=$!&quot;</code><br><code>echo  &quot;执行结果=$?&quot;</code></p><h5 id="3、shell注释"><a href="#3、shell注释" class="headerlink" title="3、shell注释"></a>3、shell注释</h5><p>单行注释：#<br>多行注释：</p><p>:&lt;&lt;!<br>内容<br>!</p><h5 id="4、运算符"><a href="#4、运算符" class="headerlink" title="4、运算符"></a>4、运算符</h5><p>（1）$$((运算式))</p><p>（2）$[运算式]</p><p>（3）expr表达式（运算符之间要有空格）</p><p>+、-、\*、&#x2F;、%加减乘除取余</p><p>expr   5 + 3<br><strong>注意空格</strong></p><p>案例1：计算(2+3)x4<br>第一种方式<br><code>res=$(((2+3)*4))</code><br>或第二种<br><code>res=$[(2+3)*4]</code><br>或expr<br>temp&#x3D;`expr  2 + 3`</p><p>res&#x3D;`$temp  \*  4`</p><p>echo  “$res” </p><h5 id="5、条件判断"><a href="#5、条件判断" class="headerlink" title="5、条件判断"></a>5、条件判断</h5><p>(1)if语句</p><p>单分支：</p><p>if [ 条件 ]<br>then<br>代码<br>fi</p><p>两个分支：</p><p>if [ 条件 ]<br>then<br>代码<br>else<br>代码<br>fi</p><p>多分支：</p><p>if [ 条件 ]<br>then<br>代码<br>elif [ 条件 ]<br>then<br>代码<br>else<br>代码<br>fi</p><p>(2)条件语句： [ 条件 ]  注意左右空格</p><p>例：</p><p>[ abc ]  返回true<br>[  ]  返回false<br>[ 条件 ]  &amp;&amp; echo ok ||  echo !ok  条件满足执行后面语句</p><p>判断条件：</p><p>1)&#x3D;字符串比较</p><p>2)整数比较</p><p>-lt 小于（&lt;）<br>-le 小于等于(&lt;&#x3D;)<br>-eq 等于（&#x3D;&#x3D;）<br>-gt  大于(&gt;)<br>-ge 大于等于(&gt;&#x3D;)<br>-ne 不等于(!&#x3D;)</p><p>3）按照文件权限判断</p><p>-r   有读权限<br>-w  有写权限<br>-x  有执行权限</p><p>4）按照文件类型判断</p><p>-f  文件存在&amp;普通文件<br>-e  文件存在<br>-d 文件存在&amp;为目录</p><p>案例：编写一个shell程序，输入一个数，大于大于60及格，小于不及格</p><p><code>#!/bin/bash</code><br><code>if [ $1  -ge  60 ]</code><br><code>then</code><br><code>echo &quot;及格&quot;</code><br><code>elif [ $1 -lt 60 ]</code><br><code>then</code><br><code>echo &quot;不及格&quot;</code><br><code>fi</code></p><h5 id="6、case语句"><a href="#6、case语句" class="headerlink" title="6、case语句"></a>6、case语句</h5><p>case expression in</p><pre><code>pattern1)    statement1    ;;pattern2)    statement2    ;;pattern3)    statement3    ;;#其他pattern情形*)    statement</code></pre><p>esac</p><p><u>pattern支持正则表达式</u>：</p><p>*  ：表示任意字符串。<br>[abc]：表示 a、b、c 三个字符中的任意一个。比如，[15ZH] 表示 1、5、Z、H 四个字符中的任意一个。<br>[m-n]：表示从 m 到 n 的任意一个字符。比如，[0-9] 表示任意一个数字，[0-9a-zA-Z] 表示字母或数字。<br>|：表示多重选择，类似逻辑运算中的或运算。比如，abc | xyz 表示匹配字符串 “abc” 或者 “xyz”。</p><p>expression 既可以是一个变量、一个数字、一个字符串，还可以是一个计算表达式，或者是命令的执行结果，只要能够得到 expression 的值就可以。pattern 可以是一个数字、一个字符串，甚至是一个简单的正则表达式。有时候相近的内容作为一个pattern时，这些内容以“|”隔开，比如 y|yes|YES)。如果 expression 和某个模式匹配成功，就会执行这模式后面对应的所有语句（该语句可以有一条，也可以有多条），直到遇见双分号;;才停止，然后整个 case 语句就执行完了，程序会跳出整个 case 语句，执行 esac 后面的其它语句。如果 expression 没有匹配到任何一个模式，那么就执行*)后面的语句，直到遇见双分号;;或者esac才结束。最后一个分支可以写;;，也可以不写。执行到 esac 都会结束整个 case in 语句。最后一个分支*)并不是什么语法规定，它只是一个正则表达式，*表示任意字符串。</p><p>case  $1  in<br>    1)<br>       echo “星期一”<br>        ;;<br>    2)<br>        echo “星期二”<br>        ;;<br>    3)<br>        echo “星期三”<br>        ;;<br>    #其他pattern情形<br>    *)<br>        echo “others”<br>esac</p><h5 id="7、循环"><a href="#7、循环" class="headerlink" title="7、循环"></a>7、循环</h5><h6 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h6><p>案例一：编写一个num.sh，将输入的数字参数输出</p><p><code>#!/bin/bash</code><br><code>for  i   in   &quot;$@&quot;</code><br><code>do</code><br><code>echo  &quot;n  is $i&quot;</code><br><code>done</code></p><p>案例二：编写一个sum.sh对1到100求和输出结果</p><p><code>#!/bin/bash</code><br><code>SUM=0</code><br><code>for(( i=1;i&lt;=100;i++ ))</code><br><code>do</code><br>​<code>$SUM=$[$SUM+Si]</code><br><code>done</code><br><code>echo  $SUM</code></p><h6 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h6><p>while  [ 条件 ]<br>do<br>代码<br>done</p><p>案例：从命令行输入一个参数n，计算1+2+…+n</p><p>#!&#x2F;bin&#x2F;bash<br><code>SUM=0</code><br><code>i=1</code><br><code>while  [ $i  -le  $1 ]</code><br><code>do</code><br>​<code>SUM=$[ $SUM+$i ]</code><br>​<code>i=$[ $i+1 ]</code><br><code>done</code><br><code>echo  $SUM</code></p><h5 id="8、read读取输入"><a href="#8、read读取输入" class="headerlink" title="8、read读取输入"></a>8、read读取输入</h5><p>-p  :  读取时的提示；-t：读取等待的秒数</p><p>案例：读取控制台输入的两个数输出</p><p><code>read  -p  &quot;请输入一个数=&quot;  NUM1</code><br><code>echo   $NUM1</code><br><code>read   -t  10  -p  &quot;请在10秒内输入一个数=&quot;  NUM2</code><br><code>echo   $NUM2</code></p><h5 id="9、函数"><a href="#9、函数" class="headerlink" title="9、函数"></a>9、函数</h5><p><u>系统函数basename\dirname</u><br>basename返回路径后的文件名，dirname返回文件所在文件夹绝对路径</p><p>案例1：取出&#x2F;home&#x2F;myhome&#x2F;a.txt的a.txt文件名</p><p><code>basename  /home/myhome/a.txt</code>  </p><p>案例2：取出&#x2F;home&#x2F;myhome&#x2F;a.txt的文件的绝对路径&#x2F;home&#x2F;myhome</p><p><code>dirname  /home/myhome/a.txt</code></p><p>自定义函数:<br>function  函数名(){</p><p>}</p><p>调用函数：函数名+参数值</p><p>案例：定义一个函数getSum()求出输入参数之和</p><p>#!&#x2F;bin&#x2F;bash<br><code>function  getSum()&#123;</code><br>​<code>SUM=$[$n1+$n2]</code><br>​<code>echo &quot;$SUM&quot;</code><br><code>&#125;</code><br><code>read -p  &quot;请输入一个数n1=&quot;   n1</code><br><code>read -p  &quot;请输入一个数n2=&quot;   n2</code><br><code>getSum   $n1  $n2</code></p><h5 id="10、备份数据库练习"><a href="#10、备份数据库练习" class="headerlink" title="10、备份数据库练习"></a>10、备份数据库练习</h5><p>在&#x2F;usr&#x2F;sbin下创建数据库备份脚本文件mysql_db_backup.sh</p><p>#!&#x2F;bin&#x2F;bash<br><code>BACKUP=/data/backup/db</code><br>#时间<br><code>DATETIME=$(date  +%Y-%m-%d_%H%M%S)</code><br><code>echo  $DATETIME</code><br>#主机<br><code>HOST=localhost</code><br>#用户<br><code>DB_USER=root</code><br>#密码<br><code>DB_PASS=root</code><br>#数据库名<br><code>DATABASE=MyDB</code><br>#创建备份目录<br><code>[ ! -d &quot;$&#123;BACKUP&#125;/$&#123;DATETIME&#125;&quot; ] &amp;&amp; mkdir -p  &quot;$&#123;BACKUP&#125;/$&#123;DATETIME&#125;&quot;</code><br>#备份<br><code>mysqldump  -u&#123;DB_USER&#125;  -p&#123;DB_PASS&#125;  --host=$&#123;HOST&#125;  -q -R  --datebases  $&#123;DATABASE&#125;  |  gzip &gt;  $&#123;BACKUP&#125;/$&#123;DATETIME&#125;/$DATETIME.sql.gz</code><br>#打包<br><code>cd  $&#123;BACKUP&#125;</code><br><code>tar -zcvf  $DATETIME.tar.gz  $&#123;DATETIME&#125;</code><br>#删除备份目录<br><code>rm -rf  $&#123;BACKUP&#125;/$&#123;DATETIME&#125;</code><br>#删除10天前备份数据<br><code>find  $&#123;BACKUP&#125; -atime 10+ -name &quot;\*.tar.gz&quot; -exec rm -rf &#123;&#125; \</code><br><code>echo  &quot;备份$DATABASE 成功~&quot;</code></p><p>每天2点半定时备份<br>crontab -e<br><code>30 2 * * *  /usr/sbin/mysql_db_backup.sh</code></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Shell是一个命令解释器，它提供一个向内核发送请求的界面系统级程序。</summary>
    
    
    
    <category term="linux" scheme="https://aachou.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux下进行JavaEE开发,安装JDK、Tomcat、MySQL</title>
    <link href="https://aachou.github.io/2023/1106/"/>
    <id>https://aachou.github.io/2023/1106/</id>
    <published>2023-11-06T09:38:47.000Z</published>
    <updated>2023-12-04T00:05:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>(1)安装JDK步骤：</p><p>1、创建目录mkdir   &#x2F;opt&#x2F;jdk</p><p>2、将jdk压缩包通过xftp6上传到该目录</p><p>3、cd  &#x2F;opt&#x2F;jdk</p><p>4、tar -zxvf  jdk-8u151-linux-x64.tar.gz</p><p>5、mkdir  &#x2F;usr&#x2F;local&#x2F;java<span id="more"></span></p><p>6、mv  &#x2F;opt&#x2F;jdk&#x2F;jdk1.8.0_151  &#x2F;usr&#x2F;local&#x2F;java</p><p>7、修改环境变量配置文件vim &#x2F;etc&#x2F;profile</p><p>8、<code>export  JAVA_HOME=/usr/local/java/jdk1.8.0_151</code></p><p>9、<code>export  PATH=$JAVA_HOME/bin:$PATH</code></p><p>10、更新环境变量source  &#x2F;etc&#x2F;profile </p><p>测试是否配置成功，编写hello.java输出hello java。  </p><p>(2)安装Tomcat步骤：</p><p>1、创建文件夹mkdir  &#x2F;opt&#x2F; tomcat</p><p>2、将apache-tomcat-8.5.95.tar.gz上传至该文件夹</p><p>（注意：不要下载src源码版或exe二进制版的包）</p><p>3、解压tar -zxvf apache-tomcat-8.5.95.tar.gz</p><p>4、进入解压目录&#x2F;bin，.&#x2F;startup.sh启动tomcat（用户要有执行权限）</p><p>5、防火墙开放8080端口</p><p><code>firewall-cmd  --permanent  --add-port=8080/tcp</code></p><p><code>firewall-cmd  --reload</code></p><p>(3)安装MySQL步骤</p><p>1、从Mysql官网或阿里云镜像网站<code>https://mirrors.aliyun.com/mysql</code>，下载MySQL的安装包mysql-5.7.38-1.el7.x86_64.rpm-bundle.tar</p><p>2、新建文件夹&#x2F;opt&#x2F;mysql</p><p>3、删除CentOS原有的Mariadb数据库，通过rpm -qa | grep maria查看</p><p>4、删除mariadb</p><p><code>rpm  -e  --nodeps  maria</code></p><p><code>rpm -e  --nodeps  mariadb-libs-5.5.68-1.el7.x86_64</code></p><p>5、通过xftp将下载好的mysql安装包传输到&#x2F;opt&#x2F;mysql下</p><p>6、解安装包mysql-5.7.37-1.el7.x86_64.rpm-bundle.tar，得到rpm包如下</p><p><code>tar -xvf  mysql-5.7.38-1.el7.x86_64.rpm-bundle.tar</code></p><p>mysql-community-client-5.7.38-1.el7.x86_64.rpm<br>mysql-community-common-5.7.38-1.el7.x86_64.rpm<br>mysql-community-devel-5.7.38-1.el7.x86_64.rpm<br>mysql-community-embedded-5.7.38-1.el7.x86_64.rpm<br>mysql-community-embedded-compat-5.7.38-1.el7.x86_64.rpm<br>mysql-community-embedded-devel-5.7.38-1.el7.x86_64.rpm<br>mysql-community-libs-5.7.38-1.el7.x86_64.rpm<br>mysql-community-libs-compat-5.7.38-1.el7.x86_64.rpm<br>mysql-community-server-5.7.38-1.el7.x86_64.rpm<br>mysql-community-test-5.7.38-1.el7.x86_64.rpm</p><p>7、开始安装对应rpm包</p><p>rpm -ivh  mysql-community-common-5.7.38-1.el7.x86_64.rpm<br>rpm -ivh  mysql-community-client-plugin-5.7.38-1.el7.x86_64.rpm<br>rpm -ivh  mysql-community-libs-5.7.38-1.el7.x86_64.rpm<br>rpm -ivh  mysql-community-client-5.7.38-1.el7.x86_64.rpm<br>rpm -ivh  mysql-community-server-5.7.38-1.el7.x86_64.rpm</p><p>8、运行mysql</p><p><code>systemctl start mysqld.service</code><br> (默认开机自启动)</p><p>9、查看当前mysql密码</p><p><code>grep &quot;password&quot; /var/log/mysqld.log</code></p><p>10、登录mysql修改密码</p><p>mysql  -u  root  -p  密码</p><p><code>set password  for  &#39;root&#39;@&#39;localhost&#39;=password(&quot;12345678&quot;);</code><br>或<br><code>update user set authentication_string=password(&quot;12345678&quot;) where user=&#39;root&#39;;</code><br>或<br><code>ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;12345678&#39;; </code></p><p>可设置密码策略：默认为1，要求长度，数字，字母大小写，特殊字符。</p><p>set global validate_password.policy&#x3D;0;</p><p>11、使密码生效，flush privileges;</p><p>12、Ctrl+Z退出</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;(1)安装JDK步骤：&lt;/p&gt;
&lt;p&gt;1、创建目录mkdir   &amp;#x2F;opt&amp;#x2F;jdk&lt;/p&gt;
&lt;p&gt;2、将jdk压缩包通过xftp6上传到该目录&lt;/p&gt;
&lt;p&gt;3、cd  &amp;#x2F;opt&amp;#x2F;jdk&lt;/p&gt;
&lt;p&gt;4、tar -zxvf  jdk-8u151-linux-x64.tar.gz&lt;/p&gt;
&lt;p&gt;5、mkdir  &amp;#x2F;usr&amp;#x2F;local&amp;#x2F;java</summary>
    
    
    
    <category term="linux" scheme="https://aachou.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>虚拟机IP突然消失的解决方法</title>
    <link href="https://aachou.github.io/2023/1102/"/>
    <id>https://aachou.github.io/2023/1102/</id>
    <published>2023-11-02T01:19:39.000Z</published>
    <updated>2023-12-01T19:43:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>基础方法如下：<br>如果这个文件 ifcfg-ens33已经将ONBOOT改为yes了，之前用的还好好的还有ip地址的但是现在没有了。<span id="more"></span></p><p>1.先重启网络服务</p><p><code>sudo service network restart</code><br>但是重启网络失败的话，那就执行下边命令。</p><p>出现问题<br>解决方式：禁用NetworkManager</p><p>2.执行下边这两条命令</p><p><code>systemctl stop NetworkManager</code><br><code>systemctl disable NetworkManager</code></p><p>3.执行完成之后重新启动网络服务。</p><p><code>sudo service network restart</code></p><p>然后重新启动网络服务就OK了</p><p>4.输入ip addr查看ip地址。<br>在使用VMware过程中，有时候出现ssh工具连接不上的情况，在VMware中使用ip addr或者ifconfig命令查看ip，发现ip已消失</p><p>若为kali系统，可以试试以下命令：<br><code>dhclient eth0</code><br>eth0为网卡名字，该操作为网卡自动分配ip。</p><p>解决办法二：<br>1、查看VMware的网络设置，网络适配器，将网络适配器设置为NAT模式<br>2、设置VMware的虚拟网络编辑器，设置NAT模式的网段。（点击虚拟网络编辑器”更改设置“。如果不点击这里，“还原默认设置”按钮将是灰色的）<br>3、点击虚拟网络编辑器“还原默认设置”。</p><p>解决办法三：<br>重启网卡：<br><code>service network restart</code><br>如果报错，则可以停止网络管理，<code>systemctl stop NetworkManager</code>。若为kali则重启网络服务为<code>service networking restart</code></p><p>解决办法四：<br>由于启动服务器时未加载网卡，导致IP地址初始化失败。修改网络初始化配置，设定网卡在系统启动时初始化。<br><code>cat /etc/sysconfig/network-scripts/ifcfg-ens33</code></p><p>进入目录：&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts</p><p>编辑文件：vi ifcfg-ens33，将ONBOOT&#x3D;no改为ONBOOT&#x3D;yes</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;基础方法如下：&lt;br&gt;如果这个文件 ifcfg-ens33已经将ONBOOT改为yes了，之前用的还好好的还有ip地址的但是现在没有了。</summary>
    
    
    
    <category term="虚拟机" scheme="https://aachou.github.io/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>linux找回root密码，CentOS7</title>
    <link href="https://aachou.github.io/2023/1027/"/>
    <id>https://aachou.github.io/2023/1027/</id>
    <published>2023-10-27T04:55:09.000Z</published>
    <updated>2023-10-27T04:59:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>linux找回密码需要进入单用户模式，linux运行级别有0~6，可以通过init切换。<span id="more"></span></p><p>0：关机</p><p>1：单用户模式</p><p>2：多用户状态无网络</p><p>3：多用户状态有网络muti-user.target</p><p>4：系统未使用保留用户</p><p>5：图形用户graphical.target</p><p>6：系统重启</p><p>进入单用户模式通过以下步骤找回密码：</p><p>1.进入系统，在开机界面按住’e’进入编辑界面</p><p>2.进入编辑界面，找到’Linux16’开头的行，在末尾输入: init&#x3D; &#x2F;bin&#x2F;sh</p><p>3.按住快捷键ctrl+x进入单用户模式</p><p>4.在光标闪烁的位置输入：mount -o  remount,rw &#x2F; ，完成后enter回车</p><p>5.在新的一行最后输入passwd回车，输入密码即可</p><p>6.接着输入touch  &#x2F;.autorelabel回车</p><p>7.然后输入exec  &#x2F;sbin&#x2F;init回车，等待系统完成重启</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;linux找回密码需要进入单用户模式，linux运行级别有0~6，可以通过init切换。</summary>
    
    
    
    <category term="linux" scheme="https://aachou.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>7月感悟</title>
    <link href="https://aachou.github.io/2023/0724/"/>
    <id>https://aachou.github.io/2023/0724/</id>
    <published>2023-07-24T13:43:40.000Z</published>
    <updated>2023-08-09T10:13:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>7月份马上了快结束了，我已经从大学的苦海中暂时脱离出来了，在快毕业的时候我已经写了一篇感悟，那时还在考研复试，现在什么都结束了，研也考上了，已经离开学校了。<span id="more"></span></p><p>在4月回到学校后，每天都是在宿舍休息，休息其实在放纵自己，虽然毕设还没弄完，但是知道已经完成的差不多了，就躺在床上玩手机。到了晚上一般都会买瓶饮料，开始了大吃大喝，不过想想这几年遭的罪，喝饮料也是一种慰藉。有时候想到正在进行的毕设，又会打开软件写代码。没有人真正担心毕设过不了，确实不用担心，因为大家都清楚学校啥样，无疑这几个月是大学最为轻松的时光。</p><p>于是在5月初劳动节的那几天，有几个哥们想出去玩，商量着该去哪里花他们的假期。和宿友模棱两半天，我们三个决定去青岛玩几天。这是我们几个第一次去海边，我江西的，他两河南的，三个内陆孩子对海的向往得到了实现。从山东的日照再到青岛，我们住在一个小县城的小宾馆里，毕竟一人430，条件就这样了。我们第二天去的青岛，我当时是坐大巴车去的，坐了好几个小时，车上几乎是跟我们差不多的大学生。我们估计都是第一次看海，海的美景确实很震撼很吸引人，特别是在青岛胶州湾大桥上，那被海所包围的场景让我记忆深刻。进入熙熙攘攘的市区，青岛这座城市慢慢的在我眼前晃动。不过这一天并不好受，早上6点起来就出发，一直到10点，下车了，还是在海边下的车，临近网红景点栈桥。没走几步就累了，放纵的后果很大程度上减缓了我对青岛探索的步伐，之后我们分别到小青岛、海底世界、第一海水浴场、八大关和中山公园游玩，走到中山公园已经下午6点了，中间午饭都是问题，于是我受不了在浴场旁边的面馆解决，本来还想吃一顿海鲜自助，不过中午已经人满为患。期间走路还被圆石头柱绊了一跤，走了个趔趄，顺口一句国粹，这是这趟旅行的一大不快之一。对我们来说，青岛非常大，逛也逛不完，景区非常多，到了中山公园就止步了，哥几个准备回去了，有些遗憾，确实一天也玩不了什么。</p><p>6月初该提交论文的初稿了，我毕设也做完了，心里没什么负担。期间我们进行了答辩，答辩就那样，基本去了就过了，老师也不会故意让学生延毕的。过了两个礼拜，学校就举行毕业典礼，我们拿到了双证就这样毕业了，三年疫情，连工作都不好找，人都傻了，但还是向前走吧，23届的毕业生简直不能再惨了。我们宿舍6个人，四个考研，只有我上岸了，没考上的都准备再战一年。其余两个，一个签了三方去工作了，另一个混毕业，回家准备混进公司。就这样，大学宿舍生活结束了，大家各自东西南北中。</p><p>7月下我收到了研究生学校的录取通知书，不过并不开心，因为我不喜欢学校的生活，压抑沉闷，最主要的是没钱，经济上的问题一直催促我要早点工作赚钱，我很焦虑。而且，作为学生身份，难免要面对各种目光，我想要站起来，做一次自己的思考和选择 ，有一个稳定的环境真正让我能够放松下来，我还想看看外面的世界呢！不能再荒废下去了！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;7月份马上了快结束了，我已经从大学的苦海中暂时脱离出来了，在快毕业的时候我已经写了一篇感悟，那时还在考研复试，现在什么都结束了，研也考上了，已经离开学校了。</summary>
    
    
    
    <category term="碎碎念" scheme="https://aachou.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
  </entry>
  
  <entry>
    <title>机器学习概念初步</title>
    <link href="https://aachou.github.io/2023/0314/"/>
    <id>https://aachou.github.io/2023/0314/</id>
    <published>2023-03-14T15:00:56.000Z</published>
    <updated>2023-08-09T10:13:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学关于机器学习的东西，感觉有点难消化，但还是坚持啃一啃，做一点笔记<span id="more"></span></p><p><strong>非显著式编程</strong>：让计算机自己总结事物的规律，通过已知的数据学习经验来获取算法最好性能指标的过程，来预测未知的样本。</p><p>打标签label：告诉机器数据是什么，对数据进行标记。</p><p>收益函数reward function：机器在特定环境下的行为所带来的收益。</p><p><strong>监督学习supervised learning</strong>：从所有带标签的数据训练集中推出一个功能规律的机器学习</p><p><strong>无监督学习unsupervised learning</strong>：从没有标签的的数据集中分析特征，推断出数据的关系的机器学习(聚类clustering；em算法expectation maximization；主成分分析法principle component analysis）</p><p><strong>半监督学习semi-supervised learning</strong>：从带有少量标签的数据样本中推出经验规律的学习。</p><p><strong>强化学习reinforement learning</strong>：计算机通过与环境的互动逐渐强化自己的行为模式</p><p>监督学习根据数据标签是否存在的分类，传统的监督学习：监督学习，无监督学习，半监督学习(支持向量机SVM，人工神经网络artificial neural network，深度神经网络deep neural network)。基于标签的固有属性，监督学习分为分类classification(标签是离散值)和回归regression(标签是连续值)，如识别某张人脸，人脸对比和预测股票，房价。</p><p>线性可分linear separable：一条直线可以分割两类数据集</p><p>线性不可分nonlinear separable：一条直线不可以区分两类数据集</p><p><strong>特征空间</strong>：n个特征组成的n维平面，在特征空间上距离接近的样本，他们属于同一个类别的概率会更高</p><p>简单的神经元MP模型，基于神经元的生理结构建立起单个神经元的数学模型，多个加权输入偏置求和，经过激活函数非线性变换。</p><p><strong>卷积神经网络convolution neural network</strong>：专门用来处理类似网络结构的数据的神经网络。卷积网格是指那些只至少在网络的一层中使用卷积计算来代替一般的矩阵计算的神经网络。卷积神经网络基本结构由输入层、卷积层、池化层、激活函数层和全连接层，输入层代表一张图片的像素矩阵；卷积层对图像和滤波矩阵filter做内积操作，每计算玩一个窗口(卷积核)，窗口平移直到计算完所有图像数据；池化层保留主要的特征同时减少参数(降维,效果类似PCA)和计算量,防止过拟合,提高模型泛化能力；激活函数进行非线性变换；全连接层则起到将学到的特征映射到样本标记空间。</p><p>depth深度：神经元个数，代表了滤波器的个数；stride步长：决定滑动多少步到边缘.</p><p>神经网络后向传播算法Background Propogation：核心是梯度下降法求局部极值。</p><p><strong>自编码器auto-encoder</strong>：是一种无监督领域的神经网络模型，它可以表征到输入数据的隐含特征，这称为编码，同时用学习到的新特征可以重构出原始输入数据，称之为解码。比主成分分析法更强一些，能表征非线性变换。自动编码器还可以用于特征降维，将学习到的新特征送入有监督学习模型中，所以可以作为特征提取器。在引入语音识别系统后，EA代替了隐含马尔科夫模型Morkov和高斯混合模型。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在学关于机器学习的东西，感觉有点难消化，但还是坚持啃一啃，做一点笔记</summary>
    
    
    
    <category term="机器学习" scheme="https://aachou.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>写在大学最后的时光</title>
    <link href="https://aachou.github.io/2023/0208/"/>
    <id>https://aachou.github.io/2023/0208/</id>
    <published>2023-02-08T08:49:24.000Z</published>
    <updated>2023-08-09T10:13:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>当决定考研的那一刻，我并不知道我为什么一定要考研，内心的我是这样想的：考上了研究生，将来会更有优势。想法非常的单纯，在将近一年的准备的过程中，感觉身心疲惫，简直就是在折磨自己，每天三点一线的模式，大部分时间就是坐在板凳上看书学习，只能靠着听音乐和以后所谓的“美好将来”的幻想来迷惑自己<span id="more"></span>。</p><p>到了考试前终于停下了，整个人一度的摆烂，考试那几天几乎没有看书，那些天有特殊情况，学校让隔离了，本来大家都要回家隔离再回来考试的，全宿舍都被感染了新冠，考试当天就发烧头痛。已经无所谓了，就这两三天，也没什么心思看书，只希望早点回家。当坐在回去的列车上，看着窗外飞速而过的树木，我知道这一年真的太不容易。</p><p>就像22年的卡塔尔世界杯，梅西带领阿根廷闯进世界杯决赛，我在拼命的刷数学题，我们每个人都在拼命地朝着目标前进，都在付出，最后阿根廷赢了，而我并不知道自己赢没赢，人生真的是一场比赛或者游戏吗？</p><p>回想大学四年的时光，自己懵懵懂懂地进入大学，把以前的无知和天真带了进来，左右折腾也没有找到那些大牛口中声称的“热爱”，可能是校园太小了吧，或者是我的能力和资源有限的原因吧，我迷茫地花掉了大学的大部分时光，期间也曾起来试图摆脱平庸，和其他人一起考了大学英语四六级，但是考过了又怎样。进入大三了，我又开始陷入另一种迷茫，要不要考研？网上各种声音，说考研是人生的一个转折点；说考研是一种逃避毕业工作的途径；又说考研是为了将来更好的自己，还说是在提高自己，我不懂在提高自己的什么，血压和体重吗？还是自己的受骗率？只是为了学历就算了，说实话，我还是挺佩服那些努力考上研的同学，网上基本上都是知名大学，每当看到我们这些双非院校的能逆袭985、211的视频，我更加迷茫了，我不知道是为了什么，我只是照着别人的路线继续按部就班地走下去罢了，从来没有听听内心的真实想法。所以一年下来也非常痛苦，搬书来来回回，晚上10点多才回宿舍，总是在逃避着什么。我也不清楚，进入大学以来一个人突然地像被释放了，自由独立多了，没有什么约束，也就迷茫了。从来没有人向我介绍大学生活，也没有人告诉我们大学里应该怎么做，网上倒是有很多教程，有关生活的各个方面，都被安排的明明白白。</p><p>马上就要毕业了，我依然是这样的不知所措，准备毕设加可能的研究生复试加就业，我不可能面面俱到，人生就是这样，有得有失，我准备好了面对结果了。也许我并不在乎最终结果，大概只是喜欢努力过后能有一点收获的感觉吧，可能有付出并不会有回报，就挺打击的。</p><p>如果我如愿考上研究生，那就针对的起大学这几年的颓废和迷茫吗？我又陷入了一种“迷茫”，我在读研究生，每天看着各种文献，敲着代码，导师可能一个星期就联系一次，等到毕业了又不知道如何面对以后的生活，如何融入这个陌生的社会，如何在这个世界生存下去，只能说学校建了一堵厚厚的墙，把里面的我们保护的很好，看起来我只是换了一个学校继续迷茫罢了。当初大学填报志愿的时候只是怀着一丝好奇选择了计算机专业，大学之前也没有太多机会接触计算机，直到枯燥的课程扑面而来，我才算是入门计算机了，之后的话几乎停留在理论的基础上，运用的最多是和同学一起玩游戏，大学期间电脑游戏也算是入门了。</p><p>可能是时间的原因，推着我们向前走，直到认清自己，开始接受现实，我只是一个“被编好程序的人”，安排来接受教育之后进入社会打工罢了，不然怎么叫程序员呢。当程序员也好呀，走到了人生的最后几步了，不用担心没有钱吃喝住了，心里踏实平静多了，也许不迷茫了，当然买房可能是个问题，不过比待业在家啃老强，好歹有个稳定收入养活一家子。以后操心事多了，就不继续遐想了，总之顺其自然吧，父母希望子女有个出息，但是我也就这样了，他们知不知道我们现在的压力呢，年轻人拼了命的努力，最后只为了在目标城市买到一块安生之地。</p><p>虽然现在考试分数还没出来，但是毕设和企业春招已经开始了，是时候走出迷茫了，走一个令人舒畅的路了，疫情这几年真不容易，真是难受！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;当决定考研的那一刻，我并不知道我为什么一定要考研，内心的我是这样想的：考上了研究生，将来会更有优势。想法非常的单纯，在将近一年的准备的过程中，感觉身心疲惫，简直就是在折磨自己，每天三点一线的模式，大部分时间就是坐在板凳上看书学习，只能靠着听音乐和以后所谓的“美好将来”的幻想来迷惑自己</summary>
    
    
    
    <category term="碎碎念" scheme="https://aachou.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
  </entry>
  
  <entry>
    <title>关于28岁的字节工程师离世的感慨</title>
    <link href="https://aachou.github.io/2022/0224/"/>
    <id>https://aachou.github.io/2022/0224/</id>
    <published>2022-02-24T08:36:49.000Z</published>
    <updated>2023-08-09T10:13:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>此前网传年轻的字节跳动员工吴同学已离世，字节跳动的内网一则通知显示，从医院获知，吴同学不幸离世。经过大概是这样的，2月21日晚上18点，28岁的吴同学走进字节跳动的健身房，吴同学在运动约1小时后出现头晕现象，情况加重。当晚19时30分许，急救人员到场救治，并将其送上救护车<span id="more"></span>。2月23日0时30分，医院反馈，该员工情况危重。不久，吴同学便去世了。</p><p>说到这，我是软件的本科生，起初同样是怀着兴趣报考了计算机相关的专业，以至于来到了之后不太满意的学校。28岁可以称他为‘学长’了，大了我几岁，但还是年轻的生命啊！吴学长有着名校的学历，很早就有了从事IT行业的想法，在毕业后进入字节努力地工作，结了婚，买了房，出了书，几个月前妻子还有了孩子。很难想到这样一位年轻的学长，本应在日后获得更加幸福美好的生活，然而现实却是如此的残酷，他是匆匆地离开世间。</p><p>从吴学长生前的个人平台和当前报道来看，吴学长是一位有梦想、活泼开朗的人，而且能力还是很强的，还买了房，虽然是贷款的。尽管在医院奋力的抢救，还是没能挽回吴学长的生命。吴学长的逝世给了吴学长妻子很大的压力，她打算退了房子回到小县城，和她母亲孕育孩子，抚养成人。</p><p>关于以上的消息，我对吴学长的离开感到难过和一点惋惜，惋惜他是一位值得被生活善待的人，结局令人悲痛；还对软件专业的自己感到迷茫，因为面临着就业和考研的烦恼，现在怀疑要不要继续学习计算机或进入相关的行业；也对计算机相关专业在读的同学或即将从事计算机相关行业的人感到一丝忧虑和庆幸，庆幸我们还有当前健康的身体和生活，庆幸我们还有一些选择。</p><p>吴学长的离世不是孤例，另一位26岁的年轻人也上了热搜。上海一家设计事务所的设计师，疑似因加班过度，于15日清晨在出租屋内猝死。两个年轻人的离世消息撞到一起，给人的冲击格外大，难道生活的真相就是如此吗？大家都知道IT行业普遍加班，工作压力很大，生活压力也大，而且相关从业者都生活在大城市。据了解，字节这样的公司喜欢自律能力强的人，基本上福利多，有免费三餐和酒水，免费健身房，五险一金等等，在这样的环境中，人不想向上爬都难，回到家也是不断地学习。</p><p>总之，IT行业就一个字，“卷”！因为社会的某种普遍共识，行业薪资高，不光是入职找工作卷，高考和研究生报考也开始卷起来了，考啥一定考计算机相关的专业，甚至跨考，光想着以后会待遇高，可是也看到了报考人数上涨，招生扩招都无法满足大家的录取，只能越来越卷。不是其他行业不卷，是计算机卷得太厉害了，炸天了！不管适不适合读相关专业，做不做的了相关工作，都涌入大潮之中，特别是人工智能开始发展兴起之后。</p><p>与此同时，在当前像字节这样的大公司里工作，可以自由地享受各种优厚待遇，也会感受到了一种被限制的自由。尽管有弹性的工作制，工作的员工要完成各种任务，和优秀的人在一起会更优秀，但是也要抗住辛苦和劳累。不是说大家不要努力向上，而是看看给自己带来了什么，忽视了长远的利益发展和被迫劳累所带来的危害，即使是强壮的巨人最终也会倒下。</p><p>当时看到吴学长的新闻，就十分感慨，他为何遭遇这样的不幸。因为很难说清他的猝死和加班有没有关联，但应该反思一下，如何在如此的生活压力下，让巨头字节和它的员工的心都保持跳动。·</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;此前网传年轻的字节跳动员工吴同学已离世，字节跳动的内网一则通知显示，从医院获知，吴同学不幸离世。经过大概是这样的，2月21日晚上18点，28岁的吴同学走进字节跳动的健身房，吴同学在运动约1小时后出现头晕现象，情况加重。当晚19时30分许，急救人员到场救治，并将其送上救护车</summary>
    
    
    
    <category term="碎碎念" scheme="https://aachou.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
  </entry>
  
</feed>
