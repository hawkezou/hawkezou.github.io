{"meta":{"title":"Chou's blog","subtitle":"","description":"","author":"Aaron Chou","url":"https://AaChou.github.io","root":"/"},"pages":[{"title":"关于","date":"2023-07-22T23:57:32.000Z","updated":"2025-11-30T09:05:52.215Z","comments":false,"path":"about/index.html","permalink":"https://aachou.github.io/about/index.html","excerpt":"","text":"这是我的 GitHub 博客，这里发表了关于技术和其他的文章，同时也展示了我的个人信息。感谢您的访问！&emsp;This is my GitHub blog, where I have articles I wrote about web and other technologies. It also showcases information about me. Thank you for visiting! 简介Introduction Name: Aa.Chou Major in CyberSecurity A ping-pong player. Homebody but longs for freedom outside, like traveling, have been to Qingdao in ShanDong (first trip). I am somewhat socially anxious, but not very seriously. Specialty: web、java、python、linux, currently interested in AI. Email: hzou0435@gmail.com&emsp; 姓名：邹子豪 网络安全专业 乒乓球爱好者 宅但渴望外面的自由，比如旅行，曾去过山东青岛（第一次旅行）。 有些社交焦虑，但不严重。 专长：web、java、python、linux，对人工智能感兴趣。 邮箱：hzou0435@gmail.com 教育经历Education 2023-至今 NCU Master 2019-2023 HPU Bachelor of Engineering Degree（Software-Engineering） 其他经历Other experiences&emsp;目前暂无其他出彩经历，以后会丰富一些！ &emsp;Currently, there are no other outstanding experiences, but they will be enriched in the future!"},{"title":"分类","date":"2020-03-19T10:08:44.000Z","updated":"2020-06-27T01:31:13.000Z","comments":false,"path":"categories/index.html","permalink":"https://aachou.github.io/categories/index.html","excerpt":"","text":""},{"title":"archives","date":"2020-04-06T23:57:32.000Z","updated":"2020-04-08T07:56:43.000Z","comments":true,"path":"archives/index.html","permalink":"https://aachou.github.io/archives/index.html","excerpt":"","text":""}],"posts":[{"title":"SpringBoot原理解析","slug":"springboot","date":"2024-01-18T01:16:09.000Z","updated":"2024-01-18T02:09:49.000Z","comments":true,"path":"2024/0118/","permalink":"https://aachou.github.io/2024/0118/","excerpt":"springboot是一种简化springweb开发的框架，类似springmvc，他提供各种默认配置，达到开箱即用、敏捷开发的效果。本文主要介绍springboot的依赖管理、自动配置、web开发、thymeleaf与视图解析、拦截器、文件上传、异常处理、web原生组件注入、整合数据源Druid与Redis、Junit单元测试、spring Acutuator性能监控、高级特性与springboot启动原理。","text":"springboot是一种简化springweb开发的框架，类似springmvc，他提供各种默认配置，达到开箱即用、敏捷开发的效果。本文主要介绍springboot的依赖管理、自动配置、web开发、thymeleaf与视图解析、拦截器、文件上传、异常处理、web原生组件注入、整合数据源Druid与Redis、Junit单元测试、spring Acutuator性能监控、高级特性与springboot启动原理。 依赖管理父项目依赖123456&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.7.1&lt;/version&gt; &lt;relativePath/&gt;&lt;/parent&gt; 作用：依赖管理及版本管理。 父项目的父项目： 12345&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.7.1&lt;/version&gt;&lt;/parent&gt; 其中默认引入了许多依赖，自动版本仲裁无需关注版本，我们可以不用配置某些依赖的版本，但是第三方需要。根据maven就近原则，默认使用本项目pom.xml配置好的依赖，若需要修改依赖版本号： 1234&lt;properties&gt; &lt;java.version&gt;8&lt;/java.version&gt; &lt;mysql.version&gt;5.2.41&lt;/mysql.version&gt;&lt;/properties&gt; starter场景启动器starter也叫依赖管理器，spring-boot-starter-*是用来开发某一场景的一组依赖，引入starter就导入了相关的开发依赖。 starter基本依赖为pring-boot-starter，web开发还需要引入spring-boot-starter-json、spring-boot-starter-tomcat、spring-web、spring-webmvc。 自动配置启动时加载所有自动配置和组件，条件装配按需配置。自动配置tomcat、自动配置springMVC、自动配置web常见功能、自动扫描springboot主程序所在包及子包下的bean组件。 @SpringBootApplication注解相当于@SpringBootConfiguration、@EnableAutoConfiguration、@ComponentScan注解。 自动配置按需加载，pom.xml引入依赖后该依赖的自动配置才会生效。配置会映射到某个配置类中，springboot默认配置会映射到名为xxProperties.class配置类中，配置类也是组件。 @Configuration声明配置类，参数proxyBeanMethods默认为true，开启代理，即使用cglib生成代理对象，只会在容器中生成一个组件示例。若为false，则不会生成代理对象，每次调用组件都会创建一个实例对象。 @Bean给容器中添加组件，以类名或方法名做id，返回类型为组件类型，返回值即组件在容器中的示例。@Bean注解的方法名默认作为对象的名字，也可以用name属性定义对象的名字。@bean分为两种模式,一种是Lite Mode(轻量模式),这种模式下被@bean定义的方法需要在@Component下或者原生类下,效果类似于@Component注册在类上的效果。@Configuration下的@bean被称为是Full mode，bean的创建是通过cglib代理生成的被@Configuration定义的类的增强类，因为@Configuration定义的类的bean，默认都是被Spring通过Cglib增强的子类。 @Bean注解参数： value：定义bean在IOC容器中的id属性。name ：定义bean在IOC容器中的id属性。autowire：装配方式Autowire.NO (默认设置)Autowire.BY_NAMEAutowire.BY_TYPEinitMethod：指定初始化方法 相当于xml文件中 init-methoddestroyMethod：指定销毁的方法 相当于xml文件中 destroy-method @Bean和@Component的区别：@Bean和@Component都是将Spring Bean添加到Spring Context 中。 1）作用域 @Component注解表明一个类会作为组件类，并告知 Spring 要为这个类创建 bean。@Bean不能作用在类上，只能作用于方法。 @Bean注解告诉 Spring 这个方法将会返回一个对象，这个对象要注册为 Spring 应用上下文中的 bean。要获取这个 bean 的时候，Spring 要按照这种方式、去获取这个 bean。 2）注册方式 @Component注解表明一个类会作为组件类，并告知 Spring 要为这个类创建 bean。@Bean注解告诉 Spring 这个方法将会返回一个对象，这个对象要注册为 Spring 应用上下文中的 bean。通常方法体中包含了最终产生bean实例的逻辑。 当我们引用第三方库中的类需要装配到 Spring 容器时，则只能通过@Bean来实现。 3）使用方式 @Component（@Controller、@Service、@Repository）通常是通过类路径扫描来侦测及自动装配到 Spring 容器中。@Bean一般结合@Configuration一起使用，也可以配置在类的方法中。 容器功能注解组件添加： 1、@Configuration 2、@Bean、@Component、@Controller、@Service 3、@ComponentScan 4、@Conditional 原生配置文件导入： @ImportResource 配置绑定： 1、@ConfigurationProperties 2、@EnableConfigurationProperties+@ConfigurationProperties 3、@Component+@ConfigurationProperties @Import(&#123;xx.class,xx.class&#125;)，通过类型在容器中创建组件实例，组件名为全类名。 @Conditional，条件装配注解，满足指定条件进行组件注册。参数value为一个class泛型数组。@ConditionalOnBean(name &#x3D; “xxx”)，当ioc容器中存在该对象时，为该组件注册实例。 @ImportResource(&quot;classpath:beans.xml&quot;)，导入spring原生配置文件，支持xml配置。 @EnableConfigurationProperties(xx.class)，为xx.class开启配置属性绑定。 @AutoConfigurationPackage，自动配置包原则，利用Register批量地将主程序所在包下的所有组件批量注册进容器。 @ConfigurationProperties(prefix=&quot;spring&quot;)，为核心配置文件中的属性绑定前缀，在映射的实体类上添加注解，表示将该类注册成bean并配置属性值。 简化开发lombok开发 1、在maven项目的pom.xml文件中添加lombok依赖 2、执行maven导入依赖 3、添加@Data注解，免去get和set方法 4、添加@ToString重写toString方法。 spring Initailizr开发，再idea中使用spring Initailizr创建初始化项目，勾选依赖配置和版本，maven自动导入，实现快速初始化项目。 yaml（yaml ain’t markup language）配置，key-value写法，大小写敏感，缩进表层级，#为注释。字符串值用单引号或双引号包围，单引号将\\n作为字符串输出，双引号将\\n作为换行输出。 注：标记语言是一种将标记以及文本相关的其他信息结合起来，展现出关于文档结构和数据处理细节的文字编码。 spring-boot-configuration-processor配置处理器，显示配置提示信息，添加依赖： 12345678910111213141516171819202122&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;!--在打包项目的时候排除以下简化开发的插件--&gt; &lt;excludes&gt; &lt;exclude&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;/exclude&gt; &lt;/excludes&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; web场景开发src&#x2F;main&#x2F;java；src&#x2F;main&#x2F;resources都是classes类路径的根路径，下面的所有文件都在该类路径下。当请求来时，java先动态处理，无法处理后寻找静态资源。默认的静态资源路径有[&#x2F;static，&#x2F;resources，&#x2F;META-INF，&#x2F;public] 1private static final String[] CLASSPATH_RESOURCE_LOCATIONS = &#123; &quot;classpath:/META-INF/resources/&quot;,&quot;classpath:/resources/&quot;, &quot;classpath:/static/&quot;, &quot;classpath:/public/&quot; &#125;; 欢迎页处理： 12345678910111213WelcomePageHandlerMapping(TemplateAvailabilityProviders templateAvailabilityProviders, ApplicationContext applicationContext, Optional&lt;Resource&gt; welcomePage, String staticPathPattern) &#123; if (welcomePage.isPresent() &amp;&amp; &quot;/**&quot;.equals(staticPathPattern)) &#123; //要用欢迎页功能，必须是/** logger.info(&quot;Adding welcome page: &quot; + welcomePage.get()); setRootViewName(&quot;forward:index.html&quot;); &#125; else if (welcomeTemplateExists(templateAvailabilityProviders, applicationContext)) &#123; // 调用Controller /index logger.info(&quot;Adding welcome page template: index&quot;); setRootViewName(&quot;index&quot;); &#125;&#125; 请求处理1234&lt;form action=&quot;/user&quot; method=&quot;post&quot;&gt; &lt;input name=&quot;_method&quot; type=&quot;hidden&quot; value=&quot;delete&quot;/&gt; &lt;input type=&quot;submit&quot; value=&quot;delete提交&quot;/&gt;&lt;/form&gt; 核心Filter：HiddenHttpMethodFilter；用法： 表单method&#x3D;post，隐藏域 _method&#x3D;put，SpringBoot中手动开启。 12345spring: mvc: hiddenmethod: filter: enabled: true #开启页面表单的Rest功能 设置自定义的methodFilter，编写webconfig配置类，创建filter对象，调用HiddenHttpMethodFilter的setMethodParam方法。 Rest原理 表单提交会带上_method=PUT 请求过来被HiddenHttpMethodFilter拦截 请求是否正常，并且是POST 获取到_method的值。 兼容以下请求；PUT、DELETE、PATCH 原生request（post），包装模式requesWrapper重写了getMethod方法，返回的是传入的值。 过滤器链放行的时候用wrapper。以后的方法调用getMethod是调用requesWrapper。 Rest使用客户端工具，PostMan直接发送Put、delete等方式请求，无需Filter。 请求映射原理： SpringMVC功能分析都从 org.springframework.web.servlet.DispatcherServlet-&gt;doDispatch(） RequestMappingHandlerMapping：保存了所有@RequestMapping和handler的映射规则。 所有的请求映射都在HandlerMapping中。 SpringBoot自动配置欢迎页的 WelcomePageHandlerMapping ，访问 &#x2F;能访问到index.html SpringBoot自动配置了默认的RequestMappingHandlerMapping 请求进来，挨个尝试所有的HandlerMapping看是否有请求信息。如果有就找到这个请求对应的handler，如果没有就是下一个 HandlerMapping。 基本注解： 路径变量@PathVariable、获取请求头@RequestHeader、模型属性@ModelAttribute、声明请求参数@RequestParam、获取post请求体@RequestBody、声明请求属性@RequestAttribute、矩阵变量@MatrixVariable、获取cookie值@CookieValue、请求处理映射路径@RequestMapping。 123456789101112131415161718package com.example.demo;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;@SpringBootApplication@RestControllerpublic class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125; @GetMapping(&quot;/hello&quot;) public String hello(@RequestParam(value = &quot;name&quot;, defaultValue = &quot;World&quot;) String name) &#123; return String.format(&quot;Hello %s!&quot;, name); &#125;&#125; Servlet API： WebRequest、ServletRequest、MultipartRequest、 HttpSession、javax.servlet.http.PushBuilder、Principal、InputStream、Reader、HttpMethod、Locale、TimeZone、ZoneId。 复杂参数： Map、Model（map、model里面的数据会被放在request的请求域 request.setAttribute）、Errors&#x2F;BindingResult、RedirectAttributes（ 重定向携带数据）、ServletResponse（response）、SessionStatus、UriComponentsBuilder、ServletUriComponentsBuilder 自定义对象参数： 可以自动类型转换与格式化，可以级联封装 123456789101112@Datapublic class Person &#123; private String userName; private Integer age; private Pet pet; &#125;@Datapublic class Pet &#123; private String name; private String age;&#125; 参数处理原理 HandlerMapping中找到能处理请求的Handler（Controller.method()） 为当前Handler 找一个适配器 HandlerAdapter； RequestMappingHandlerAdapter 适配器执行目标方法并确定方法参数的每一个值 参数解析器-HandlerMethodArgumentResolver 确定将要执行的目标方法的每一个参数的值是什么，SpringMVC目标方法能写多少种参数类型。取决于参数解析器。 响应请求 响应JSON ， jackson+@ResponseBody（返回数据不返回页面视图） SpringMVC到底支持以下返回值： 1234567891011121314ModelAndViewModelViewResponseEntity ResponseBodyEmitterStreamingResponseBodyHttpEntityHttpHeadersCallableDeferredResultListenableFutureCompletionStageWebAsyncTask@ResponseBody---&gt; RequestResponseBodyMethodProcessor； 返回值解析器原理 返回值处理器判断是否支持这种类型返回值 supportsReturnType 返回值处理器调用 handleReturnValue 进行处理 RequestResponseBodyMethodProcessor 可以处理返回值标了@ResponseBody 注解的 底层利用 MessageConverters 进行处理 ，将数据写为json 1、内容协商（浏览器默认会以请求头的方式告诉服务器他能接受什么样的内容类型） 2、服务器最终根据自己自身的能力，决定服务器能生产出什么样内容类型的数据， 3、SpringMVC会挨个遍历所有容器底层的 HttpMessageConverter ，看谁能处理 得到MappingJackson2HttpMessageConverter可以将对象写为json 根据客户端接收能力不同，返回不同媒体类型的数据，只需要改变请求头中Accept字段。Http协议中规定的，告诉服务器本客户端可以接收的数据类型。 导入了jackson处理xml的包，xml的converter就会自动进来: 1234 &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt; &lt;artifactId&gt;jackson-dataformat-xml&lt;/artifactId&gt;&lt;/dependency&gt; 开启浏览器参数方式内容协商功能: 1234spring: contentnegotiation: favor-parameter: true #开启基于请求参数内容协商策略 内容协商原理 1、判断当前响应头中是否已经有确定的媒体类型MediaType。 2、获取客户端支持接收的内容类型。（获取客户端Accept请求头字段）。 ​ contentNegotiationManager内容协商管理器两种内容协商策略： ​ （1）ParameterContentNegotiationStrategy 基于format参数(mediaType有json;xml) ​ （2）HeaderContentNegotiationStrategy 默认基于请求头(mediaType为xml) 3、遍历循环所有当前系统的 MessageConverter，看谁支持操作这个对象。 4、找到支持操作Person的converter，把converter支持的媒体类型统计出来。 5、客户端需要【application&#x2F;xml】，服务端能力【10种、json、xml】。 6、进行内容协商的最佳匹配媒体类型。 7、用支持将对象转为 最佳匹配媒体类型 的converter。调用它进行转化 。 自定义返回值mediaType数据格式，配置内容协商策略，添加自定义的mediaType类型。 **自定义MessageConverter ** 实现多协议数据兼容。json、xml… (1)、@ResponseBody 返回响应数据出去，调用 RequestResponseBodyMethodProcessor 处理 (2)、Processor 处理方法返回值，通过 MessageConverter 处理 (3)、所有 MessageConverter 合起来可以支持各种媒体类型数据的操作（读、写） (4)、内容协商找到最终的 messageConverter thymeleaf一个XML&#x2F;XHTML&#x2F;HTML5模板引擎，可用于Web与非Web环境中的应用开发。它是一个开源的现代化服务端Java模板引擎，是整合 Spring MVC 的可选模块，在应用开发中，使用 Thymeleaf 来代替 JSP或其他模板引擎。官网 注：由于SpringBoot打包是以jar的方式，不是war。其次我们的tomcat是嵌入式的，所以现在SpringBoot默认不支持jsp。Spring官方文档 基本语法 ： 表达式名字 语法 用途 变量取值 ${…} 获取请求域、session域、对象等值 选择变量 *{…} 获取上下文对象值 消息 #{…} 获取国际化等值 链接 @{…} 生成链接 片段表达式 ~{…} jsp:include 作用，引入公共页面片段 2、字面量 文本值: ‘one text’ , ‘Another one!’ ,…数字: 0 , 34 , 3.0 , 12.3 ,…布尔值: true , false 空值: null 变量： one，two，…. 变量不能有空格 3、文本操作 字符串拼接: + 变量替换: |The name is ${name}| 4、数学运算 运算符: + , - , * , &#x2F; , % 5、布尔运算 运算符: and , or 一元运算: ! , not 6、比较运算 比较: &gt; , &lt; , &gt;&#x3D; , &lt;&#x3D; ( gt , lt , ge , le )等式: &#x3D;&#x3D; , !&#x3D; ( eq , ne ) 7、条件运算 If-then: (if) ? (then) If-then-else: (if) ? (then) : (else) Default: (value) ?: (defaultvalue) 8、特殊操作 无操作： _ 迭代： 12345&lt;tr th:each=&quot;prod : $&#123;prods&#125;&quot;&gt; &lt;td th:text=&quot;$&#123;prod.name&#125;&quot;&gt;Onions&lt;/td&gt; &lt;td th:text=&quot;$&#123;prod.price&#125;&quot;&gt;2.41&lt;/td&gt; &lt;td th:text=&quot;$&#123;prod.inStock&#125;? #&#123;true&#125; : #&#123;false&#125;&quot;&gt;yes&lt;/td&gt;&lt;/tr&gt; 使用thymeleaf 引入依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 在相关页面中定义命名空间： 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form class=&quot;layui-form&quot; lay-filter=&quot;userForm&quot; id=&quot;userForm&quot;&gt; &lt;!--/*@thymesVar id=&quot;myUserName&quot; type=&quot;ch&quot;*/--&gt; &lt;input type=&quot;text&quot; th:text=&quot;$&#123;myUserName&#125;&quot; name=&quot;userName&quot; lay-verify=&quot;required&quot; placeholder=&quot;请输入用户名&quot; autocomplete=&quot;off&quot; class=&quot;layui-input&quot;&gt;&lt;a href=&quot;www.xxxx.com&quot; th:href=&quot;$&#123;link&#125;&quot;&gt;百度&lt;/a&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; controller返回对应页面： 12345678@RequestMapping(&quot;/editUser&quot;)public String editUser(Model model)&#123; User u = userService.getUser(); model.addAttribute(&quot;myUserName&quot;,u.getUserName()); model.addAttribute(&quot;myNickName&quot;,u.getNickName()); model.addAttribute(&quot;link&quot;,&quot;www.baidu.com&quot;); return &quot;user&quot;;&#125; 视图解析原理流程1、目标方法处理的过程中，所有数据都会被放在 ModelAndViewContainer 里面。包括数据和视图地址 2、方法的参数是一个自定义类型对象（从请求参数中确定的），把他重新放在 ModelAndViewContainer 3、任何目标方法执行完成以后都会返回 ModelAndView（数据和视图地址）。 4、processDispatchResult 处理派发结果（页面改如何响应） render(mv, request, response); 进行页面渲染逻辑 根据方法的String返回值得到 View 对象（定义了页面的渲染逻辑），所有的视图解析器尝试是否能根据当前返回值得到View对象，得到了 redirect:&#x2F;main.html –&gt; Thymeleaf new RedirectView()，ContentNegotiationViewResolver 里面包含了下面所有的视图解析器，内部还是利用下面所有视图解析器得到视图对象。view.render(mv.getModelInternal(), request, response)，视图对象调用自定义的render进行页面渲染工作。 RedirectView 如何渲染【重定向到一个页面】 1、获取目标url地址 2、response.sendRedirect(encodedURL) 视图解析： 1）返回值以 forward: 开始： new InternalResourceView(forwardUrl)–&gt; 转发request.getRequestDispatcher(path).forward(request, response); 2）返回值以 redirect: 开始： new RedirectView() -&gt; render就是重定向 3）返回值是普通字符串： new ThymeleafView() HandlerInterceptor拦截器定义拦截器，实现HandlerInterceptor接口，重写preHandler方法： 123456789101112public class LoginInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; //获取session HttpSession httpSession = request.getSession(); if(httpSession.getAttribute(&quot;loginUser&quot;)==null)&#123; response.sendRedirect(&quot;/f/toLogin&quot;); return false; &#125; return true; &#125;&#125; webMvcConfig重写addInterceptor方法： 12345678910@Configurationpublic class WebConfig implements WebMvcConfigurer &#123; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new LoginInterceptor()) .addPathPatterns(&quot;/**&quot;) .excludePathPatterns(&quot;/&quot;,&quot;/login.html&quot;,&quot;/f/toLogin&quot;, &quot;/user/login&quot;,&quot;/img/*&quot;,&quot;/layui/**&quot;); &#125;&#125; 拦截器执行过程： preHandler-&gt;目标方法-&gt;postHandler-&gt;afterCompletion 原理： 1、根据当前请求，找到HandlerExecutionChain【可以处理请求的handler以及handler的所有拦截器】 2、先顺序执行 所有拦截器的 preHandle方法 如果当前拦截器prehandler返回为true。则执行下一个拦截器的preHandle。 如果当前拦截器返回为false。直接倒序执行所有已经执行了的拦截器的afterCompletion。 3、如果任何一个拦截器返回false。直接跳出不执行目标方法。 4、所有拦截器都返回True，执行目标方法。 5、倒序执行所有拦截器的postHandle方法。 6、前面的步骤有任何异常都会直接倒序触发 afterCompletion 7、页面成功渲染完成以后，也会倒序触发 afterCompletion 文件上传文件上传自动配置类-MultipartAutoConfiguration，spring boot自动配置好了 StandardServletMultipartResolver 文件上传解析器。 原理步骤： 1、请求进来使用文件上传解析器判断（isMultipart）并封装（resolveMultipart，返回MultipartHttpServletRequest）文件上传请求。 2、参数解析器来解析请求中的文件内容封装成MultipartFile。 3、将request中多个文件信息封装为一个Map ，MultiValueMap&lt;String, MultipartFile&gt; 。 注：可以FileCopyUtils文件复制工具类的copy方法，实现文件流的拷贝。 核心配置文件中配置spring文件上传大小： 12345spring: servlet: multipart: max-file-size: 10MB max-request-size: 100MB 前端页面表单： 12345&lt;!--post提交，上传至/upload，contentType=&quot;multipart/form-data&quot;--&gt;&lt;form method=&quot;post&quot; action=&quot;/upload&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt; 后端接口： 1234567891011/** * MultipartFile 自动封装上传过来的文件 * @RequestPart从请求中取multipartFile文件 */@PostMapping(&quot;/upload&quot;)public String upload(@RequestParam(&quot;username&quot;) String username, @RequestPart(&quot;headerImg&quot;) MultipartFile headerImg, @RequestPart(&quot;photos&quot;) MultipartFile[] photos) throws IOException &#123; return &quot;main&quot;;&#125; 异常处理错误处理默认规则 默认情况下，Spring Boot提供/error处理所有错误的映射 对于服务器端，它将生成JSON响应，其中包含错误，HTTP状态和异常消息的详细信息。对于浏览器端，响应一个“ WhitelabelErrorView”，以HTML格式呈现。 要对其进行自定义，添加View解析为error 要完全替换默认行为，可以实现 ErrorController 并注册该类型的Bean定义，或添加ErrorAttributes类型的组件以使用现有机制但替换其内容。 templates&#x2F;error&#x2F;下的4xx，5xx页面会被自动解析； 定制错误处理逻辑 自定义错误页 error&#x2F;404.html error&#x2F;5xx.html，有精确的错误状态码页面就匹配精确，没有就找 4xx.html；如果都没有就触发白页。 @ControllerAdvice+@ExceptionHandler处理全局异常，底层是使用ExceptionHandlerExceptionResolver @ResponseStatus(返回状态码)+自定义异常 ，底层是使用ResponseStatusExceptionResolver，把@ResponseStatus注解的信息封装成ModelAndView并返回，底层调用 response.sendError(statusCode, resolvedReason)。 Spring底层的异常，如参数类型转换异常，使用DefaultHandlerExceptionResolver 处理框架底层的异常。 response.sendError(HttpServletResponse.SC_BAD_REQUEST, ex.getMessage()) 自定义实现 HandlerExceptionResolver接口的异常解析器，可以作为默认的全局异常处理规则。 ErrorViewResolver实现自定义处理异常，response.sendError(411,”自定义异常”)，error请求就会转给controller。异常没有任何人能处理，则tomcat底层调用response.sendError，error请求就会转给controller。BasicErrorController要去的页面地址是ErrorViewResolver 。 异常处理自动配置 ErrorMvcAutoConfiguration 自动配置异常处理规则 容器中的组件：类型：DefaultErrorAttributes -&gt; id：errorAttributes。 public class DefaultErrorAttributes implements ErrorAttributes, HandlerExceptionResolver。 DefaultErrorAttributes：定义错误页面中可以包含哪些数据。 容器中的组件：类型：BasicErrorController –&gt; id：basicErrorController（json+白页 适配响应）。 处理默认 &#x2F;error 路径的请求，页面响应 new ModelAndView(“error”, model)。 容器中有组件 View-&gt;id是error（响应默认错误页）。 容器中放组件 BeanNameViewResolver，按照返回的视图名作为组件的id去容器中找View对象。 容器中的组件：类型：DefaultErrorViewResolver -&gt; id：conventionErrorViewResolver。 如果发生错误，会以HTTP的状态码作为视图页地址（viewName），找到真正的页面。 viewName：error&#x2F;404、5xx.html。 如果想要返回页面，就会找error视图StaticView类型的defaultErrorView，默认是一个白页。其中定义了类WhitelabelErrorViewConfiguration。 异常处理步骤流程1、执行目标方法，目标方法运行期间有任何异常都会被catch，而且标志当前请求结束，并且用 dispatchException封装 。 2、进入视图解析页面渲染 mav = processDispatchResult(processedRequest, response, mappedHandler, mav, dispatchException); 3、处理handler发生的异常，处理完成返回ModelAndView（跳转地址和页面数据）。 遍历所有的handlerExceptionResolvers，找到HandlerExceptionResolver处理器异常解析器。 默认异常解析器（DefaultErrorAttributes、DefaultHandlerExceptionResolver、ExceptionHandlerExceptionResolver、ResponseHandlerExceptionResolver） DefaultErrorAttributes定义错误信息(exception、status、stack_trace、error、message、path)，把异常信息保存到request域，并且返回null。默认没有任何人能处理异常，所以异常会被抛出 如果没有任何人能处理最终底层就会发送 &#x2F;error 请求，会被底层的BasicErrorController处理。解析错误视图，遍历所有的 ErrorViewResolver解析，找到默认的DefaultErrorViewResolver(作用是把响应状态码作为错误页的地址)，模板引擎最终响应这个页面error&#x2F;xxx.html。 Web原生组件注入（Servlet、Filter、Listener）使用Servlet API @ServletComponentScan(basePackages = &quot;com.xxx.xxx&quot;) :指定原生Servlet组件都放在那里 @WebServlet(urlPatterns = &quot;/my&quot;)：效果：直接响应，没有经过Spring的拦截器。 @WebFilter(urlPatterns=&#123;&quot;/css/\\*&quot;,&quot;/images/\\*&quot;&#125;) @WebListener DispatchServlet 如何注册进来 容器中自动配置了 DispatcherServlet 属性绑定到 WebMvcProperties；对应的配置文件配置项是 spring.mvc。 通过ServletRegistrationBean&lt;DispatcherServlet&gt;把 DispatcherServlet 配置进来。 默认映射的是 &#x2F; 路径。 Tomcat-Servlet； 多个Servlet都能处理到同一层路径，精确优选原则 A： &#x2F;my&#x2F; B： &#x2F;my&#x2F;1 使用RegistrationBean 1ServletRegistrationBean`, `FilterRegistrationBean`, and `ServletListenerRegistrationBean 嵌入式Servlet容器 默认支持的webServer有Tomcat, Jetty, or Undertow，ServletWebServerApplicationContext 容器启动寻找ServletWebServerFactory 并引导创建服务器。 原理 (1) SpringBoot应用启动发现当前是Web应用。web场景包-导入tomcat，web应用会创建一个web版的ioc容器 ServletWebServerApplicationContext 。ServletWebServerApplicationContext 启动的时候寻找 ServletWebServerFactory（Servlet 的web服务器工厂—&gt; Servlet 的web服务器）。 (2) SpringBoot底层默认有很多的WebServer工厂，TomcatServletWebServerFactory, JettyServletWebServerFactory, or UndertowServletWebServerFactory。底层直接会有一个自动配置类ServletWebServerFactoryAutoConfiguration，它导入了ServletWebServerFactoryConfiguration。 (3) ServletWebServerFactoryConfiguration 配置类 根据动态判断系统中到底导入了那个Web服务器的包。（默认是web-starter导入tomcat包），容器中就有TomcatServletWebServerFactory ，它创建出Tomcat服务器并启动。TomcatWebServer 的构造器拥有初始化方法initialize—this.tomcat.start()。 (4) 内嵌服务器就是手动把启动服务器的代码调用，前提是tomcat核心jar包存在。 定制Servlet容器 实现 WebServerFactoryCustomizer&lt;ConfigurableServletWebServerFactory&gt; 接口的xxxCustomizer定制化器，可以改变xxxx的默认规则。 把配置文件的值和ServletWebServerFactory 进行绑定。 修改核心配置文件，server.xxx。 直接自定义 ConfigurableServletWebServerFactory 编写一个配置类实现 WebMvcConfigurer 即可定制化web功能+ @Bean给容器中再扩展一些组件。 Druid数据源 Druid主要解决的问题就是传统数据库无法解决的大数据量查询性能的问题。 本质就是一个分布式支持实时数据分析的数据存储系统。 在实际应用中，MyBatis 可以利用 Druid 作为其连接池，这样可以避免频繁地创建和关闭连接。MyBatis 会指定 Druid 作为连接池，并从中获取连接。这样MyBatis 从 Druid 中获得连接的管理工作，专注于数据处理本身。总结来说，Druid 为 MyBatis 提供了一个高效且可靠的连接池服务，使得MyBatis能够在不需要手动管理连接的情况下进行数据库操作。 引入druid-starter： 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.17&lt;/version&gt;&lt;/dependency&gt; 系统中所有filter： 别名 Filter类名 default com.alibaba.druid.filter.stat.StatFilter stat com.alibaba.druid.filter.stat.StatFilter mergeStat com.alibaba.druid.filter.stat.MergeStatFilter encoding com.alibaba.druid.filter.encoding.EncodingConvertFilter log4j com.alibaba.druid.filter.logging.Log4jFilter log4j2 com.alibaba.druid.filter.logging.Log4j2Filter slf4j com.alibaba.druid.filter.logging.Slf4jLogFilter commonlogging com.alibaba.druid.filter.logging.CommonsLogFilter 核心配置： 12345678910111213141516171819202122232425262728293031spring: datasource: druid: url: jdbc:mysql://localhost:3306/db username: root password: 123456 driver-class-name: com.mysql.jdbc.Driver aop-patterns: com.xxx.admin.* #监控SpringBean filters: stat,wall # 底层开启功能，stat（sql监控），wall（防火墙） stat-view-servlet: # 配置监控页功能 enabled: true login-username: admin login-password: 123456 resetEnable: false web-stat-filter: # 监控web enabled: true urlPattern: /* exclusions: &#x27;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*&#x27; filter: stat: # 对上面filters里面的stat的详细配置 slow-sql-millis: 1000 logSlowSql: true enabled: true wall: enabled: true config: drop-table-allow: false SpringBoot配置示例 配置项列表 整合RedisRedis 是一个开源的内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构。 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 核心配置： 123456789spring: redis: host: r-bp1nc7reqesxisgxpipd.redis.rds.aliyuncs.com port: 6379 password: lfy:Lfy123456 #client-type: jedis # jedis: # pool: # max-active: 10 自动配置： RedisAutoConfiguration 自动配置类。RedisProperties 属性类 ，spring.redis.xxx是对redis的配置。 连接工厂是准备好的。LettuceConnectionConfiguration、JedisConnectionConfiguration。 自动注入了RedisTemplate&lt;Object, Object&gt; ： xxxTemplate。 自动注入了StringRedisTemplate；k：v都是String。 底层只要我们使用 StringRedisTemplate、RedisTemplate就可以操作redis。 连接测试： 1234567@Test void testRedis()&#123; ValueOperations&lt;String, String&gt; operations = redisTemplate.opsForValue(); operations.set(&quot;hello&quot;,&quot;world&quot;); String hello = operations.get(&quot;hello&quot;); System.out.println(hello); &#125; 单元测试 Spring Boot 2.2.0 版本开始引入 JUnit 5 作为单元测试默认库，作为最新版本的JUnit框架，JUnit5与之前版本的Junit框架有很大的不同。由三个不同子项目的几个不同模块组成。 JUnit 5 &#x3D; JUnit Platform + JUnit Jupiter + JUnit Vintage 1）JUnit Platform: Junit Platform是在JVM上启动测试框架的基础，不仅支持Junit自制的测试引擎，其他测试引擎也都可以接入。 2）JUnit Jupiter: 提供了JUnit5的新的编程模型，是JUnit5新特性的核心，内部包含了一个测试引擎，用于在Junit Platform上运行。 3）JUnit Vintage: 提供了兼容JUnit4.x,Junit3.x的测试引擎。 相关变化： 注解在 org.junit.jupiter.api 包中，断言在 org.junit.jupiter.api.Assertions 类中，前置条件在 org.junit.jupiter.api.Assumptions 类中。 把@Before 和@After 替换成@BeforeEach 和@AfterEach。 把@BeforeClass 和@AfterClass 替换成@BeforeAll 和@AfterAll。 把@Ignore 替换成@Disabled。 把@Category 替换成@Tag。 把@RunWith、@Rule 和@ClassRule 替换成@ExtendWith。 注意：SpringBoot 2.4 以上版本移除了默认对 Vintage 的依赖，不能使用junit4的功能 @Test，JUnit 5’s Vintage Engine 从spring-boot-starter-test中移除，如果需要继续兼容junit4需要自行引入vintage。 引入依赖： 1234567891011121314151617&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!--兼容junit4--&gt;&lt;dependency&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.hamcrest&lt;/groupId&gt; &lt;artifactId&gt;hamcrest-core&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; SpringBoot整合Junit以后,编写测试方法：@Test标注（注意需要使用junit5版本的注解），Junit类具有Spring的功能，@Autowired、@Transactional 标注测试方法，测试完成后自动回滚。 JUnit5常用注解JUnit5与JUnit4的注解变化 @Test :表示方法是测试方法。但是与JUnit4的@Test不同，他的职责非常单一不能声明任何属性，拓展的测试将会由Jupiter提供额外测试 @ParameterizedTest :表示方法是参数化测试 @RepeatedTest :表示方法可重复执行 @DisplayName :为测试类或者测试方法设置展示名称 @BeforeEach :表示在每个单元测试之前执行 @AfterEach :表示在每个单元测试之后执行 @BeforeAll :表示在所有单元测试之前执行 @AfterAll :表示在所有单元测试之后执行 @Tag :表示单元测试类别，类似于JUnit4中的@Categories @Disabled :表示测试类或测试方法不执行，类似于JUnit4中的@Ignore @Timeout :表示测试方法运行如果超过了指定时间将会返回错误 @ExtendWith :为测试类或测试方法提供扩展类引用 断言assertions断言（assertions）是测试方法中的核心部分，用来对测试需要满足的条件进行验证。这些断言方法都是 org.junit.jupiter.api.Assertions 的静态方法。JUnit 5 内置的断言可以分成如下几个类别： 1、简单断言 用来对单个值进行简单的验证，前面的断言失败，后面的代码不会执行。 方法 说明 assertEquals 判断两个对象或两个原始类型是否相等 assertNotEquals 判断两个对象或两个原始类型是否不相等 assertSame 判断两个对象引用是否指向同一个对象 assertNotSame 判断两个对象引用是否指向不同的对象 assertTrue 判断给定的布尔值是否为 true assertFalse 判断给定的布尔值是否为 false assertNull 判断给定的对象引用是否为 null assertNotNull 判断给定的对象引用是否不为 null 2、数组断言 通过 assertArrayEquals 方法来判断两个对象或原始类型的数组是否相等 12345@Test@DisplayName(&quot;array assertion&quot;)public void array() &#123; assertArrayEquals(new int[]&#123;1, 2&#125;, new int[] &#123;1, 2&#125;);&#125; 3、组合断言 assertAll 方法接受多个 org.junit.jupiter.api.Executable 函数式接口的实例作为要验证的断言，可以通过 lambda 表达式很容易的提供这些断言 12345678@Test@DisplayName(&quot;assert all&quot;)public void all() &#123; assertAll(&quot;Math&quot;, () -&gt; assertEquals(2, 1 + 1), () -&gt; assertTrue(1 &gt; 0) );&#125; 4、异常断言 在JUnit4时期，想要测试方法的异常情况时，需要用**@Rule注解的ExpectedException变量还是比较麻烦的。而JUnit5提供了一种新的断言方式Assertions.assertThrows()** ,配合函数式编程就可以进行使用。 12345678@Test@DisplayName(&quot;异常测试&quot;)public void exceptionTest() &#123; ArithmeticException exception = Assertions.assertThrows( //扔出断言异常 ArithmeticException.class, () -&gt; System.out.println(1 % 0));&#125; 5、超时断言 Junit5还提供了Assertions.assertTimeout() 为测试方法设置了超时时间 123456@Test@DisplayName(&quot;超时测试&quot;)public void timeoutTest() &#123; //如果测试方法时间超过1s将会异常 Assertions.assertTimeout(Duration.ofMillis(1000), () -&gt; Thread.sleep(500));&#125; 6、快速失败 通过 fail 方法直接使得测试失败 12345@Test@DisplayName(&quot;fail&quot;)public void shouldFail() &#123; fail(&quot;This should fail&quot;);&#125; 前置条件（assumptions）JUnit 5 中的前置条件类似于断言，不同之处在于不满足的断言会使得测试方法失败，而不满足的前置条件只会使得测试方法的执行终止直接跳过。前置条件可以看成是测试方法执行的前提，当该前提不满足时，就没有继续执行的必要。 1234567891011121314151617181920@DisplayName(&quot;前置条件&quot;)public class AssumptionsTest &#123; private final String environment = &quot;DEV&quot;; @Test @DisplayName(&quot;assumeTrue&quot;) public void simpleAssume() &#123; assumeTrue(Objects.equals(this.environment, &quot;DEV&quot;)); assumeFalse(() -&gt; Objects.equals(this.environment, &quot;PROD&quot;)); &#125; @Test @DisplayName(&quot;assumingThat&quot;) public void assumeThenDo() &#123; assumingThat( Objects.equals(this.environment, &quot;DEV&quot;), () -&gt; System.out.println(&quot;In DEV&quot;) ); &#125;&#125; assumeTrue 和 assumFalse 确保给定的条件为 true 或 false，不满足条件会使得测试执行终止。assumingThat 的参数是表示条件的布尔值和对应的 Executable 接口的实现对象。只有条件满足时，Executable 对象才会被执行；当条件不满足时，测试执行并不会终止。 嵌套测试JUnit 5 可以通过 Java 中的内部类和@Nested 注解实现嵌套测试，从而可以更好的把相关的测试方法组织在一起。在内部类中可以使用@BeforeEach 和@AfterEach 注解，而且嵌套的层次没有限制。但是，嵌套内部的@BeforeEach 和@AfterEach 方法不会对外部的@Test单元测试生效。相反，外层的会对内层的单元测试生效。 123456789class xxx &#123; @Test @DisplayName(&quot;is empty&quot;) void isEmpty() &#123;&#125; @Nested @DisplayName(&quot;after&quot;) class After &#123;&#125;&#125; 参数化测试参数化测试是JUnit5很重要的一个新特性，用不同的参数多次运行测试，为我们的单元测试带来许多便利。 相关注解： @ParameterizedTest：代表这是一个参数化测试单元，而不是普通测试单元。 @ValueSource：为参数化测试指定入参来源，支持八大基础类以及String类型,Class类型，使用不同的参数进行多次单元测试，而不需要每新增一个参数就新增一个单元测试，省去了很多冗余代码。 @NullSource: 表示为参数化测试提供一个null的入参。 @EnumSource: 表示为参数化测试提供一个枚举入参。 @CsvFileSource：表示读取指定CSV文件内容作为参数化测试入参。 @MethodSource：表示读取指定方法的返回值作为参数化测试入参(注意方法返回需要是一个流)。 123456789101112131415@ParameterizedTest@ValueSource(strings = &#123;&quot;x&quot;, &quot;xx&quot;, &quot;xxx&quot;&#125;)public void parameterizedTest1(String string) &#123; System.out.println(string); Assertions.assertTrue(StringUtils.isNotBlank(string));&#125;@ParameterizedTest@MethodSource(&quot;method&quot;) //指定方法名public void testWithExplicitLocalMethodSource(String name) &#123; System.out.println(name);&#125;static Stream&lt;String&gt; method() &#123; return Stream.of(&quot;xxx&quot;, &quot;xx&quot;);&#125; 注：当然如果参数化测试仅仅只能做到指定普通的入参，他的强大之处的地方在于可以支持外部的各类入参。如:CSV,YML,JSON 文件甚至方法的返回值也可以作为入参。只需要去实现ArgumentsProvider接口，任何外部文件都可以作为它的入参。 指标监控Actuator未来每一个微服务在云上部署以后，都需要对其进行监控、追踪、审计、控制等。SpringBoot就抽取了Actuator场景，使得我们每个微服务快速引用即可获得生产级别的应用监控、审计等功能。 引入依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; ​ 2.x版本与1.x版本不同在于在支持MVC的基础上支持webFlux函数式编程、注解扩展、丰富的安全策略，底层使用MicroMeter。 访问路径：localhost:8080&#x2F;actuator，localhost:8080&#x2F;actuator&#x2F;EndPoint 相关配置： 1234567#management是actuator的配置management: endpoints: enabled-by-default: true #暴露所有JMX端点信息 web: exposure: include: &#x27;*&#x27; #以web方式暴露所有端点 Actuator Endpoint常用的Endpoints监控端点 ID 描述 auditevents 暴露当前应用程序的审核事件信息。需要一个AuditEventRepository组件。 beans 显示应用程序中所有Spring Bean的完整列表。 caches 暴露可用的缓存。 conditions 显示自动配置的所有条件信息，包括匹配或不匹配的原因。 configprops 显示所有配置@ConfigurationProperties。 env 暴露Spring的属性ConfigurableEnvironment flyway 显示已应用的所有Flyway数据库迁移。 需要一个或多个Flyway组件。 health 显示应用程序运行状况信息。 httptrace 显示HTTP跟踪信息（默认情况下，最近100个HTTP请求-响应）。需要一个HttpTraceRepository组件。 info 显示应用程序信息。 integrationgraph 显示Spring integrationgraph 。需要依赖spring-integration-core。 loggers 显示和修改应用程序中日志的配置。 liquibase 显示已应用的所有Liquibase数据库迁移。需要一个或多个Liquibase组件。 metrics 显示当前应用程序的“指标”信息。 mappings 显示所有@RequestMapping路径列表。 scheduledtasks 显示应用程序中的计划任务。 sessions 允许从Spring Session支持的会话存储中检索和删除用户会话。需要使用Spring Session的基于Servlet的Web应用程序。 shutdown 使应用程序正常关闭。默认禁用。 startup 显示由ApplicationStartup收集的启动步骤数据。需要使用SpringApplication进行配置BufferingApplicationStartup。 threaddump 执行线程转储。 如果应用程序是Web应用程序（Spring MVC，Spring WebFlux或Jersey），则可以使用以下附加端点： ID 描述 heapdump 返回hprof堆转储文件。 jolokia 通过HTTP暴露JMX bean（需要引入Jolokia，不适用于WebFlux）。需要引入依赖jolokia-core。 logfile 返回日志文件的内容（如果已设置logging.file.name或logging.file.path属性）。支持使用HTTPRange标头来检索部分日志文件的内容。 prometheus 以Prometheus服务器可以抓取的格式公开指标。需要依赖micrometer-registry-prometheus。 最常用的Endpoint Health：监控状况 Metrics：运行时指标 Loggers：日志记录 Health Endpoint 健康检查端点，一般用于在云平台，平台会定时的检查应用的健康状况，status为up表示健康，为down不健康，web访问路径：localhost:8080&#x2F;actuator&#x2F;health。 Metrics Endpoint 提供详细的、层级的、空间指标信息，这些信息可以被主动推送或者被动获取方式得到。相关metric访问路径：localhost:8080&#x2F;actuator&#x2F;metrics&#x2F;http.server.requests。 管理Endpoints1、开启与禁用Endpoints 默认所有的Endpoint除过shutdown都是开启的。 需要开启或者禁用某个Endpoint，配置模式为management.endpoint.端点名.enabled = true 12345management: endpoint: health: show-details: always enabled: true 或者禁用所有的Endpoint然后手动开启指定的Endpoint 12345678management: endpoints: enabled-by-default: false endpoint: beans: enabled: true health: enabled: true 2、暴露Endpoints 支持的暴露方式 HTTP：默认只暴露health和info JMX：默认暴露所有Endpoint，cmd使用jconsole本地访问 除过health和info，剩下的Endpoint都应该进行保护访问。如果引入SpringSecurity，则会默认配置安全访问规则 JMX （Java Management Extensions，即Java管理扩展）是一个为应用程序、设备、系统等植入管理功能的框架，提供了一种简单的、标准的监控和管理资源的性能监控方式。 定制 Endpoint1、定制 Health 信息 监控端点的类名须以HealthIndicator结尾，方式一实现HealthIndicator接口： 1234567891011@Componentpublic class MyHealthIndicator implements HealthIndicator &#123; @Override public Health health() &#123; int errorCode = check(); if (errorCode != 0) &#123; return Health.down().withDetail(&quot;Error Code&quot;, errorCode).build(); &#125; return Health.up().build(); &#125;&#125; 方式二继承AbstractHealthIndicator抽象类： 12345678910111213141516171819public class MyhealthHealthIndicator extends AbstractHealthIndicator&#123; @Override protected void doHealthCheck(Health.Builder builder) throws Exception &#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); if(1 == 1)&#123; // builder.up(); 健康 builder.status(Status.UP); map.put(&quot;count&quot;,1); map.put(&quot;ms&quot;,100); &#125;else &#123; // builder.down(); builder.status(Status.OUT_OF_SERVICE); map.put(&quot;err&quot;,&quot;连接超时&quot;); map.put(&quot;ms&quot;,3000); &#125; builder.withDetail(&quot;code&quot;,100) .withDetails(map); &#125;&#125; 访问：localhost:8080&#x2F;actuator&#x2F;health 会返回的所有health信息，包括Myhealth。 2、定制info信息 常用两种方式： 1、编写核心配置文件 123456info: appName: MyAdmin version: 1.0.0 #使用@@可以获取maven的pom文件值 mavenProjectName: @project.artifactId@ mavenProjectVersion: @project.version@ 2、编写InfoContributor监控点 123456789101112131415import java.util.Collections;import org.springframework.boot.actuate.info.Info;import org.springframework.boot.actuate.info.InfoContributor;import org.springframework.stereotype.Component;@Componentpublic class ExampleInfoContributor implements InfoContributor &#123; @Override public void contribute(Info.Builder builder) &#123; builder.withDetail(&quot;example&quot;, Collections.singletonMap(&quot;key&quot;, &quot;value&quot;)) .withDetail(&quot;hello&quot;,&quot;world&quot;); &#125;&#125; 访问：localhost:8080&#x2F;actuator&#x2F;info 会输出以上方式返回的所有info信息。 3、定制Metrics信息 SpringBoot支持自动适配的Metrics。 增加定制Metrics： 12345678910111213141516class MyService&#123; Counter counter; public MyService(MeterRegistry meterRegistry)&#123; //通过Registry注册metrics指标 counter = meterRegistry.counter(&quot;myservice.hello.count&quot;); &#125; public void hello()&#123; //记录hello方法调用次数 counter.increment(); &#125;&#125;//也可以使用下面的方式@BeanMeterBinder queueSize(Queue queue) &#123; return (registry) -&gt; Gauge.builder(&quot;queueSize&quot;, queue::size).register(registry);&#125; 访问：localhost:8080&#x2F;actuator&#x2F;metrics&#x2F;myservice.hello.count，会输出该监控指标信息。 4、自定义Endpoint 使用@EndPoint注解，属性id为EndPointName。 123456789101112@Component@Endpoint(id = &quot;EPname&quot;)public class DockerEndpoint &#123; @ReadOperation public Map getDockerInfo()&#123; return Collections.singletonMap(&quot;info&quot;,&quot;docker started...&quot;); &#125; @WriteOperation private void stopDocker()&#123; System.out.println(&quot;docker stopped....&quot;); &#125;&#125; 访问：localhost:8080&#x2F;actuator&#x2F;EPname 获取以上信息。 开发ReadinessEndpoint来管理程序是否就绪，或者LivenessEndpoint来管理程序是否存活。 可视化应用监控服务引入springboot-admin-server依赖： 12345678910&lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-starter-server&lt;/artifactId&gt; &lt;version&gt;2.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-starter-client&lt;/artifactId&gt; &lt;version&gt;2.3.1&lt;/version&gt;&lt;/dependency&gt; 在主配置类上添加@EnableAdminServer注解开启admin监控，在核心配置文件中配置： 12345678910#admin访问地址spring.boot.admin.url=http://localhost:8080#应用以ip注册spring.boot.admin.instance.prefer-ip=true#应用名spring.application.name=hellomanagement.endpoints.enabled-by-default=true #暴露所有端点management.endpoints.web.exposure.include=*#以web方式暴露所有端点 高级特性与原理解析Profile功能为了方便多环境适配，springboot简化了profile功能。 1、application-profile功能 默认配置文件 application.yaml，任何时候都会加载。 指定环境配置文件： application-{env}.yaml，env可为test、prod。 激活指定环境并指定相关配置参数。 激活profile环境方式： 一、配置文件激活：spring.profiles.active=prod 二、命令行激活：java -jar xxx.jar --spring.profiles.active=prod --person.name=666 修改配置文件的任意值，命令行优先。 默认配置与环境配置同时生效。 同名配置项，profile配置优先。 2、@Profile条件装配功能 该注解使类或方法等在指定配置环境下生效。 12345@Configuration(proxyBeanMethods = false)@Profile(&quot;prod&quot;)//该类在生产环境下生效public class ProductionConfiguration &#123; // ...&#125; 3、profile分组 批量加载配置文件，互补配置，注意不要冲突。 1234spring.profiles.group.myprod[0]=prodspring.profiles.group.myprod[1]=testspring.profiles.active=myprod #激活 外部化配置1、外部配置源 常用：Java属性文件、YAML文件、环境变量、命令行参数 2、springboot配置文件查找位置 (1) classpath 根路径 (2) classpath 根路径下config目录 (3) jar包当前目录 (4) jar包当前目录的config目录 (5) &#x2F;config子目录的直接子目录 ​ 注：指定环境优先，外部优先，后面的可以覆盖前面的同名配置项 3、配置文件加载顺序 当前jar包内部的application.properties和application.yml 当前jar包内部的application-{profile}.properties 和 application-{profile}.yml 引用的外部jar包的application.properties和application.yml 引用的外部jar包的application-{profile}.properties 和 application-{profile}.yml springboot启动过程starter启动原理： autoconfigure包中配置使用 META-INF/spring.factories 中 EnableAutoConfiguration的值，使得项目启动加载指定的自动配置类。 编写自动配置类 xxxAutoConfiguration -&gt; xxxxProperties 1234@Configuration@Conditional@EnableConfigurationProperties@Bean 过程：引入starter —&gt;xxxAutoConfiguration —&gt; 容器中放入组件 —&gt; 绑定xxxProperties.java —&gt; 配置项 springboot应用启动过程： 创建 SpringApplication 保存一些信息。 判定当前应用的类型。 bootstrappers：初始启动引导器，去spring.factories文件中找 org.springframework.boot.Bootstrapper 找 ApplicationContextInitializer初始化器·，去spring.factories找 ApplicationContextInitializer。 找 ApplicationListener应用监听器(事件通知)，去spring.factories找ApplicationListener。 运行 SpringApplication StopWatch监控应用启停。 记录应用的启动时间。 创建引导上下文（Context环境）createBootstrapContext()，获取到所有之前的 bootstrappers 挨个执行 intitialize() 来完成对引导启动器上下文环境设置。 让当前应用进入headless模式。 获取所有RunListener（运行监听器），getSpringFactoriesInstances 去spring.factories找 SpringApplicationRunListener。 遍历SpringApplicationRunListener调用 starting 方法，相当于通知所有感兴趣系统正在启动过程的人，项目正在 starting。 保存命令行参数ApplicationArguments 准备环境 prepareEnvironment（） 返回或者创建基础环境信息对象StandardServletEnvironment 配置环境信息对象，读取所有的配置源的配置属性值 绑定环境信息 监听器调用listener.environmentPrepared()通知所有的监听器当前环境准备完成 创建IOC容器createApplicationContext 根据项目类型（Servlet）创建容器 当前会创建AnnotationConfigServletWebServerApplicationContext 准备ApplicationContext IOC容器的基本信息 prepareContext() 保存环境信息 IOC容器的后置处理流程 应用初始化器applyInitializers 遍历所有的 ApplicationContextInitializer，调用 initialize.来对ioc容器进行初始化扩展功能 遍历所有的 listener 调用 contextPrepared，EventPublishRunListenr，通知所有的监听器contextPrepared 所有的监听器 调用 contextLoaded，通知所有的监听器 contextLoaded。 刷新IOC容器refreshContext，创建容器中的所有组件 容器刷新完成后工作afterRefresh 所有监听器调用 listeners.started(context)，通知所有的监听器started 调用所有runners，callRunners() 获取容器中的ApplicationRunner 获取容器中的 CommandLineRunner 合并所有runner并且按照@Order进行排序 遍历所有的runner，调用 run 方法 如果以上有异常，调用Listener 的 failed方法。 调用所有监听器的 running 方法listeners.running(context)，通知所有的监听器应用运行中 running如果有问题，继续通知 failed ，调用所有 Listener 的 failed，通知所有的监听器 failed","categories":[{"name":"java","slug":"java","permalink":"https://aachou.github.io/categories/java/"}],"tags":[],"author":"沧海一粟"},{"title":"Spring入门","slug":"spring","date":"2023-12-31T10:16:09.000Z","updated":"2024-01-01T10:07:48.000Z","comments":true,"path":"2023/1231/","permalink":"https://aachou.github.io/2023/1231/","excerpt":"Spring是一个开放源代码的JavaEE设计层面框架，解决了业务逻辑层和其他各层的松耦合问题，因此它将面向接口的编程思想贯穿整个系统应用，它的核心是IOC控制反转和AOP面向切面编程","text":"Spring是一个开放源代码的JavaEE设计层面框架，解决了业务逻辑层和其他各层的松耦合问题，因此它将面向接口的编程思想贯穿整个系统应用，它的核心是IOC控制反转和AOP面向切面编程。 七大模块：core、aop、orm、dao、web、context、web mvc。 IOC控制反转，面向对象的设计原则，用来降低代码之间的耦合度。它有一种Bean对象容器，帮我们创建、管理、装配对象，即bean管理。 原理：xml解析、工厂模式、反射 提供IOC容器的接口：BeanFactory、ApplicationContext(加载配置文件时创建对象)。 ApplicationContext接口实现类：FileSystemXmlApplicationContext、ClassPathXmlApplicationContext。 实现IOC的方法：依赖注入。 bean管理：创建对象、注入属性(装配)。 bean管理的两种方式：xml配置、注解。 两种Bean：普通bean、工厂bean。 bean的作用域：singleton单例（默认）、prototype原型、request、session、application。 123&lt;bean id=&quot;user&quot; class=&quot;com.xx.xxx.user&quot; scope=&quot;propotype&quot;&gt;&lt;!--原型，调用getBean方法时创建不同的对象--&gt;&lt;/bean&gt; Bean的生命周期： 123451.执行无参构造创建bean2.调用set方法设置属性值3.执行初始化方法(postProcess)4.获取bean实例5.调用销毁方法销毁 xml配置创建对象配置文件中配置bean。 &lt;bean id=&quot;user&quot; class=&quot;com.xx.xxx.user&quot; name=&quot;别名&quot;&gt; id：唯一标识 class：全类名 默认通过无参构造创建对象。 有参构造创建：1）通过对象构造器参数下标 2）通过参数名 3）通过参数类型 1234567&lt;bean id=&quot;user&quot; class=&quot;com.xx.xxx.user&quot;&gt; &lt;!--第一个参数设值--&gt; &lt;constructor-arg index=&quot;0&quot; value=&quot;xx&quot;&gt; &lt;!--通过参数名设值--&gt; &lt;constructor-arg name=&quot;xx&quot; value=&quot;xx&quot;&gt; &lt;constructor-arg type=&quot;int&quot; value=&quot;xx&quot;&gt;&lt;/bean&gt; xml配置注入属性1）set方法。 2）配置文件中配置属性注入。 属性注入方式：property标签 、collection集合、p命名空间 、c命名空间。 （1）property配置： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;bean id=&quot;user&quot; class=&quot;com.xx.xxx.user&quot; name=&quot;别名&quot;&gt; &lt;!--属性名，值--&gt; &lt;property name=&quot;xxx&quot; value=&quot;xxx&quot;/&gt; &lt;!--null注入--&gt; &lt;property name=&quot;xxx&quot;&gt; &lt;null/&gt; &lt;/property&gt; &lt;!--特殊符号注入--&gt; &lt;!--转义或CDATA--&gt; &lt;property name=&quot;xxx&quot;&gt; &lt;value&gt;&lt;![CDATA[&lt;&lt;年龄&gt;&gt;]]&gt;&lt;/value&gt; &lt;/property&gt; &lt;!--外部Bean注入，ref指向哪个bean--&gt; &lt;!--类中需定义对象属性，set方法--&gt; &lt;property name=&quot;xxx&quot; ref=&quot;xxx&quot;/&gt; &lt;!--内部Bean注入(对象注入)--&gt; &lt;property name=&quot;xxx&quot;&gt; &lt;bean id=&quot;dept&quot; class=&quot;com.xx.xx.Dept&quot;&gt; &lt;property name=&quot;dname&quot; value=&quot;xx&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/property&gt;&lt;!--通过级联赋值，对多个对象属性赋值，需要设置对象属性的get方法--&gt; &lt;!--&lt;property name=&quot;dept.dname&quot; value=&quot;xx&quot;/&gt;--&gt; &lt;!--数组注入--&gt; &lt;property name=&quot;xxx&quot;&gt; &lt;array&gt; &lt;value&gt;1&lt;/value&gt; &lt;value&gt;2&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;!--map注入--&gt; &lt;property name=&quot;xxx&quot;&gt; &lt;map&gt; &lt;entry key=&quot;x&quot; value=&quot;x&quot;&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;!--list类型注入--&gt; &lt;property name=&quot;xxx&quot;&gt; &lt;list&gt; &lt;value&gt;1&lt;/value&gt; &lt;value&gt;2&lt;/value&gt; &lt;!--list中存对象&lt;ref bean=&quot;外部bean对象&quot;&gt;&lt;/ref&gt;--&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 测试获取bean对象： 12ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);xxx x = (xxx)context.getBean(&quot;xxx&quot;); （2）p命名空间注入 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xmlns:p=&quot;http://www.springframework.org/schema/p&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/beanshttps://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;bean id=&quot;user&quot; class=&quot;com.xx.xx.user&quot; p:name=&quot;xx&quot; p:age=&quot;12&quot;/&gt;&lt;/beans&gt; （3）c命名空间注入 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xmlns:c=&quot;http://www.springframework.org/schema/c&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/beanshttps://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;!--constructor构造器参数注入--&gt;&lt;!--需要有参构造--&gt;&lt;bean id=&quot;user&quot; class=&quot;com.xx.xx.user&quot; c:name=&quot;xx&quot; c:age=&quot;12&quot;/&gt;&lt;/beans&gt; （4）公共集合属性提取 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xmlns:util=&quot;http://www.springframework.org/schema/util&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/beanshttps://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/utilhttps://www.springframework.org/schema/util/spring-util.xsd&quot;&gt; &lt;util:list id=&quot;booklist&quot;&gt; &lt;value&gt;xxx&lt;/value&gt; &lt;/util:util&gt; &lt;bean id=&quot;book&quot; class=&quot;com.xx.xx.book&quot;&gt; &lt;property name=&quot;list&quot; ref=&quot;booklist&quot;&gt;&lt;/property&gt; &lt;/beans&gt;&lt;/beans&gt; 自动装配spring根据属性名称和属性类型自动将bean的属性值注入。 byName：默认，在容器中寻找set方法中对应的Beand的id，id唯一。 byType：寻找和自己属性类型相同的对象，class唯一。 1234&lt;bean id=&quot;pet&quot; class=&quot;com.xx.xx.pet&quot;/&gt;&lt;bean id=&quot;people&quot; class=&quot;com.xx.xxx.user&quot; autowire=&quot;byName&quot;&gt; &lt;!--&lt;property name=&quot;name&quot; ref=&quot;pet&quot;/&gt;--&gt;&lt;/bean&gt; 引入外部属性文件引入数据库连接池配置 1、引入依赖 2、配置context命名空间 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xmlns:context=&quot;http://www.springframework.org/schema/context&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/beanshttps://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; 3、引入外部文件jdbc.properties 1&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; 4、配置连接池 123456&lt;bean id=&quot;dbs&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; autowire=&quot;byName&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;prop.driverClass&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;prop.url&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;prop.userName&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;prop.password&#125;&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 注解创建对象bean管理中使用注解创建对象，在要放入spring容器的对象上加上@Component注解，按照mvc架构，它的衍生注解有@Repository、@Service、@Controller，属性值设置使用@Value（相当于property配置）。 1)引入aop依赖。 2）添加context命名空间，开启注解扫描。 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xmlns:context=&quot;http://www.springframework.org/schema/context&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/beanshttps://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;&lt;context:component-scan base-package=&quot;com.xxx&quot;/&gt;&lt;/beans&gt; 3）在类上添加相关的bean注解，@Component(value=&quot;xx&quot;) 默认beanid为类名，首字母小写。value值设置beanid。 其他注解： @Nullable，在方法上表示返回值可以为空；用在方法的参数上表示参数可空；用在属性上表示属性可为空。 @Scope : 设置作用域。@Scope(“singleton”):单例模式。 @Configuration : 代表这是一个配置类，就像我们之前看的beans.xml。配合@Bean使用将实体类注册，本质是一个@Component。 @Bean : 注册一个bean，就相当于我们之前写的一个bean标签;这个方法的名字，就相当于bean标签中的id属性;这个方法的返回值，就相当于bean标签中的class属性。 @Import : @Import(XXX.class)可以引入其他配置类，使其合并为一个总配置类，使用时通过AnnotationConfig上下文来获取总配置类即可。 @Data : Lombok中的注解,放在实体类上会自己创建set和get方法，toString方法等。 自定义扫描哪些注解: 123&lt;context:component-scan base-package=&quot;com.xxx&quot; use-default-filter=&quot;false&quot;&gt;&lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;&gt;&lt;/context&gt;&lt;/context:component-scan&gt; 注解注入属性常用注解：Autowired、Qualifier、Resource、Value(普通类型注入)。 1）添加context命名约束 2）开启注解配置 12&lt;context:component-scan base-package=&quot;com.xxx&quot;/&gt;&lt;context:annotation-config/&gt; 3）添加@Autowired，根据属性类型实现自动装配 通过属性名称完成属性装配，使用@Qualifier(value=&quot;xxx&quot;)注解指定bean对象。@Resource注解也可以完成自动装配，通过beanid和class类型寻找匹配，名称注入通过name。@Value注解对基本数据类型进行注入。 @Autowired与@Resource的不同 1）来源不同@Autowired是Spring定义的注解，而@Resource是JSR-250定义的注解。 2）参数不同@Autowired只包含一个参数：required，表示是否开启自动准入，默认是true。而@Resource包含七个参数，其中最重要的两个参数是：name 和 type。@Autowired如果要使用byName，需要使用@Qualifier一起配合。而@Resource如果指定了name，则用byName自动装配，如果指定了type，则用byType自动装配。 3）使用不同@Autowired能够用在：构造器、方法、参数、成员变量和注解上，而@Resource能用在：类、成员变量和方法上。 4）装配顺序@Autowired默认按byType自动装配，而@Resource默认byName自动装配。 完全注解开发 Config配置类代替xml文件实现自动装配，实际使用springboot也能完成类似操作。 123import org.springframework.context.annotation.Beanimport org.springframework.context.annotation.Configurationimport org.springframework.context.annotation.ComponentScan 在一个类上加上注解@Configuration 代表这是一个配置类，配置类中加上@ComponentScan注解，扫描要注入的bean对象包，替代xml配置文件。 1ApplicationContext context = new AnnotationConfigApplicationContext(config.class); AOP面向切面编程，通过预编译方式和动态代理实现程序功能统一维护的一种技术。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 动态代理分为两大类：基于接口的动态代理，基于类的动态代理 基于接口 : JDK动态代理 基于类 : cglib 通过反射实现 专业术语： 横切关注点：跨越应用程序多个模块的方法和功能，如日志、安全、缓存、事务。切面aspect：增强的过程，被模块化的特殊对象，它是一个类。通知advice：需要增强的代码逻辑部分。切入点pointcut：实际增强的方法，必须定义。连接点jointpoint：可增强的方法。目标target：被通知的对象。代理proxy：向目标对象通知后创建的对象。 使用AOP需要导入一个依赖包 : 123456&lt;!--https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.4&lt;/version&gt;&lt;/dependency&gt; 方式一 : 通过JDK接口实现创建UserService接口和实现类UserServiceImpl，创建实现类的代理对象，并实现aop切入实现，注意导入约束。 通过Proxy的newProxyInstance方法创建代理对象。 12345678910111213141516import java.lang.reflect.Proxy;import java.lang.reflect.Method;import java.lang.reflect.InvocationHandler;public class MyProxy&#123; public static void main(String[] args)&#123; Class[] interfaces = &#123;UserService.class&#125;; UserSerivce us = (UserService)Proxy.newProxyInstance(MyProxy.class.getClassLoader(),interfaces,new InvocationHandler()&#123; @Override public Object invoke(Object proxy,Method method, Object[] args) throws Throwable&#123; return null; &#125; &#125;) &#125;&#125; 方式二 : 通过AspectJ实现AOPAspectJ是一个独立的AOP框架，结合spring实现aop操作。需要引入aop、aspectj、cglib、aopalliance依赖。 切入点表达式： execution([权限修饰符] [返回类型] [全类名] [方法名] ([参数列表])) 例：expression=&quot;execution(* com.xxx.xx.UserServiceImpl.*(..)) （1）xml方式实现： 1）创建类及其增强类(代理对象类) 2）添加aop命名空间 3）xml中配置切入点 定义类： 12345public class book &#123; public void buy()&#123; System.out.println(&quot;---buy-----&quot;); &#125; &#125; 定义增强类： 12345678public class Proxy &#123; public void before()&#123; System.out.println(&quot;----方法执行前------&quot;); &#125; public void after()&#123; System.out.println(&quot;----方法执行后------&quot;); &#125;&#125; 4）在Spring配置中增强(切入) 123456789101112131415&lt;!--创建两个类的对象--&gt;&lt;bean id=&quot;book&quot; class=&quot;com.xx.config.book&quot;/&gt;&lt;bean id=&quot;Proxy&quot; class=&quot;com.xx.config.Proxy&quot;/&gt;&lt;!--aop的配置--&gt;&lt;aop:config&gt; &lt;!--切入点--&gt; &lt;aop:pointcut id=&quot;P&quot; expression=&quot;execution(* com.xx.config.book.buy(..))&quot;/&gt;&lt;!--切面,增强类--&gt;&lt;aop:aspect ref=&quot;Proxy&quot;&gt; &lt;!--advice增强方法--&gt; &lt;aop:before pointcut-ref=&quot;p&quot; method=&quot;before&quot;/&gt; &lt;aop:after pointcut-ref=&quot;p&quot; method=&quot;after&quot;/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; （2）注解方式实现： @Aspect注解表示该类为为增强类或代理对象类。 1）创建类及其增强类(代理对象类) 2）添加aop命名空间 3）开启注解扫描和生成代理对象 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xmlns:context=&quot;http://www.springframework.org/schema/context&quot;xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;xsi:schemaLocation=&quot; http://www.springframework.org/schema/beanshttps://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsdhttp://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;&lt;context:component-scan base-package=&quot;com.xxx&quot;/&gt;&lt;bean id=&quot;annotationProxy&quot; class=&quot;com.xxx.config.AnnotationProxy&quot;/&gt;&lt;!--开启aspectj代理对象生成--&gt;&lt;aop:aspectj-autoproxy/&gt;&lt;/beans&gt; aop:aspectj-autoproxy有一个proxy-target-class属性，默认为false，默认使用jdk动态代理。当为true，表示使用CGLib动态代理。不过即使proxy-target-class设置为false，如果目标类没有声明接口，则spring将自动使用CGLib动态代理。 注：@EnableAspectJAutoProxy注解可以实现代理对象生成，效果一样。 4）使用注解创建类及增强类的对象 使用注解配置不同类型的advice通知（增强逻辑）。 1234567891011121314151617181920212223@Aspectpublic class AnnotationProxy&#123; @Before( &quot;execution(* com.x.service.UserServiceImpl.*(..))&quot;) public void before()&#123; System.out.println(&quot;------方法执行前------&quot;); &#125; @After( &quot;execution(* com.x.service.UserServiceImpl.*(..))&quot;) public void after()&#123; System.out.println(&quot;-----方法执行后-------&quot;); &#125; @Around( &quot;execution(* com.x.service.UserServiceImpl.*(..))&quot;) public void around(ProceedingJoinPoint jp) throws Throwable &#123; System.out.println(&quot;环绕前&quot;); System.out.println(&quot;签名:&quot;+jp.getSignature()); //执行目标方法proceed Object proceed = jp.proceed(); System.out.println(&quot;环绕后&quot;); System.out.println(proceed); &#125;&#125; 五种advice通知(增强)类型： @Before前置通知。 @Around环绕通知 @After最终通知 @AfterRetuning后置通知 @AfterThrowing异常通知 123456环绕之前...before...目标方法执行...环绕之后...after...afterReturning... 提取公共切入点：定义一个方法，添加注解@Pointcut(value=&quot;切入点表达式&quot;)，在advice注解设置value值为方法名()。当有多个增强类对同一切入点增强，使用@Order()注解设置增强类优先级。 JdbcTemplate它是spring对jdbc的封装。 1）导入mysql、druid、jdbc、tx、orm依赖包。 2）配置数据库连接池 在引入外部文件中已经配置过。 3）配置JdbcTemplate对象 123&lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt; 4）开启注解扫描，在dao层注入jdbcTemplate对象 Spring事务管理Spring在不同的事务管理API之上定义了一个抽象层，使得开发人员不必了解底层的事务管理器API。Spring的声明事务管理底层原理使用aop。 Spring支持编程式事务管理和声明式的事务管理。声明式的事务管理有两种实现方式：注解和xml配置。 注解方式 1）使用Spring管理事务，导入tx事务依赖，命名空间导入 : tx。 12345678910111213&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xmlns:context=&quot;http://www.springframework.org/schema/context&quot;xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;xsi:schemaLocation=&quot; http://www.springframework.org/schema/beanshttps://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsdhttp://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsdhttp://www.springframework.org/schema/txhttp://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; 2）创建事务管理器 123&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;&lt;/bean&gt; 3）开启事务注解 12&lt;tx:annotation-driven transaction-manager = &quot;transactionManager&quot;/&gt; 4）在service类上添加事务注解 @Transactional，添加在类上，类中方法开启事务。spring定义了7种事务传播行为。 xml方式 1）配置事务管理器 2）配置事务通知 123456789101112&lt;!--配置事务通知--&gt;&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;!--配置哪些方法使用什么样的事务,配置事务的传播特性--&gt; &lt;tx:method name=&quot;add&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;delete&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;update&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;search*&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;!--该方法只读，无法对数据库进行操作--&gt; &lt;tx:method name=&quot;get&quot; read-only=&quot;true&quot;/&gt; &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt; 3）配置aop，切入点、切面 1234567&lt;!--配置aop事务--&gt;&lt;aop:config&gt; &lt;aop:pointcut id=&quot;txPointcut&quot; expression=&quot;execution(* com.x.dao.*.*(..))&quot;/&gt; &lt;!--配置切面--&gt;&lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPointcut&quot;/&gt;&lt;/aop:config&gt; 完全注解开发 使用@Configuration、@ComponentScan、@EnableTransactionManager、@Bean注解完成事务。创建数据库连接池，事务管理器，jdbcTemplate。 整合Mybatis编写实体类 12345public class User &#123; private int id; private String name; private String pwd; &#125; 编写mybatis-config核心配置文件 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;typeAliases&gt; &lt;package name=&quot;com.x.pojo&quot;/&gt; &lt;/typeAliases&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;package name=&quot;com.x.dao&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 编写UserDao接口 123public interface UserMapper &#123; public List&lt;User&gt; selectUser();&#125; 编写接口对应的Mapper映射文件 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.xxx.dao.UserMapper&quot;&gt; &lt;select id=&quot;selectUser&quot; resultType=&quot;User&quot;&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; 导入spring-webmvc、spring-jdbc、mybatis、mybatis-spring、mysql-connector-java、aspectjweaver包。 配置Maven静态资源过滤问题： 123456789101112&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; Mybatis-Spring MyBatis-Spring 会帮助你将 MyBatis 代码无缝地整合到 Spring 中。它将允许 MyBatis 参与到 Spring 的事务管理之中，创建映射器 mapper 和 SqlSession 并注入到 bean 中，以及将 Mybatis 的异常转换为 Spring 的 DataAccessException。最终，可以做到应用代码不依赖于 MyBatis，Spring 或 MyBatis-Spring。 在 MyBatis-Spring 中，可使用SqlSessionFactoryBean来创建 SqlSessionFactory。要配置这个工厂 bean，只需要把下面代码放在 Spring 的 XML 配置文件中： 123&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;&lt;/bean&gt; 实现一引入Spring配置文件beans.xml 123&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;/beans&gt; 配置数据源替换mybatis数据源 1234567&lt;!--配置数据源：可以用第三方的，也可用Spring的--&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;&lt;/bean&gt; 配置SqlSessionFactory，关联Mybatis 1234567&lt;!--配置SqlSessionFactory--&gt;&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;!--关联Mybatis--&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:com/kuang/dao/*.xml&quot;/&gt;&lt;/bean&gt; 注册sqlSessionTemplate，关联sqlSessionFactory 12345&lt;!--注册sqlSessionTemplate , 关联sqlSessionFactory--&gt;&lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt; &lt;!--利用构造器注入--&gt; &lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot;/&gt;&lt;/bean&gt; 增加Dao接口的实现类；私有化sqlSessionTemplate 1234567891011public class UserDaoImpl implements UserMapper &#123; //sqlSession不用我们自己创建了，Spring来管理 private SqlSessionTemplate sqlSession; public void setSqlSession(SqlSessionTemplate sqlSession) &#123; this.sqlSession = sqlSession; &#125; public List&lt;User&gt; selectUser() &#123; UserMapper mapper = sqlSession.getMapper(UserMapper.class); return mapper.selectUser(); &#125;&#125; 注册bean实现 123&lt;bean id=&quot;userDao&quot; class=&quot;com.x.dao.UserDaoImpl&quot;&gt; &lt;property name=&quot;sqlSession&quot; ref=&quot;sqlSession&quot;/&gt;&lt;/bean&gt; 当前Mybatis配置文件内容: 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;typeAliases&gt; &lt;package name=&quot;com.x.pojo&quot;/&gt; &lt;/typeAliases&gt;&lt;/configuration&gt; 测试 1234567@Testpublic void test2()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); UserMapper mapper = (UserMapper) context.getBean(&quot;userDao&quot;); List&lt;User&gt; user = mapper.selectUser(); System.out.println(user);&#125; 实现二dao继承Support类 , 直接利用 getSqlSession() 获得 , 然后直接注入SqlSessionFactory . 比起方式一 , 不需要管理SqlSessionTemplate , 而且对事务的支持更加友好。 将UserDaoImpl修改一下 12345public class UserDaoImpl extends SqlSessionDaoSupport implements UserMapper &#123; public List&lt;User&gt; selectUser() &#123; UserMapper mapper = getSqlSession().getMapper(UserMapper.class); return mapper.selectUser(); &#125;&#125; 修改bean的配置 123&lt;bean id=&quot;userDao&quot; class=&quot;com.xx.dao.UserDaoImpl&quot;&gt; &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot; /&gt;&lt;/bean&gt; WebFlux函数式编程spring5的新功能，类似springMVC，用于web开发，流行的异步非阻塞的响应式编程框架，基于Reactor的api实现。","categories":[{"name":"java","slug":"java","permalink":"https://aachou.github.io/categories/java/"}],"tags":[],"author":"沧海一粟"},{"title":"mybatisplus入门","slug":"mybatisplus入门","date":"2023-12-25T07:11:52.000Z","updated":"2023-12-31T10:25:08.000Z","comments":true,"path":"2023/1225/","permalink":"https://aachou.github.io/2023/1225/","excerpt":"Mybatis是一种关系型数据库的ORM持久化框架，封装了JDBC和sqlmap，使java代码和DAO分离，提高了开发效率。","text":"Mybatis是一种关系型数据库的ORM持久化框架，封装了JDBC和sqlmap，使java代码和DAO分离，提高了开发效率。 Mybatis和Hibernate对比Hibernate和JPA：操作简便，开发效率高，不容易优化，反射操作太多影响性能。 Mybatis：轻量级，性能出色，开发效率稍低。 12345678910&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt;&lt;/dependency&gt; 在resource文件夹下创建mybatis-config.xml配置文件。 —–表—–实体类——mapper接口—–映射文件– java&#x3D;数据库概念关系：实体类&#x3D;表，类属性&#x3D;字段，对象&#x3D;记录&#x2F;行，保持一致。xml映射文件的namespace命名域需要与mapper接口的全类名一致，sql语句的id要与mapper接口中的方法名一致。通过调用接口的方法来执行对应sql语句！ mapper接口的名字和mapper映射文件的名字保存一致，所在包包名保存一致，最好为mapper。 mybatis提供一个操作数据库的对象SqlSession，通过SqlSession.getMap获取mapper接口实现类的对象。 12select * from user where username like &quot;%&quot;#&#123;username&#125;&quot;%&quot;;select * from user where username like &#x27;%$&#123;username&#125;%&#x27;; 在核心配置文件中mybaitis-plus配置： 1234567mybatis-plus:#控制台输出日志 configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl map-underscore-to-camel-case: true type-aliases-package: com.xxx.xxx.entity mapper-locations: classpath:mapper/*.xml 使用步骤： 1、导入依赖 2、配置依赖 3、创建pojo 4、继承BaseMapper，创建mapper接口。 5、在spring应用程序上添加@MapperScan(&quot;xxx&quot;)注解或在mapper接口上添加@Mapper注解。 6、在service层中继承实现类ServiceImpl&lt;BaseMapper, Object&gt;，实现自定义接口。 123@Servicepublic class ProductServiceImpl extends ServiceImpl&lt;ProductMapper, Product&gt;//业务层帮我们创建mapper对象 主键自增策略mysql默认插入数据主键自增，可以在数据库中查看。为了弥补数据库默认自增的不足，比如会出现单点故障。MyBatis-Plus默认的主键策略是：ASSIGN_ID （使用了雪花算法）。mybaitis-plus需要在实体类属性上加上主键自增注解@TableId(type=IdType.AUTO)。 1@TableId(value = &quot;product_id&quot;,type = IdType.AUTO) type: AUTO自增、ID_WORKER默认唯一id、UUID全局唯一id。 字段主键@TableField(exist = false) ：该字段在数据库中不存在。 自动填充和乐观锁自动填充项目中经常会遇到一些数据，每次都使用相同的方式填充，例如记录的创建时间，更新时间等。我们可以使用MyBatis Plus的自动填充功能，完成这些字段的赋值工作。 实体上增加字段并添加自动填充注解 123456@TableField(fill = FieldFill.INSERT)private Date createTime; //create_time@TableField(fill = FieldFill.INSERT_UPDATE)private Date updateTime; //update_time 实现元对象处理器接口 123456789101112@Componentpublic class MyMetaObjectHandler implements MetaObjectHandler &#123; //mp执行添加操作，这个方法执行 @Override public void insertFill(MetaObject metaObject) &#123; this.setFieldValByName(&quot;createTime&quot;,new Date(),metaObject); this.setFieldValByName(&quot;updateTime&quot;,new Date(),metaObject); &#125; //mp执行修改操作，这个方法执行 @Override public void updateFill(MetaObject metaObject) &#123; this.setFieldValByName(&quot;updateTime&quot;,new Date(),metaObject); &#125;&#125; 乐观锁当要更新一条记录的时候，希望这条记录没有被别人更新，也就是说实现线程安全的数据更新。 取出记录时，获取当前version更新时，带上这个version执行更新时， set version 修改实体类，添加@Version注解 12@Versionprivate Integer version; 创建包config，创建文件MybatisPlusConfig.java， 此时可以删除主类中的 @MapperScan扫描注解。 1234567@Configuration@MapperScan(&quot;com.xxx.mapper&quot;)public class MpConfig &#123; @Bean public OptimisticLockerInterceptor optimisticLockerInterceptor() &#123; return new OptimisticLockerInterceptor(); &#125; &#125; ${}和#{}获取参数值字段名和属性名一致：ResultType 字段名和属性名不一致：给字段起别名，别名为属性名；在mybatis中配置驼峰命名map-underscore-to-camel-case: true；定义一个resultMap，通过property和column字段绑定 一对多collection集合 1234567891011&lt;resultMap id=&quot;DeptAndEmpResultMap&quot; type=&quot;Dept&quot; autoMapping=&quot;true&quot;&gt; &lt;id column=&quot;dept_id&quot; property=&quot;deptId&quot;/&gt; &lt;!--属性emps集合中元素的类型--&gt; &lt;collection property=&quot;emps&quot; ofType=&quot;Emp&quot;&gt; &lt;id property=&quot;eid&quot; column=&quot;eid&quot;&gt;&lt;/id&gt; &lt;result property=&quot;empName&quot; column=&quot;emp_name&quot;&gt;&lt;/result&gt; &lt;result property=&quot;age&quot; column=&quot;age&quot;&gt;&lt;/result&gt; &lt;result property=&quot;sex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt; &lt;result property=&quot;email&quot; column=&quot;email&quot;&gt;&lt;/result&gt; &lt;/collection&gt;&lt;/resultMap&gt; 分步查询： select：设置分步查询的唯一标识，mapper接口的全类名和方法名。 column：查询的字段。 ofType：查询中的集合内的数据类型。 多对一映射resultMap级联属性赋值; &lt;association&gt;标签； 1234567&lt;resultMap id=&quot;MinMap&quot; type=&quot;Moneyin&quot; autoMapping=&quot;true&quot;&gt; &lt;id column=&quot;in_id&quot; property=&quot;inId&quot;/&gt; &lt;!--将查询出的账户的列数据和账户实体映射起来--&gt; &lt;association property=&quot;zhanghu&quot; javaType=&quot;Zhanghu&quot; autoMapping=&quot;true&quot;&gt;&lt;/association&gt; &lt;!--将查询出的收入分类的列数据和收入分类实体映射起来--&gt; &lt;association property=&quot;categoryin&quot; javaType=&quot;Categoryin&quot; autoMapping=&quot;true&quot;&gt;&lt;/association&gt;&lt;/resultMap&gt; 分步查询 优点：实现了延迟加载，避免执行过多的sql语句。配置文件配置如下： 123lazyLoadingEnabled=true#开启时所有关联对象都延迟加载aggressiveLazyLoading=false 当开启全局延迟加载后，查询可通过fetchType属性实现eager立即加载或lazy延迟加载。 动态SQL尽管mybaitis-plus帮我们省去了动态sql的编写，但仍必要了解什么是动态sql。 本质：标签 作用：动态拼接sql语句 if标签 1234567891011121314&lt;select id=&quot;getEmp&quot; resultMap=&quot;Emp&quot; &gt; select * from t_emp where 1=1 &lt;if test=&quot;ename!=null and ename!=&#x27;&#x27;&quot;&gt; ename = #&#123;ename&#125; &lt;/if&gt; &lt;if test=&quot;age!=null and age!=&#x27;&#x27;&quot;&gt; and age = #&#123;age&#125; &lt;/if&gt; &lt;if test=&quot;email !=null and email!=&#x27;&#x27;&quot;&gt; and email = #&#123;email&#125; &lt;/if&gt; &lt;!--引用定义好的sql语句--&gt; &lt;!-- &lt;include refid=&quot;minSql&quot;&gt;&lt;/include&gt; --&gt;&lt;/select&gt; where标签 根据标签中的内容自动生成where关键字，并将条件内容前多余的and、or关键字去掉，后面的关键字无法忽略，如果没有内容则不会生成where。 trim标签 prefix|suffix，在标签内容的前后添加内容 choose、when标签 choose…when….otherwise &#x3D;switch….case… default foreach标签 ​ collection：需要循环的数组和集合 ​ item：表示数组和集合中的每一个元素 ​ separator：循环之间的分割符 ​批量删除 1234567&lt;delete id=&quot;deleteMore&quot;&gt; delete from t_emp where eid in( &lt;foreach collection=&quot;eids&quot; item=&quot;eid&quot; separator=&quot;,&quot;&gt; #&#123; eid &#125; &lt;/foreach&gt; )&lt;/delete&gt; ​批量增加 123456&lt;insert id=&quot;insertMore&quot;&gt; insert into t_emp values &lt;foreach collection=&quot;emps&quot; item=&quot;emp&quot; separator=&quot;,&quot;&gt; (null,#&#123; emp.empName &#125;,#&#123; emp.age &#125;,#&#123; emp.sex &#125;,#&#123; emp.email &#125;,null) &lt;/foreach&gt;&lt;/select&gt; sql标签 12345678910111213141516&lt;!--定义可以被复用的查询sql--&gt;&lt;sql id=&quot;minSql&quot;&gt; select mi.in_id, mi.single_in, mi.zhanghu_id, mi.categoryin_id, mi.date, mi.beizhu, z.zhanghu_name, z.zhanghu_money, z.create_time, cin.categoryin_name from moneyin mi join zhanghu z on mi.zhanghu_id=z.zhanghu_id join categoryin cin on mi.categoryin_id=cin.categoryin_id&lt;/sql&gt;&lt;!--引用定义好的sql语句--&gt;&lt;include refid=&quot;minSql&quot;&gt;&lt;/include&gt; 缓存针对查询，将数据暂时保存起来以备下一次查询。 cache hit ratio 一级缓存默认开启，sqlSession级别，对于同一的sqlSession的查询，会从缓存中取对象，如果是同一查询则能够成功取出对象，若两次查询之间进行了一次增删改操作则会失效(相当于清除缓存)，clearCache()手动清除缓存。 二级缓存sqlSeesionFactory级别，通过同一sqlSeesionFactory创建的sqlSeesion查询的结果会被缓存，此后再执行相同的查询就会从缓存中取。 二级缓存开启条件：在核心配置文件中配置cacheEnabled&#x3D;”true”；在映射文件中设置cache标签，在sqlSeesion关闭或提交后有效；查询的实体类型必须实现序列化接口。 查询顺序：先查二级缓存，没有命中再查一级缓存，最后查数据库 ，sqlSession关闭或提交后一级缓存保存到二级。 第三方缓存代替二级缓存。 1）添加依赖 123456789101112&lt;!--在pom.xml中添加--&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt; &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt; &lt;version&gt;1.2.11&lt;/version&gt;&lt;/dependency&gt;&lt;!--SLF4J是Simple Logging Facade for Java的简写，即Java简单日志门面，用来服务于各种各样的日志框架，比如java.util.logging、logback和log4j--&gt;&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt;&lt;/dependency&gt; 2）导入jar包 slf4j-api，mybatis-ehcache，ehcache，logback-classic。 3）配置第三方缓存配置文件ehchche.xml 4）设置二级缓存的类型 12&lt;!--在映射文件中添加--&gt;&lt;cache type=&quot;第三方缓存全类名&quot;&gt; pagehelper分页插件1、添加依赖 123456 &lt;!--分页--&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.4.3&lt;/version&gt;&lt;/dependency&gt; 2、在核心配置文件中添加插件配置 1234567#配置分页#pagehelperpagehelper: helper-dialect: mysql reasonable: true support-methods-arguments: true params: count=countSql 分页插件的使用： 1PageInfo&lt;Product&gt; listByPage(Integer page, Integer limit, String searchProductName); 12limit 0,10--limit 起始下标index,pageSize页大小 index当前页起始索引，pageSize每页显示条数，pageNum当前页码，total总记录数，pages页数，prePage上一页页码，nextPage下一页页码，navigatePages导航页码数，navigatepageNums导航分页页码。 123456789101112//使用PageHelper插件，设置分页参数PageHelper.startPage(page,limit);//构建查询条件包装器QueryWrapper qw = new QueryWrapper();if(!Objects.isNull(searchProductName)) &#123; qw.like(&quot;pro_name&quot;, searchProductName);&#125;//实现条件查询List products = this.list(qw);//使用分页对象封装查询结果PageInfo&lt;Product&gt; pi = new PageInfo&lt;&gt;(products);return pi; pageinfo对象： 12345PageInfo&#123;pageNum=1, pageSize=5, size=2, startRow=1, endRow=2, total=2, pages=1, list=Page&#123;count=true, pageNum=1, pageSize=5, startRow=0, endRow=5, total=2, pages=1, reasonable=true, pageSizeZero=false&#125;[ Product(productId=1, proName=股票, proMoney=1000.00, description=), Product(productId=2, proName=黄金, proMoney=1000.00, description=) ], prePage=0, nextPage=0, isFirstPage=true, isLastPage=true, hasPreviousPage=false, hasNextPage=false, navigatePages=8, navigateFirstPage=1, navigateLastPage=1, navigatepageNums=[1]&#125; 查询1）通过多个 id 批量查询 完成了动态sql的foreach的功能 1234567//多个id批量查询@Testpublic void testSelect1() &#123; List&lt;User&gt; users=userMapper.selectBatchIds( Arrays.asList(1, 2, 3)); System.out.println(users);&#125; 2）简单的条件查询 通过map封装查询条件 注意：map中的key对应数据库中的列名。如：数据库user_id，实体类是userId，这时map的key需要填写user_id 123456789//简单条件查询@Testpublic void testSelect2() &#123; Map&lt;String, Object&gt; columnMap = new HashMap&lt;&gt;(); columnMap.put(&quot;name&quot;,&quot;Jack&quot;); columnMap.put(&quot;age&quot;,20); List&lt;User&gt; users = userMapper.selectByMap(columnMap); System.out.println(users);&#125; PaginationInterceptor分页 MyBatis Plus自带分页插件，只要简单的配置即可实现分页功能。 添加分页插件 配置类中添加@Bean配置 123/** * 分页插件 */@Beanpublic PaginationInterceptor paginationInterceptor() &#123; return new PaginationInterceptor();&#125; 测试 selectPage 分页123456789101112131415161718192021222324//分页查询@Testpublic void testSelectPage() &#123; Page&lt;User&gt; page = new Page(1,3); Page&lt;User&gt; userPage = userMapper.selectPage(page, null); //返回对象得到分页所有数据 long pages = userPage.getPages(); //总页数 long current = userPage.getCurrent(); //当前页 List&lt;User&gt; records = userPage.getRecords(); //查询数据集合 long total = userPage.getTotal();//总记录数 boolean hasNext = userPage.hasNext(); //下一页 boolean hasPrevious = userPage.hasPrevious(); //上一页 System.out.println(pages); System.out.println(current); System.out.println(records); System.out.println(total); System.out.println(hasNext); System.out.println(hasPrevious); &#125; 测试 selecMapsPage 分页 当指定了特定的查询列时，希望分页结果列表只返回被查询的列，而不是很多null值。 测试selectMapsPage分页，结果集是Map 1234567891011121314@Testpublic void testSelectMapsPage() &#123;//Page不需要泛型Page&lt;Map&lt;String, Object&gt;&gt; page = newPage&lt;&gt;(1, 5);Page&lt;Map&lt;String, Object&gt;&gt; pageParam = userMapper.selectMapsPage(page, null);List&lt;Map&lt;String, Object&gt;&gt; records = pageParam.getRecords();records.forEach(System.out::println);System.out.println(pageParam.getCurrent());System.out.println(pageParam.getPages());System.out.println(pageParam.getSize());System.out.println(pageParam.getTotal());System.out.println(pageParam.hasNext());System.out.println(pageParam.hasPrevious());&#125; 性能分析插件性能分析拦截器，用于输出每条SQL语句及其执行时间，可以设置最大执行时间，超过时间会抛出异常，该插件只用于开发环境，不建议生产环境使用。在MP中提供了对SQL执行的分析的插件，可用作阻断全表更新、删除的操作。 注意：该插件仅适用于开发环境，不适用于生产环境。 1、配置springboot：SQL分析插件 12345678&lt;configuration&gt; &lt;plugins&gt; &lt;plugin interceptor=&quot;com.baomidou.mybatisplus.extension.plugins.PerformanceInterceptor&quot;&gt; &lt;property name=&quot;maxTime&quot; value=&quot;100&quot;/&gt; &lt;property name=&quot;format&quot; value=&quot;true&quot;/&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/configuration&gt; 2、测试 1234567@Testpublic void testSelectById()&#123; User user = new User(); user.setId(2L); User user1 = user.selectById(); System.out.println(user1);&#125; 条件构造器Wrapper ： 条件构造抽象类，最顶端父类 AbstractWrapper ： 用于查询条件封装，生成 sql 的 where 条件 QueryWrapper ： 查询条件封装 UpdateWrapper ： Update 条件封装 AbstractLambdaWrapper ： 使用Lambda 语法 LambdaQueryWrapper ：用于Lambda语法使用的查询Wrapper LambdaUpdateWrapper ： Lambda 更新封装Wrapper 123456789QueryWrapper&lt;user&gt; wrapper = new QueryWrapper&lt;&gt;();wrapper.notLike(&quot;name&quot;,&quot;e&quot;).likeRight(&quot;email&quot;,&quot;t&quot;);List&lt;Map&lt;String,Object&gt;&gt; maps=userMapper.selectMaps(wrapper);maps.forEach(System.out::println);//id排序QueryWrapper&lt;user&gt; wrapper = new QueryWrapper&lt;&gt;();wrapper.orderByDesc(&quot;id&quot;);List&lt;User&gt; users = userWrapper.selectList(wrapper);users.forEach(System.out::println); MBG逆向工程正向工程：先创建java实体类，框架负责根据实体类生成数据库表。 逆向工程：先创建数据库表，框架根据表生成java实体类，mapper接口和映射文件。 代码生成器1、依赖导入 12345&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;最新版本&lt;/version&gt;&lt;/dependency&gt; 2、引入相应包 123import com.baomidou.mybatisplus.generator.AutoGenerator;import com.baomidou.mybatisplus.generator.config. GlobalConfig 3、创建一个代码自动生成器对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950AutoGenerator mpg = new AutoGenerator();//全局配置GlobalConfig gc = new GlobalConfig();String projectPath = System.getProperty(&quot;user.dir&quot;);gc.setOutputDir(projectPath+&quot;/src/main/java&quot;);gc.setAuthor(&quot;xxx&quot;);gc.setFileOverride(false);gc.setOpen(false);gc.setServiceName(&quot;%sService&quot;);//去前缀Igc.getIdType(IdType.ID_WORKER);gc.setDateType(Date.ONLY_DATE);mpg.setGlobalConfig(gc);//设置数据源DataSourceConfig dsc = new DataSourceConfig();dsc.setUrl(&quot;jdbc:mysql://localhost:3306/xxx? useSSL=false&amp;useUnicode=utf8&quot;);dsc.setDriverName(&quot;com.mysql.cj.jdbc.Driver&quot;);dsc.setUsername(&quot;root&quot;);dsc.password(&quot;xxxxxx&quot;);dsc.setDbType(DbType.MYSQL);mpg.setDataSource(dsc);//java源码包PackageConfig pc = new PackageConfig();pc.setModuleName(&quot;xxx&quot;);pc.setParentName(&quot;com.xxx&quot;);pc.setEntity(&quot;entity&quot;);pc.setMapper(&quot;mapper&quot;);pc.setService(&quot;service&quot;);pc.setController(&quot;controller&quot;);mpg.setPackageInfo(pc);//设置策略StrateryConfig sc = new StrateryConfig();sc.setInclude(&quot;xxx&quot;,&quot;xxx&quot;,&quot;xxx&quot;);//要映射的表名sc.setNaming(NamingStratery.underline_to_camel);sc.setColumnNaming(NamingStratery.underline_to_camel);sc.setEntityLombokModel(true);//使用lomboksc.setLogicDeleteFieldName(&quot;deleted&quot;);//配置自动填充TableFill xxCreate = new TableFill(&quot;xx_create&quot;,FiledFill.INSERT);TableFill xxModified = new TableFill(&quot;xx_modified&quot;,FiledFill.INSERT);ArrayList&lt;TableFill&gt; tfs = new ArrayList&lt;&gt;();tfs.add(xxCreate);tfs.add(xxModified);sc.setTableFillList(tfs);//乐观锁sc.setVersionFieldName(&quot;version&quot;);sc.setRestControllerStyle(true);//rest风格//sc.setControllerMappingHyphenStyle(true);mpg.setStratery(sc);mpg.execute(); 注意：以上为旧版本，mybatis-plus-generator 3.5.1 及其以上版本对历史版本不兼容！3.5.1 以上的请参考 代码生成器新和相关配置。 目前支持两套生成的方式,一套使用SQL查询的方式是兼容旧的代码生成器核心逻辑使用,另一套使用驱动规范来读取元数据的方式,默认的使用元数据查询方式来生成代码, 123456789101112131415161718192021222324252627FastAutoGenerator.create(&quot;url&quot;, &quot;username&quot;, &quot;password&quot;) .globalConfig(builder -&gt; &#123; builder.author(&quot;xxx&quot;) // 设置作者 .enableSwagger() // 开启 swagger 模式 .fileOverride() // 覆盖已生成文件 .outputDir(&quot;D://&quot;); // 指定输出目录 &#125;) .dataSourceConfig(builder -&gt; builder.typeConvertHandler((globalConfig, typeRegistry, metaInfo) -&gt; &#123; int typeCode = metaInfo.getJdbcType().TYPE_CODE; if (typeCode == Types.SMALLINT) &#123; // 自定义类型转换 return DbColumnType.INTEGER; &#125; return typeRegistry.getColumnType(metaInfo); &#125;)) .packageConfig(builder -&gt; &#123; builder.parent(&quot;com.baomidou.mybatisplus.samples.generator&quot;) // 设置父包名 .moduleName(&quot;system&quot;) // 设置父包模块名 .pathInfo(Collections.singletonMap(OutputFile.xml, &quot;D://&quot;)); // 设置mapperXml生成路径 &#125;) .strategyConfig(builder -&gt; &#123; builder.addInclude(&quot;t_xxx&quot;) // 设置需要生成的表名 .addTablePrefix(&quot;t_&quot;, &quot;c_&quot;); // 设置过滤表前缀 &#125;) .templateEngine(new FreemarkerTemplateEngine()) // 使用Freemarker引擎模板，默认的是Velocity引擎模板 .execute();","categories":[{"name":"java","slug":"java","permalink":"https://aachou.github.io/categories/java/"}],"tags":[],"author":"沧海一粟"},{"title":"MySQL入门","slug":"Mysql入门","date":"2023-12-15T08:15:23.000Z","updated":"2023-12-15T08:12:21.000Z","comments":true,"path":"2023/1215/","permalink":"https://aachou.github.io/2023/1215/","excerpt":"本文介绍了什么是sql和nosql以及两者区别；介绍了mysql的特点、函数和SQL语句操作数据库；讲解了mysql事务及ACID原则和事务的4种隔离级别，索引的作用和原理；mysql的权限管理和数据备份恢复；数据库的设计和三大范式；SQL注入问题和避免；JDBC以及DBCP连接池连接数据库。","text":"本文介绍了什么是sql和nosql以及两者区别；介绍了mysql的特点、函数和SQL语句操作数据库；讲解了mysql事务及ACID原则和事务的4种隔离级别，索引的作用和原理；mysql的权限管理和数据备份恢复；数据库的设计和三大范式；SQL注入问题和避免；JDBC以及DBCP连接池连接数据库。 sql与nosql关系型数据库SQL是使用关系模式组织数据的结构化数据库系统。 非关系型数据库（NoSQL）是一类用于存储和管理非结构化数据的数据库系统。 关系数据库和非关系数据库区别体现在三个方面：数据存储方式不同；扩展方式不同；对事务性的支持不同。具体可参考：区别 关系型数据库的实现：Mysql，SQLserver，Oracle等。 非关系数据库实现：Redis（键值对），Mongodb（文档型），hbase（列存储），neo4j（Graph图像）。 mysqlSQL语言的特点：高度非过程化、面向集合操作、可移植性强、简洁灵活、支持三级模式结构、ACID（原子性，一致性，隔离性，持久性）。 SQL语言支持三级模式结构，通过外模式对应视图、基本表对应存储文件，以及内模式对应存储文件的方式实现。 Mysql默认不支持中文，在my.ini中配置编码character-set-server=utf8或，编写sql代码时加上DEFAULT CHARSET=UTF8。Mysql默认localhost本地连接，root为最高权限用户，默认数据库引擎为Innodb（支持事务，行级锁，外键，但是占用空间大）。 注释：–，&#x2F;**&#x2F; 数据库数值类型：tinyint(1byte)、smallint(2byte)、int(4byte)、float(4byte)、double(8byte)、decimal、varchar(0-65535)、text文本串、null date：YYYY-MM-DD time: HH:mm:ss datetime：YYYY-MMM-DD HH:mm:ss timestamp：时间戳，1970到现在的毫秒数 文档：reference DDL定义数据定义语言（DDL）：create，drop，alter 创建数据库：create database 数据库名 切换数据库：USE DATABASE 修改表：alter table &#39;表名&#39; rename as xxx 增加字段：alter table &#39;表名&#39; add Phone INT(11) 修改字段：alter table &#39;表名&#39; modify Phone VARCHAR(11)； 修改字段名：alter table &#39;表名&#39; change Phone Phone1 INT(11) 删除字段：alter table &#39;表名&#39; drop Phone INT(11) 12345678--创建表---CREATE TABLE `categoryin`(categoryin_id INT(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;收入分类id&#x27;,categoryin_name VARCHAR(20) CHARACTER SET utf8 COMMENT &#x27;收入分类名&#x27;,PRIMARY KEY (categoryin_id))ENGINE=INNODB AUTO_INCREMENT=3 CHARACTER SET = utf8 COMMENT=&#x27;收入分类&#x27;; DML操作管理数据操作语言（DML）：insert , delete , update，truncate insert into 表名 (字段1,字段2) values(值1，值2); 12INSERT INTO `categoryin` VALUES (1,&#x27;工资&#x27;);INSERT INTO `categoryin` VALUES (2,&#x27;彩票&#x27;); update 表名 set &#39;字段1&#39;=&#39;值1&#39;,&#39;字段2&#39;=&#39;值2&#39; where id=xxx; where条件运算符：&#x3D;，!&#x3D;(&lt;&gt;)， &gt;，&lt;，between and，and，or。 delete from 表名 where [条件] 清空表（自增变量归0）：truncate table &#39;表名&#39; DQL查询数据查询语言（DQL）：select select 字段1,字段2 from 表名 as 别名 字段去重，select distinct &#39;字段&#39; from 表名 12345678--查询系统版本select version();--计算select 2*3;--查询变量select @@auto_increment_increment--函数select 函数 模糊查询： select 字段 from 表名 where xxx like &#39;a__&#39; select 字段 from 表名 where xxx like &#39;%a%&#39; select 字段 from 表名 where xxx in (xxx,xxx,xxx) select 字段 from 表名 where xxx is &#39;xxx&#39; 多表查询： 联接查询：join 表名 as 别名 on [条件] 123456789select mi.in_id, mi.single_in, mi.zhanghu_id, mi.categoryin_id, mi.date, mi.beizhu, z.zhanghu_name,z.zhanghu_money, z.create_time, cin.categoryin_name from moneyin as mi join zhanghu as z on mi.zhanghu_id=z.zhanghu_id join categoryin cin on mi.categoryin_id=cin.categoryin_id inner join：只返回两个表中联结字段相等的行。 left join：返回左表所有值，即使没有匹配(使用null填充)。 right join：返回右表所有值，即使没有匹配(使用null填充)。 注意顺序： where指定结果满足条件； group by按照哪个字段分组 ； having过滤分组满足的次要条件； order by排序； limit分页。 分页limit和排序order by: 12345--ASC升序--DESC降序where ....order by xxx desclimit 0,10--limit 起始下标,pageSize页大小 子查询： 在where ..(select …)中嵌套一个查询 123select sNamefrom Studentwhere sId in (select distinct sId from score where tId=(select tId from teacher where tName=&#x27;Alice&#x27;)) DCL控制数据控制语言（DCL）：grant，revoke 。 五个约束主键约束（唯一约束）（Primay Key Counstraint）：唯一性，非空性。 唯一约束（Unique Counstraint）：唯一性，可以空，但只能有一个。 检查约束 (Check Counstraint) 12alter table useradd constraint CK_Sex check (sex=&#x27;男&#x27; or sex=&#x27;女&#x27;) 默认约束 (Default Counstraint) 12alter table useradd constraint df_age default (&#x27;0&#x27;) for age 外键约束 (Foreign Key Counstraint) 函数usage: select [函数]; 常用函数： abs绝对值，floor向下取整，celling向上取整，rand产生0-1随机数，char_length字符串长度，concat拼接，sign符号函数，current_date当前日期，now当前时间，localtime本地时间，sysdate系统时间，md加密。 first：返回指定的字段中第一个记录的值； last：返回指定的字段中最后一个记录的值； len：返回文本字段中值的长度； 聚合函数(计算最大、最小、平均值)： count计数 123select count(字段或p-k) from stduent;--忽略nullselect count(*) from student;--不会忽略nullselect count(1) from student;--不忽略null，本质：计算行数 sum求和；avg求平均；max；min select sum(‘字段’) as 总和 from 表;select avg(‘字段’) as 平均 from 表;select max(‘字段’) as 最大 from 表;select min(‘字段’) as 最小 from 表; 12345678--查询不同课程的平均分&gt;80，最高分，最低分select subjectName,avg(studentResult) as 平均分,max(studentResult) as 最高分,min(studentResult) as 最低分 from result rinner join &#x27;subject&#x27; sub on r.&#x27;subjectNo&#x27;=sub.&#x27;subjectNo&#x27;--根据不同课程分组group by r.&#x27;subjectNo&#x27;having 平均分&gt;80 事务数据库事务(Transaction)：指由一个或多个数据库操作组成的逻辑单位。 mysql默认开启事务自动提交！ set autocommit=0;设置手动提交事务。 start transaction开启事务。 commit事务提交，事务一旦提交，数据将持久化，回滚也无法恢复。 rollback事务回滚。 事务原则ACID ACID（原子性，一致性，隔离性，持久性）。 原子性atomic：事务要么所有的操作都执行成功,要么所有的操作都不执行,保证数据库的一致性和完整性。 一致性consistency：事务完成后符合逻辑运算，数据前后状态要一致。 持久性durability：事务没有提交则数据恢复原状，事务提交则数据不可逆，不会因宕机外部因素丢失数据。 隔离性isolation：排除其他事务对本次事务的影响。 事务隔离级别 脏读：一个事务读取另一个事务未提交的数据。 不可重复读：一次事务内多次读取某行的数据不同。 虚读(幻读)：一次事务中读取了其他事务插入的数据。 4 种隔离级别：读未提交 (READ UNCOMMITTED)、读已提交 (READ COMMITTED)、可重复读 (REPEATABLE READ)、串行化 (SERIALIZABLE)。 隔离级别 脏读 不可重复读 幻读 读未提交 可能 可能 可能 读提交 不可能 可能 可能 可重复读 不可能 不可能 可能 串行化 不可能 不可能 不可能 索引索引定义：：Index是帮助MySQL高效获取数据的数据结构。索引作用：通过索引可以大大的提高数据库的检索速度，提高数据库的性能。 索引类型唯一索引unique：唯一，可重复(多个列都可以标识为unique) 主键索引primary：唯一，不可重复(一张表只能有一个)。定义表主键的时候，会自动创建主键索引。 常规索引key：默认 全文索引FullText：快速定位数据。 1234567--1、创建表时添加索引--2、alter alter table 表名 add Index_TYPE index &#x27;索引名&#x27;(&#x27;字段&#x27;);--3、create-- 索引名：id_表名_字段名create index 索引名 on 表(&#x27;字段&#x27;); 聚集索引clustered index：表中各行的物理顺序与键值的逻辑顺序相同，每个表只能有一个。在聚集索引中，表中各行的物理顺序与键值的逻辑（索引）顺序相同。表只能包含一个聚集索引。 非聚集索引：非聚集索引指定表的逻辑顺序，数据存储在一个位置，索引存储在另一个位置，索引中包含指向数据存储位置的指针。 一个表只能创建1个聚集索引，多个非聚集索引。设置某列为主键，该列就默认为聚集索引。 索引数据结构：InnoDB使用聚集索引，数据记录本身被存于一棵B+树的叶子节点上，同一个叶子节点内的各条数据记录按主键顺序存放。每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子，则开辟一个新的页（节点）。 权限与DCL数据库mysql中user表记录了root、mysql.sys、mysql.session等用户的操作权限、访问主机host（默认localhost，只能本地连接）和各自密码(加密)。其中，root用户为最高权限用户，只有root有grant授权权限。 创建用户：create user xxx identified by &#39;PASSWORD&#39;; 删除用户：drop user xxx; 修改密码：update user set password=&#39;123456&#39; where user=&#39;root&#39;; set password for root = password(&#39;123456&#39;); 修改当前用户密码：set password = password(&#39;123456&#39;); 重命名用户：rename user xxx to xx; 数据控制语言（DCL）：grant，revoke 。 授权：grant 某权限[all privileges] on 库.表 to 用户; 查看权限：show grants for xxx 特殊的show grants for root@localhost 撤销权限：revoke 权限[privileges] on 库.表(*.*) from 用户; 当出现1130-host “xxx” is not allowed to connetced to this Mysql错误提示，表示访问拒绝非本地连接，需要修改host为%，可执行以下步骤。 1234--1. use mysql;--2. update user set host=&#x27;%&#x27; where user=&#x27;root&#x27;;--3. flush privileges;/*在不重启mysql下使修改生效*/ 备份恢复备份 方式一、物理拷贝 直接将mysql中的data目录下的文件数据拷贝出去。 方式二、mysqldump命令 mysqldump -h 主机 -u 用户 -p 密码 数据库 表名&gt; 导出位置/xx.sql mysqldump -h 主机 -u 用户 -p 密码 数据库&gt; 导出位置/xx.sql 例：mysqldump -u root -p 123456 mydb &gt; /home/db.bak 方式三、sqlyog可视化导出转储 恢复 登录数据库，使用source命令导入备份的sql或bak数据。 source 备份文件 或未登录下 mysqldump -h 主机 -u 用户 -p 密码 数据库&lt; xx.sql 数据库设计良好的设计将节省内存，提高查询速度，便于系统开发。 注意点：表名命名清晰、表结构合理、表关系(实体关系)设计、字段命名规范(不要大小写，统一小写加下划线)、字段类型及长度、主键设计、数据库引擎使用(通常为innodb)、字符集规范utf8。 三大范式数据库三大范式包含： 第一范式(1NF)：属性不可分割，每一列都是不可分的原子数据项。 第二范式(2NF)：满足第一范式，且不存在部分依赖，每一列必须和主键相关。非码属性必须完全依赖于候选码。 第三范式(3NF)：满足第二范式，且不存在传递依赖，每一列必须和主键直接相关，不存在间接相关。任何非主属性不依赖于其它非主属性，即在2NF基础上消除传递依赖。 设计注意事项：关联性查询最好不要超过三张表，设计时应该考虑性能与规范的问题。 JDBCJava DataBase Connectivity（Java数据库连接），是 JavaEE 平台下的技术规范， 定义了在 Java 语言中连接数据库，执行数据库操作的标准 ，可以为多种关系数据库提供统一访问，其本质是sun公司制定的一套接口。 因为每一个数据库的底层实现原理都不一样，每一个数据库产品都有自己独特的实现原理！所以为了方便java的开发，制定一个统一的连接数据库的规范势在必行，这就是JDBC。只要数据库厂商面向JDBC编写驱动，就能让开发者使用JDBC方便地操作各种数据库。 其中，java.sql.*；javax.sql.*里定义了与数据库操作有关的接口和方法。mysql-connector-java-8.0.11.jar包是标准JDBC的驱动程序，用于连接数据库。JdbcUtils工具类封装加载驱动，获取连接，释放资源。 1234567891011121314151617181920212223//加载驱动，执行静态代码块Class.forName(&quot;com.mysql.jdbc.Driver&quot;);//url，数据库信息String url=&quot;jdbc:mysql://localhost:3360/数据库?useSSL=true&amp; characterEncoding=utf-8 &amp; serverTimezone=Asia/Shanghai&quot;;String user=&quot;root&quot;;String password=&quot;123456&quot;;//数据库连接对象Connection connection =DriverManager.getConnection(url,user,password);//定义statement对象Statement statement=connection.createStatement();String sql = &quot;select * from user&quot;;//定义结果集ResultSet resultSet = statement.executeQuery(sql);while(resultSet.next())&#123; System.ou.println(&quot;id=&quot;+resultSet.getObject(&quot;id&quot;));&#125;//释放连接resultSet.close();statement.close();connection.close();//jdbcUtils.release(connetcion,statement,resultSet); oracle数据库连接：jdbc:oracle:thin:@//&lt;host&gt;:&lt;port&gt;/&lt;SERVICE_NAME&gt; sid连接：jdbc:oracle:thin:@localhost:1521:sid JDBC参考资料 SQL注入问题指攻击者在查询信息的结尾上添加额外的SQL语句以实现非法操作，执行非授权的任意查询，实质是web应用对用户输入的数据合法性判断不严。 Statement 采取直接编译 SQL 语句的方式，扔给数据库去执行，而 PreparedStatement 则先将 SQL 语句预编译一遍，再填充参数，这样效率会高一些。 Statement对象可能进行字符串与变量的拼接，很容易进行 SQL 注入攻击。采用PreparedStatement访问数据库不仅能防止sql注入，还是预编译的，不用重新编译整个sql语句，效率高。此外执行查询语句得到的结果集是离线的，连接关闭后，仍然可以访问结果集。 注意：PreparedStatement防止sql注入实质是将传入的参数看作字符串处理。${}是拼接，#{}整体当做字符串处理。 1234567891011121314//删除表中id=1且name=admin的记录Class.forName(com.mysql.jdbc.Driver); Connection con = DriverManager.getConnection( &quot;jdbc:mysql://localhost:3306/xxx...&quot;); //以？作为占位符，值待设置String sql = &quot;delete from user where id=? and name=?&quot;;//创建PreparedStatement时就传入sql语句，实现了预编译 PreparedStatement p = con.prepareStatement(sql); //传入参数p.setString(1,&quot;1&quot;);p.setString(2,&quot;admin&quot;);//设置sql语句的占位符的值，注意第一个参数位置是1不是0p.execute(); //执行 同时，mybatis-plus框架也会进行sql的预编译。Mybatis（plus）使用参数化查询，#&#123;xxx&#125; 是参数化查询的占位符，它将传入的参数插入到占位符中，而不会将其解释为 SQL 代码。在自定义查询语句时，为确保参数化查询，须使用 @Param 注解将参数传递给 sql查询。这些措施让Mybatis-plus能防止sql注入。 文章：PreparedStatement防止SQL注入原因 ​ MybatisPlus如何解决SQL注入 ​ Mybatis-plus sql注入及防止sql注入详解 DBCP数据库连接池DBCP连接池提高资源利用率，避免重复创建和销毁连接资源，减少系统开销。使用DBCP连接池后，免去了编写连接数据库的代码。使用DBCP需要导入dbcp相关jar包，导入依赖到项目中。 12commons-dbcp-1.4.jarcommons-pool-1.5.4jar 创建多个dbcp.properties文件，存储多个不同的连接池 连接池的工作原理：①使用连接池前：用jdbc连接数据库时，先getConnection获取连接，用完后要release释放连接，再次连接重复前两步，对程序性能影响很大。②使用连接池后：在程序开始之前，先创建几个连接，将连接放入到连接池中，连接池中缓存了一定量的Connection对象，当用户需要使用连接时，从连接池中获取，使用完毕之后将连接还回连接池。 连接池的种类：DBCP，C3P0，Druid，Tmcat内置连接池等。 dhcp配置: 123456789101112131415#导入dbcp的配置文件dbcp.propertiesdriverclassName=com.mysql.jbcp.Driverurl=jdbc:mysql://localhost:3306/xxx?useUnicode=true&amp;characterEncoding=utf-8user=rootpassword=123456initialSize=10 #初始连接数量maxActive=50 #最大活跃连接数量maxIdle=20 #最大空间连接数minIdle=5 #最小空间连接数maxWait=60000 #最大等待时间ms（毫秒），从连接池获取连接，如果连接池空了，等待的最大时间connectionProperties=useUnicode=true;characterEncoding=utf-8defaultAutoCommit=truedefaultTransactionIsolation=READ_COMMITTED 12345678910InputStream in = xxx.class.getClassLoader(). getResourceAsStream(&quot;dbcp.properties&quot;);Properties pro = new Properties();pro.load(in);//声明连接池static DataSource datasource=null;//创建连接池datasource=BasicDataSourceFactory.createDataSource(pro);//从连接池获取连接conn=datasource.getConnection()； DBCP参考资料","categories":[{"name":"mysql","slug":"mysql","permalink":"https://aachou.github.io/categories/mysql/"}],"tags":[],"author":"沧海一粟"},{"title":"linux正则表达式与三剑客","slug":"linux正则表达式与三剑客","date":"2023-12-11T09:45:23.000Z","updated":"2023-12-25T07:38:14.000Z","comments":true,"path":"2023/1211/","permalink":"https://aachou.github.io/2023/1211/","excerpt":"本文介绍了如何使用linux正则表达式结合命令处理文本和awk,grep,sed三种文本工作命令。","text":"本文介绍了如何使用linux正则表达式结合命令处理文本和awk,grep,sed三种文本工作命令。 正则表达式（regular expression） 使用一些特殊字符+字母和或数字按照某个规则组合成一 个公式用来表示某个意思这就叫正则表达式。正则表达式是一种方法，很多命令可以采用这种方法：vim ，grep，sed，awk等都支持正则表达式，grep通常打印结果行。 元字符元字符：有特殊含义的字符，可以表示其他的含义 “ ^ “ 开头匹配后面的某开头字符。 cat a.txt | grep &quot;^a&quot; 12a bcabc “ $ “ 结尾匹配前面的某结尾字符。 cat a.txt | grep &quot;b$&quot; 12aa aabbbb “ . “单个匹配任意单个字符，长度不为0。 “a.{2}” 表示匹配以a开头的后面任意两个单个字符，至少两个，包括空格。 cat a.txt| egrep &quot;a.&#123;2&#125;&quot; 123a baaaa abcbbb afc “a.{4,6}” 表示匹配以a开头的后面任意4 - 6个单个字符，包括空格。 cat a.txt| egrep &quot;a.&#123;4,6&#125;&quot; 123bbb aaaaaabd efdddkkk baccccd “ * “ 任意匹配前面的字符出现0次或者任意，贪婪模式, 匹配*号前面的字符任意次，. *表示任意长度任意字符，包括空格。 cat a.txt| egrep &quot;aa.*&quot; 12aad daABC baa “ + “ 至少一次表示前面字符出现1次以上. cat a.txt | egrep &quot;[abc]+&quot; 123abcdeadebbb 相当于 cat a.txt| egrep &quot;[abc]&quot; cat a.txt | egrep &quot;abc+&quot; 123abcabccc ddd abc “ ? “ 可有可无匹配其前面的字符0或1次,即前面的字符可有可无。 cat a.txt| egrep &quot;ab?&quot; 123abadd aad “{ }”次数区间注意，在使用grep基本正则表达式要带\\转义字符，即\\&#123;4,6\\&#125;，这里以拓展正则表达式为例，就不用带转义字符。 {m} ，匹配前面的字符m次。{m,n} ，匹配前面字符至少m次，最多n次。 cat a.txt| egrep &quot;abcd&#123;2,3&#125;&quot; 12ef abcddabcdddef “ | “或者 cat a.txt| egrep &quot;a|bc&quot; 12bc asdd bcd ^patten$ 模式匹配 ^a$表示只匹配以a这个字符开头和结尾的行。 cat a.txt | egrep &quot;^a$&quot; “\\“ 转义“\\“表示是转义字符，就是把元字符转义为普通字符，比如\\\\表示普通符号”\\“，把普通字符转换为特殊意义符号，比如”\\n”表示把普通字符n转义为换行符。 \\&lt;或\\b ，单词左侧，表示以该单词为词首\\&gt;或\\b ，单词右侧，表示以该单词为词尾\\&lt;PATTERN\\&gt; ，匹配整个单词 “[ ]”方括号表达式[abc] 表示 a，b，c任意一个，实际上，[abc] &#x3D; “a|b|c”&#x3D;(a|b|c)。 示例： [a-z] 表示小写字母 [A-Z] 表示大写字母 [0-Z] 表示数字和字母 egrep (ab|ba) a.txt 12abd efgacd baef 12([0-9])|([0][0-9])|([1][0-9])#表示匹配0-9或者00-09或者10-19范围的字符。 ^在方括号里面和外面的区别方括号里面：表示对字符取反，排除某些字符。 方括号外面：表示以某字符开头。 示例：查找不是以数字开头的行 行开头可能是字母或特殊字符。 cat a.txt| egrep &quot;^[^0-9]&quot; []和 {}组合使用 [0-9]{2} 表示0-9里面可以取2次的意思。 [0-9]{2,5} 表示从0-9里可以取2-5次的数字，至少2个数字，最多5个。 [0-9]{2,} 表示从0-9里可以取两次以上，最少2次 a{2} 表示花括号前面的a连续出现两次。 abc{2}表示abc中的c出现2次。 案例：从文本里面过滤出所有邮箱地址 root@localhost lianxi]# cat mail.txta a1@qq.com aab 2b@sina.com bbc c3@163.com ccd 4d@163.com dd 写一个表示邮箱的正则，过滤邮箱。邮箱地址：字符串1@字符串2.字符串3 字符串1：a-Z_0-9 字符串2：0-Z 字符串3：a-Z cat mail.txt | grep -o &quot;[0-Z$_]+@[0-z]+.[0-z]+&quot; awk-F，字段分隔符，默认为空格 -f，从脚本中读取命令 1）以冒号为分割，显示第一列和第三列的内容： awk -F ：&#39;&#123;print $1 &quot;\\t&quot; $3&#125;&#39; a.txt 2）以冒号为分割，显示UID大于500的用户信息： awk -F : &#39;$3&gt;500&#39; /etc/passwd 3）以冒号为分割，搜索含root关键字的所有行： awk -F &#39;/root/&#39; /etc/passwd 4）以冒号为分割，搜索UID大于500的用户，并显示sh awk -F : &#39;$3&gt;500&#123;print $7&#125;&#39; /etc/passwd 5)BEGIN AND awk -F : &#39;BEGIN&#123;print &quot;name \\t uid&quot;&#125;&#123;print $1 &quot;\\t&quot; $3&#125;END&#123;print&quot;from /etc/passwd&quot;&#125;&#39; /etc/passwd grep用法: grep [选项] PATTERN [FILE] 在每个 FILE 或是标准输入中查找 PATTERN。默认的 PATTERN 是一个基本正则表达式(缩写为 BRE)，也可以是拓展正则表达式。 例如: grep -i ‘hello world’ menu.h main.c options: -e : 使用正则表达式，用于指定多个搜索模式。 -E：使用拓展表达式 -i : ignore-case忽略大小写 -v: 反转匹配。 -w, –word-regexp ，强制 PATTERN 仅完全匹配字词。 -x：完全匹配整行内容，包括行首行尾空格内容都要完全匹配。 -f : 指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式。 -c： 输出每个文件所匹配到的行数。 -r：递归搜索匹配内容 -L：列出不满足匹配要求的文件名，不输出行内容 -l ： 列出满足匹配要求的文件名，不输出行内容。 -z ：匹配一个 0 字节的数据行，但不是空行。 -m n：当匹配内容的行数达到n行后停止搜索,并输出停止前搜索到的匹配内容。 -o: 只输出匹配的具体字符串,匹配行中其他内容不会输出。 -q：安静模式,不会有任何输出内容,echo $?查找到匹配内容会返回0,未查找到匹配内容就返回非0 -s：不会输出查找过程中出现的任何错误消息。 输出线前缀控制： -b：输出每一个匹配行或字符串时附上偏移量(从文件第一个字符到该匹配内容之间的字节数) -n：输出匹配内容的同时输出其所在行号。 -H：在每一个匹配行之前加上文件名一起输出。 -h：不带文件名输出。 -T：在匹配信息和其前的附加信息之间加入tab以使格式整齐。 上下文线控制选项： -A n：匹配到搜索到的行以及该行下面的n行 -B n：匹配到搜索到的行以及该行上面的n行 -C n：匹配到搜索到的行以及上下各n行 案例1：在&#x2F;home目录下查找所有内容含abc的文件名 grep -rl abc * 案例2：统计在passwd和shadow文件中含root的行数 grep -c root /etc/passwd /etc/shadow sed sed 全名为 stream editor，流编辑器，用程序的方式来编辑文本，功能相当的强大。是贝尔实验室的 Lee E.M 在 1974年开发完成，目前可以在大多数操作系统中使用。与vim等编辑器不同，sed 是一种非交互式编辑器，它使用预先设定好的编辑指令对输入的文本进行编辑，完成之后再输出编辑结构。 sed会一次处理一行内容，处理时，把当前处理的行存储在临时缓冲区中，成为”模式空间”pattern space，接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾，文件内容并没有改变。 用法：sed [options] ‘command’ file，options有-n，-e，-i，-f，-r选项。 -n 使用安静模式，加入-n 后只打印被匹配的行。-e 多重编辑，命令顺序会影响结果。-r 使用扩展正则表达式。-i 将操作结果写入文档，不在屏幕上输出。-f 指定一个 sed 脚本文件到命令行执行。 COMMNAD: 123456789101112131415a 在当前行后添加一行或多行c 用新文本修改（替换）当前行中的文本d 删除行i 在当前行之前插入文本p 从暂存区打印行s 用一个字符串替换另一个h 把模式空间里的内容复制到暂存缓存区H 把模式空间里的内容追加到暂存缓存区g 取出暂存缓冲区里的内容，将其复制到模式空间，覆盖该处原有内容G 取出暂存缓冲区里的内容，将其复制到模式空间，追加在原有内容后面l 列出非打印字符n 读入下一输入行，并从下一条命令而不是第一条命令开始处理q 结束或退出 sedr 从文件中读取输入行！ 对所选行之外的所有行应用命令 1）安静打印 sed -n &#39;p&#39; a.txt 或sed &#39;r&#39; a.txt 2）每行打印两遍输出 sed &#39;p&#39; a.txt 3）只输出第2到5行，原文件内容不变 sed -n &#39;2,5p&#39; a.txt 4）打印第4行后退出 sed &#39;4q&#39; a.txt 5）搜索指定内容并打印 找到含abc的行并把该行输出： sed -n &#39;/abc/p&#39; a.txt 注意与sed &#39;/abc/p&#39; a.txt的区别，这是全部输出并把这行打印2遍。 6）删除 删除第2,到4行的数据： sed &#39;2,4d&#39; a.txt 删除含abc的行： sed &#39;/abc/d&#39; a.txt 7）追加a和插入i 在第二行下插入abc sed &#39;2a abc&#39; a.txt 在第二行上插入abc sed &#39;2i abc&#39; a.txt 8）整行替换 替换2,3,4行为abc sed &#39;2,4c abc&#39; a.txt 9）字符串替换 全局替换将文件中的abc替换为a字符,g(global) sed &#39;s/abc/a/g&#39; a.txt 仅换将文件中第3行的abc替换为a字符 sed &#39;3s/abc/a/g&#39; a.txt 多条件替换： 将abc和def替换为a字符 sed -e &#39;s/abc/a/g;s/def/a/g&#39; a.txt 10）结果写入 使用-i选项，将原本输出到屏幕的结果写入文档。 sed -i &#39;/abc/p&#39; a.txt 11）从文件读入 子命令r，类似于a，也是将内容追加到指定行的后边，只不过r是将指定文件内容读取并追加到指定行下边。 例：sed &#39;2r b.txt&#39; a.txt 将b.txt文件内容读取并插入到a.txt文件第2行的下边。 其他文本处理命令nl 编写行号nl [options] [file]，默认空行不统计 -b，选择样式，a所有、t非空行、n不显示、BRE正则(正则匹配的行才显示行号) -n，–number-format&#x3D;格式，根据指定格式插入行号。 -w, –number-width&#x3D;数字，为行号使用指定的栏数。 -s, –number-separator&#x3D;字符串，可能的话在行号后添加字符串。 格式是下列之一: ln 左对齐，空格不用0 填充 rn 右对齐，空格不用0 填充 rz 右对齐，空格用0 填充 nl -b a a.txt，统计a.txt中所有行， wc词数统计wc [options] [file] wc a.txt 1234567897 14 74 a.txt#行数 字（单词）数 字节数$1 1111 aaa$2 22222 bbb$3 33333 cccc$4 44444 ddd$5 bbb aaaaa$6 abd efddd$7 kkk baccccd options: -w，只统计文件中单词数 -m，字符数 -c，统计字节数 -L，显示最长行长度（可见字符加空格） -l，行数 sortsort a.txt，文本排序，默认按首字母、第一个数字顺序排序。 options: -n，按数值大小排序。 -r，逆序排列。 -t，指定分隔符 -k，选取分隔后的哪一列 案例：按a.txt文件中第三列数字大小进行排序输出 sort -k 3 -n a.txt uniquniq a.txt，去连续重行。 -d，只打印重复的行 -u，只打印不重复的行 -c，统计重复行的出现次数","categories":[{"name":"linux","slug":"linux","permalink":"https://aachou.github.io/categories/linux/"}],"tags":[],"author":"沧海一粟"},{"title":"Git入门","slug":"Git入门","date":"2023-12-01T07:16:09.000Z","updated":"2023-12-27T04:16:44.000Z","comments":true,"path":"2023/1201/","permalink":"https://aachou.github.io/2023/1201/","excerpt":"本文介绍的git版本控制、配置、命令操作、分支和文件状态等内容","text":"本文介绍的git版本控制、配置、命令操作、分支和文件状态等内容 版本控制本地版本控制：在本地记录每一次版本更新。 集中版本控制：版本数据都保存在单一服务器，不联网就看不到版本信息。SVN 分布式版本控制：所有的版本信息都同步到本地的每个用户，可以离线在本地提交，只需在联网时push。Git SVN与Git的区别： SVN 是集中式的；Git 是分布式的 SVN 的分支操作成本（创建&#x2F;删除&#x2F;合并）比 Git 高 SVN 是存储变更差异；Git 是存储文件快照 SVN必须联网操作，只有服务器上的版本控制；Git支持离线操作，有本地的版本控制 git配置1）git\\mingw64\\etc\\gitconfig ，–system系统级 2）C:\\Users\\用户\\.gitconfig ，–global全局 Git branch 获取分支列表 ，列表保存到refs&#x2F;heads&#x2F;master 下面。 git config -l，配置清单 git config --system --list，系统配置 git config --global --list，全局配置（用户配置） 安装好git后，设置用户名和邮箱（必要）： 12git config --global user.name &quot;xxx&quot;git config --global user.email &quot;xxx@qq.com&quot; 配置ssh公私钥连接远程仓库： 在c:&#x2F;Users&#x2F;用户&#x2F;.ssh下打开git bash，运行ssh-kengen生成公私钥，将pub公钥粘贴到远程仓库配置中。 工作区域git本地有四个工作区域：工作目录、暂存区(stage&#x2F;index)、资源库(repository)、远程仓库(remote repository)。 工作区：平时写代码项目文件的目录。 index&#x2F;stage：存放提交的文件列表信息的文件。 Local R本地仓库：存放提交的所有版本信息，HEAD指针总是指向当前分支。 Remote：托管代码的远程服务器。 文件状态untracked：未加入到本地库中，不参与版本控制，使用git add变为staged状态 unmodify：文件已入库，未修改。被修改则变为modified文件或git rm移除版本库变为untracked状态。 modified：文件已修改。通过git add变为staged状态，或通过git checkout放弃修改回到unmodify状态。 staged：暂存状态。执行git commit提交到版本库中，文件变为unmodify状态，执行git reset HEAD filename取消暂存，文件变为modified状态。 git对象模型在git系统中有四种对象： commit：指向一个tree，纪录了文件操作，作者，提交者信息； tree：对象关系树，管理tree和blob的关系； blob：保存文件内容； tag：标记提交。 基础命令git init，本地创建一个新的项目。 git clone [url]，克隆远程仓库上的项目代码。 git rm/mv [file]，删除移动文件 git status [xx]，查看文件状态。 git commit -m xxx，提交暂存区中的内容到本地仓库，-v提交时显示diff信息。 git branch，查看本地分支，-r查看远程，-d [name]删除分支，-rd删除远程分支 git branch [bname]，新建分支 12# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch] git merge [branch]，合并分支到当前分支。 git checkout [branch]或git switch，切换到指定分支，实际是移动HEAD指针。 git checkout [file]，恢复暂存区文件到工作区。 git reset --hard [版本号]，版本穿梭(切换版本)。 git log，显示当前分支版本历史，-S [key]根据关键词搜索提交历史，–follow [file]显示某文件的版本历史，–oneline简洁显示。 git reflog，显示当前分支的最近几次提交。 git shortlog -sn，显示所有提交过的用户。 git blame [file]，显示文件被什么人什么时间修改。 git diff，显示工作区和暂存区的差异。 git show [commit]，显示某次提交的时间和内容变化。 git fetch [remote]，下载远程仓库变动到本地版本库。 git remote -v，显示所有远程仓库，add添加仓库，remove删除。 git pull [remote] [branch]，取回远程仓库分支的变化并与本地合并。 git push [remote] [branch]，推送本地分支到远程仓库。 master分支主要用于发布新版本，常用工作分支使用dev等分支。 推送失败，因为最新提交和你试图推送的提交有冲突，两者对同一文件同一地点进行了修改。先用git pull把最新提交从origin&#x2F;dev抓下来，然后在本地合并，解决冲突再推送或者进行git reset回滚。git pull也失败了，原因是没有指定本地dev分支与远程origin&#x2F;dev分支的链接，根据提示，设置dev和origin&#x2F;dev的链接。 1git branch --set-upstream-to=origin/dev dev 这回git pull成功，但是合并有冲突，需要手动合并，即vim编辑冲突的文件，删除特殊符号，决定保留哪些内容，wq保存后，提交暂存区，提交本地库，再push。 .gitignore忽略文件在目录下创建.gitignore文件，将某些文件排除在版本控制外。 #：注释。 tmp/*.txt：忽略tmp目录所有以.txt结尾的文件，不包括tmp/d/*.txt。 !：除了这个文件外忽略所有 /tmp：忽略除tmp文件夹外的其他文件 tmp/：忽略tmp目录下的所有文件 12345678910111213141516171819202122HELP.mdtarget/!.mvn/wrapper/maven-wrapper.jar!**/src/main/**/target/!**/src/test/**/target/### STS ###.apt_generated.classpath.factorypath.project.settings.springBeans.sts4-cache### IntelliJ IDEA ###.idea*.iws*.iml*.ipr IDEA集成Git将所有克隆下来的git项目或新创建的git项目文件拷贝到IDEA项目中即可。","categories":[{"name":"git","slug":"git","permalink":"https://aachou.github.io/categories/git/"}],"tags":[],"author":"沧海一粟"},{"title":"在windows下安装linux多系统","slug":"在windows下安装linux系统","date":"2023-11-28T01:16:09.000Z","updated":"2023-12-09T19:36:44.000Z","comments":true,"path":"2023/1128/","permalink":"https://aachou.github.io/2023/1128/","excerpt":"windows上安装linux系统等系统大致步骤如下，这里以安装kali为例：","text":"windows上安装linux系统等系统大致步骤如下，这里以安装kali为例： 1、准备好系统文件和存储空间 首先下载kali镜像文件，其次在windows磁盘管理上划出一块空闲的磁盘分区，至少10G。在一块磁盘上选择压缩卷，输入空间大小，完成后可以看到一块黑色未格式化的磁盘。 2、需要一个U盘制作系统启动盘 先格式化u盘，保证U盘中没有数据。再使用rufus、软碟通或win32diskImage等软件将iso镜像文件写入u盘。其次通过win+r键输入msinfo32查看BIOS模式，现通常为UEFI模式，也可能为Legacy模式启动(需要分配一个MBR启动分区)。 若为UEFI模式，在安装时可以不选择UEFI安装也可以强制UEFI安装。通过UEFI安装，在磁盘分区手动分配时需要分配一个efi系统启动分区，可启动标志为开。 3、完成后插入U盘 重启电脑，按F12或其他BIOS按键进入启动选择管理界面，选择U盘安装启动。 4、进入安装引导界面安装。 磁盘分区挂载时选择windows上的空闲分区，不要选U盘，因为我们要把系统安装在主机磁盘上。若只有U盘没有显示其他空闲分区，则终止安装，重启系统按F2或Delete进入系统BIOS配置界面，将Storage磁盘存储模式改为AHCI模式，而不是RST模式！重启再次进入安装程序，可以看到系统已经能识别主机磁盘了。 5、设置中文界面 需要root权限，在命令行输入dpkg-reconfigure locales打开配置界面，取消en_US.UTF-8选项，勾选zh_CN.UTF-8。Tab选择ok回车，并设置默认系统环境，上下键选择zh_CN.UTF-8，选ok回车。 6、配置软件源 找到&#x2F;etc&#x2F;apt目录下的sources.list文件，将默认软件源注释掉，写入阿里云软件源，或者清华、中科大镜像源都行。 12deb http://mirrors.aliyun.com/kali kali-rolling main contrib non-free non-free-firmwaredeb-src http://mirrors.aliyun.com/kali kali-rolling main contrib non-free non-free-firmware 使用apt update更新软件源。 7、安装中文输入法 需要root用户权限，首先安装中文字体ttf-wqy-zenhei，安装fcitx输入法和拼音，补全安装apt –fix-broken install。 apt install fcitx fcitx-pinyin 打开设置，找到input输入法，设置输入法为fcitx选项。再在设置中找到fcitx配置，添加中文拼音输入，设置默认键盘为汉语，然后重启系统即可。另外，激活输入法快捷键为ctrl+space，切换为ctri+shift。","categories":[{"name":"linux","slug":"linux","permalink":"https://aachou.github.io/categories/linux/"}],"tags":[],"author":"沧海一粟"},{"title":"docker实战","slug":"docker实战","date":"2023-11-22T03:38:31.000Z","updated":"2023-11-22T03:42:08.000Z","comments":true,"path":"2023/1122/","permalink":"https://aachou.github.io/2023/1122/","excerpt":"本文将讲述如何使用docker制作tomcat镜像并上传至阿里云，部署redis和springboot项目。","text":"本文将讲述如何使用docker制作tomcat镜像并上传至阿里云，部署redis和springboot项目。 制作tomcat镜像通过dockerfile制作一个tomcat镜像并发布到阿里云镜像仓库。 1、在用户工作的主目录中创建一个build&#x2F;tomcat文件夹 2、准备tomcat和jdk安装包上传到该文件夹下 3、在文件夹下创建一个README.txt文件并编写Dockerfile文件 touch README.txt vim Dockerfile 123456789101112131415161718192021FROM centos#本地基础镜像docker images查看是否有该镜像否则将失败MAINTAINER zzh&lt;xxxx@qq.com&gt;COPY README.txt /usr/local/ADD /root/build/tomcat/apache-tomcat-8.5.94.tar.gz /usr/local/ADD /root/build/tomcat/jdk-8u151-linux-x64.tar.gz /usr/local/RUN yum -y install vimRUN yum -y install net-toolsENV MYPATH /usr/localWORKDIR $MYPATHENV JAVA_HOME /usr/local/jdk1.8.0_151ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools/jarENV CATALINA_HOME /usr/local/apache-tomcat-8.5.94ENV CATALINA_BASH /usr/local/apache-tomcat-8.5.94ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/binEXPOSE 8080CMD /usr/local/apache-tomcat-8.5.94/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-8.5.94/logs/catalina.out 4、构建diytomcat镜像 docker build -t diytomcat . 5、创建容器运行 docker run -d -p 3355:8080 --name mytomcat01 -v /root/build/tomcat/test:/usr/local/apache-tomcat-8.5.94/webapps/test -v /root/build/tomcat/logs:/usr/local/apache-tomcat-8.5.94/logs diytomcat 6、测试运行 在linux主机测试：curl localhost:3355或直接访问。 7、上传至阿里云镜像仓库 docker login --username=xxx registry.cn-shanghai.aliyuncs.com #重命名镜像 docker tag 镜像 registry.cn-shanghai.aliyuncs.com/命名空间/仓库名:tag docker push registry.cn-shanghai.aliyuncs.com/命名空间/仓库名:tag Redis集群部署1、创建网络 docker network create redis --subnet 172.17.0.0/16 2、通过脚本创建redis配置 12345678910111213141516171819202122for port in $(seq 1 6); \\do \\mkdir -p /mydata/redis/node-$&#123;port&#125;/conftouch /mydata/redis/node-$&#123;port&#125;/conf/redis.confcat &lt;&lt; EOF &gt;/mydata/redis/node-$&#123;port&#125;/conf/redis.confport 6379bind 0.0.0.0cluster-enabled yescluster-config-file node.confcluster-node-timeout 5000cluster-announce-ip 172.17.0.1$&#123;port&#125;cluster-announce-port 6379cluster-announce-bus-port 16379appendonly yesEOFdonedocker run -p 637$&#123;port&#125;:6379 -p 16371:16379 --name redis-$&#123;port&#125; \\-v /mydata/redis/node-$&#123;port&#125;/data:/data \\-v /mydata/redis/node-$&#123;port&#125;/conf/redis.conf:/etc/redis/redis.conf \\-d --net redis --ip 172.17.0.1$&#123;port&#125; redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf docker run -p 6371:6379 -p 16371:16379 --name redis-1 \\ -v /mydata/redis/node-1/data:/data \\ -v /mydata/redis/node-1/conf/redis.conf:/etc/redis/redis.conf \\ -d --net redis --ip 172.17.0.11 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf 3、查看redis容器，进入容器 docker ps docker exec -it redis-1 /bin/sh 3、创建redis集群 redis-cli --cluster create 172.17.0.11:6379 172.17.0.12:6379 172.17.0.13:6379 172.17.0.14:6379 172.17.0.15:6379 172.17.0.16:6379 --cluster-relicas 1 4、查看集群 redis-cli -c cluster info cluster nodes SpringBoot微服务打包docker镜像1、将springboot项目打包为xxx.jar 2、编写Dockerfile文件 1234567FROM java:8MAINTAINER z&lt;xx@qq.com&gt;COPY *.jar /app.jarEXPOSE 8080ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;] 3、构建镜像 docker build -t myApp . 4、发布镜像，下载镜像运行 docker push myApp docker pull myApp docker run -d -p 8080:8080 --name X-WEB-APP myApp 5、测试 curl localhost:8080 拓展compose、swarm、Jenkins","categories":[{"name":"docker","slug":"docker","permalink":"https://aachou.github.io/categories/docker/"}],"tags":[],"author":"沧海一粟"},{"title":"docker入门","slug":"docker入门","date":"2023-11-21T02:17:40.000Z","updated":"2023-12-04T00:09:44.000Z","comments":true,"path":"2023/1121/","permalink":"https://aachou.github.io/2023/1121/","excerpt":"什么是Docker Docker是内核级别的虚拟化，可以在一个物理机上可以运行很多的容器实例。服务器的性能可以被压榨到极致。Docker是基于Go语言开发的，开源项目。","text":"什么是Docker Docker是内核级别的虚拟化，可以在一个物理机上可以运行很多的容器实例。服务器的性能可以被压榨到极致。Docker是基于Go语言开发的，开源项目。 镜像（image）：docker镜像就好比是一个模板，可以通过这个模板来创建容器服务，镜像&#x3D;&gt;run&#x3D;&gt;容器，通过这个镜像可以创建多个容器（最终服务运行或者项目运行就是在容器中的）。 容器（container）：Docker利用容器技术，独立运行一个或者一个组应用，通过镜像来创建的。启动，停止，删除。 仓库（repository）：仓库就是存放镜像的地方。 官网：https://www.docker.com/文档地址：https://docs.docker.com/Doker镜像仓库地址：https://hub.docker.com/ Linux下安装docker1、需要的安装包 yum install -y yum-utils 2、设置镜像的仓库 yum config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 3、更新yum软件包索引。 yum makecache 4、安装 yum install docker-ce docker-ce-cli containerd.io 5、启动docker systemctl start docker&#96; 6、使用docker version查看是否安装成功 docker run hello-world 配置阿里云镜像加速登录阿里云，找到容器服务。找到镜像加速地址，配置使用。 12345678sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;&#123;&quot;registry-mirrors&quot;: [&quot;https://xxx.xxx.xxx.com&quot;]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker docker命令docker --help 帮助 docker version 版本 docker info 详细信息 docker stats实时查看容器运行情况 docker history IMAGEID查看镜像构建记录 镜像命令： docker images [-a所有镜像,-q只要镜像ID]查看本机镜像 docker tag 镜像id 新镜像名:tag标签 克隆命名新的镜像 docker search xxx 搜素镜像 1docker search mysql --filter=STARS=3000 [root@CentOS7 docker]# docker search mysql –filter&#x3D;STARS&#x3D;3000NAME DESCRIPTION STARS OFFICIAL AUTOMATEDmysql MySQL is a widely used, open-source… 14616 [OK]mariadb MariaDB Server is a high performing… 5573 [OK] docker pull xx 下载镜像，默认最新版（分层下载，节省开销，加快速度） 指定版本下载：docker pull mysql:5.7 docker rmi [-f] 镜像名/镜像ID 删除镜像 **删除所有镜像**文件： docker rmi -f $(docker images -aq) 生成镜像 docker commit 容器id xx镜像名，根据容器的changes生成一个镜像，-a，作者名；-m，信息。 docker build [options] 生成路径path，根据dockerfile生成镜像。 docker build [选项] 镜像名[:标签]或者上下文路径或者URL 所执行目录（.表示在当前目录执行） 例：docker build -f mydockerfile -t mytomcat . 上传提交镜像 docker push [OPTIONS] NAME[:TAG]，上传一个镜像到远程仓库。 Options: -a, –all-tags，将所有版本的镜像提交。 –disable-content-trust 忽略镜像提示。 -q, –quiet ，简洁生成。 上传到dockerhub 1）在hub.docker.com创建账号 2）登录账户：docker login -u xxx -p 3）上传镜像 docker push 镜像:tag 上传到阿里云 1）登录到阿里云，找到容器镜像服务 2）创建命名空间 3）创建容器镜像仓库 4）查看仓库基本信息，获取ip地址，按照操作指南执行 5）比如登录： sudo docker login --usename xxx registry.cn-beijing.aliyuncs.com 容器命令： 有了镜像才能创建容器。 运行容器 docker run [options] 镜像 ，创建容器运行镜像 --name， 命名容器，Repository:Tag --rm，退出时删除容器 -d ，以后台方式运行，若容器不向客户端提供服务则停止运行 -it ，交互方式运行，启动进入容器查看内容 exit或ctrl+d退出停止运行；ctrl + p + q退出不停止 -p ，指定容器端口，主机端口：容器端口 例1：交互式运行centos docker run -it centos /bin/bash #会进入容器的交互终端 docker run -itd centos /bin/bash #以后台交互方式运行容器，不会进入容器 后面的&#x2F;bin&#x2F;bash的作用是表示运行bash ,docker中必须要保持一个进程的运行，这个&#x2F;bin&#x2F;bash就表示启动容器后启动bash。 例2：以脚本方式运行centos镜像，每隔1秒启动容器。 docker run -d centos /bin/bash -c &quot;while true;do echo xxx;sleep 1 ; done&quot; 例3：以后台方式创建容器运行nginx镜像，并向外开放3344端口 docker run -d --name nginx01 -p 3344:80 nginx 查看容器 docker ps [options]，查看正在运行的容器 -a查看运行记录，-n=?显示最近运行的容器，-q显示ID docker container ls 删除容器 docker rm 容器id，删除容器；-f，强制删除 例：删除所有容器 docker rm -f $(docker ps -aq) 启动和停止容器 docker start 容器id docker restart 容器id docker stop 容器id docker kill id，强制停止运行 （生成）镜像 docker container commit 容器id xx镜像名，-a，作者名，-m，信息。 docker build [options] 生成路径path，根据dockerfile生成镜像。 docker build [选项] 镜像名[:标签]或者上下文路径或者URL 所执行目录（.表示在当前目录执行） -f指定dockerfile文件，-t命名镜像 例1：提交容器3fdf3rfe4生成镜像tomcat01 docker commit -a=&quot;xxx&quot; -m=&quot;xxx&quot; 3fdf3rfe4 tomcat01:1.0 例2：根据dockerfile生成镜像保存到当前目录 docker build -f /home/dockerfile -t myimage:1.0 . 其他命令： docker logs [options] 容器id，查看日志 Options: –details，显示详细信息-f, –follow ，实时输出日志–since ，显示在某个时间后的日志-n, –tail ，展示最后n行日志-t, –timestamps ,显示时间–until ,显示一个时间前的日志 docker top 容器id，查看正在运行的容器中的进程 docker inspect 容器id，查看容器的元数据(返回的JSON格式) docker exec -it 容器id /bin/bash，以新终端进入正在运行的容器 docker attach 容器id，进入容器正在运行的终端 docker cp 容器id:文件绝对路径 主机目的路径，从容器中拷贝文件到主机 docker pause 容器id 悬挂中断 docker unpause 容器id 部署安装Tomcat、EStomcat 1、下载镜像 docker pull tomcat:9.0 2、启动镜像 docker run -d --name tomcat01 -p 3355:8080 tomcat:9.0 3、进入tomcat容器中，配置&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;webapps目录 docker exec -it tomcat01 /bin/bash cp -r webapps.dist webapps 4、访问测试 docker ps curl localhost:3355 ES docker run -d --name es01 -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; -e ES_JAVA_OPTS=&quot;-Xms64m -Xmx512m&quot; elasticsearch:7.7.0 容器数据卷让容器内的文件数据与linux主机或容器之间同步互通，形成共享，修改容器配置文件时可直接在主机服务器上修改，不需要进入容器，实现容器数据持久化。 方式一、-v卷挂载命令 例：docker run -it -v 主机路径:容器内路径 centos /bin/bash 在主机上通过docker inspect 容器，查看mount挂载情况。 例：安装mysql同步数据 docker pull mysql:5.7 docker run -d -p 3304:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql_01 mysql:5.7 参数说明：-d后台运行，-p端口映射，-v卷映射，-e环境配置。 容器启动成功后在本地连接3304端口连接数据库。 匿名挂载：-v 容器内路径 docker run -d -p --name nginx01 -v /etc/nginx nginx 具名挂载：-v 卷名:容器内路径 docker run -d -p --name nginx01 -v nginx_01:/etc/nginx nginx 默认卷挂载到本地的/var/lib/docker/volumes/ 指定路径挂载：-v 本地路径:容器路径 docker run -d -p --name nginx01 -v /home/nginx01/:/etc/nginx nginx 卷管理 docker volume [options]，管理数据卷，参数说明： create ，创建一个卷；inspect，查看卷详细信息；ls，列出所有卷；prune，删除未使用的本地卷；rm，删除卷 方式二、dockerfile 1、创建一个dockerfile文件 vim dockerfile 2、编写dockerfile 1234567FROM centosVOLUME [&quot;volume01&quot;]CMD echo &quot;----end----&quot;CMD /bin/bash#解释FROM 镜像名:标签 #FROM指定基础镜像，其必须为Dcokerfile中第一条指令RUN 命令 #在该镜像中执行命令，如果执行多个命令用 &amp;&amp;连接起来 3、docker build 生成镜像文件 docker build -f /home/dockerfile -t 镜像名(repo):版本标签(tag) . 方式三、容器之间–volumes-from 创建一个容器docker02与其他容器共享数据。 docker run -it --name docker02 --volumes-from docker01 nginx 删除容器docker01数据依旧存在，因为它的数据在本地&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volume下。 DockerFiledockerfile用来构建镜像文件，命令脚本。 dockerfile指令： FROM #基础镜像MAINTAINER #维护者，姓名+邮箱RUN #镜像构建时需要运行的命令ADD #添加文件，若是压缩包则自动解压WORKDIR #镜像工作目录VOLUME #挂载目录EXPOSE #保留端口配置CMD #指容器启动需要运行的命令，只有最后一个生效，追加命令会覆盖ENTRYPOINT #指定容器运行时需要的命令，可以docker run时追加命令ONBUILD #当构建一个被继承的dockerfile时触发onbuild指令COPY #将主机文件拷贝到制作的镜像中ENV #构建时设置环境变量 例：编写一个mycentos镜像文件，生成镜像 vim mydockerfile-centos FROM centosMAINTAINER z&lt;zzh@163.com&gt;ENV MYWORKPATH /usr/localWORKDIR $MYWORKPATHRUN yum -y install vimRUN yum -y install net-tools EXPOSE 80CMD echo $MYWORKPATHCMD echo &quot;---end---&quot;CMD /bin/bash docker build -f mydockerfile-centos -t mycentos:1.0 . CMD与ENTRYPOINT比较 相同点： 1、只能写一条，如果写了多条，那么只有最后一条生效 2、容器启动时才运行，运行时机相同 不同点： ENTRYPOINT不会被运行的command覆盖，而CMD则会被覆盖，如果我们在Dockerfile种同时写了ENTRYPOINT和CMD，并且CMD是一个完整的指令，那么它们两个会互相覆盖，谁在最后谁生效。 docker网络docker网络是一种虚拟网络，网络为成对的bridge桥接模式。主机可与创建的容器进行通信，但是容器之间通信需要额外的操作。docker默认给容器分配一个虚拟内部ip地址，网络为docker0。 例：docker exec -it tomcat01 ping tomcat01 无法ping通，因为容器在docker0网络，无法通过容器名ping通。 ping不同的另一种原因： OCI runtime exec failed: exec failed: unable to start container process: exec: &quot;ping&quot;: executable file not found in $PATH: unknown 以上报错是因为docker创建的容器相当于一个miniLinux，很多命令和软件没有安装，包括network这一网络工具都没有。下载软件包只能通过apt-get或wget和curl命令。 docker network网络管理 docker network [options]，options如下： connect，连接容器到网络 create，创建网络 inspect ，查看网络 ls ，列出所有网络 rm ，删除网络 –link实现单向通信 运行tomcat02容器，使其能够与tomcat01通信。原理是在容器的&#x2F;etc&#x2F;hosts文件中配置了主机名与ip地址映射。 docker run -d --name tomcat02 --link tomcar01 tomcat 自定义网络 自定义网络支持通过容器名通信，创建一个自定义网络： docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 Mynet –net指定网络 使用自定义网络创建容器，在该网络中为容器分配ip： docker run -d --name tomcat02 --net Mynet tomcat 在该网络中的容器可以相互通信，可ping tomcat02。 容器-网络连接 如何让一个容器连接到另一个网络或者与另一个网络中的容器通信，可使用docker network connect，原理是将容器添加到该网络中。 docker network connect [OPTIONS] NETWORK CONTAINER Options: –alias 为网络添加作用范围scope –driver-opt 选择网络模式driver –ip 指定一个容器ip地址 –link list 添加到另一个容器的连接 –link-local-ip 为容器添加一个本地ip地址 docker network connect Mynet tomcat02，将tomcat02挂到Mynet网络。 可使用docker network inspect 查看网络中有哪些容器。","categories":[{"name":"docker","slug":"docker","permalink":"https://aachou.github.io/categories/docker/"}],"tags":[],"author":"沧海一粟"},{"title":"linux进阶","slug":"linux进阶","date":"2023-11-14T01:11:52.000Z","updated":"2023-12-24T10:19:18.000Z","comments":true,"path":"2023/1114/","permalink":"https://aachou.github.io/2023/1114/","excerpt":"本篇介绍linux日志管理、内核升级、数据备份与恢复的相关内容。","text":"本篇介绍linux日志管理、内核升级、数据备份与恢复的相关内容。 linux系统文件结构： &#x2F; 根目录&#x2F;bin 存放必要的命令&#x2F;boot 存放内核以及启动所需的文件&#x2F;dev 存放设备文件&#x2F;etc 存放系统配置文件&#x2F;home 普通用户的宿主目录，用户数据存放在其主目录中lib 存放必要 的运行库&#x2F;mnt 存放临时的映射文件系统，通常用来挂载使用&#x2F;proc 存放存储进程和系统信息&#x2F;root 超级用户的主目录&#x2F;sbin 存放系统管理程序&#x2F;tmp 存放临时文件&#x2F;usr 存放应用程序，命令程序文件、程序库、手册和其它文档。&#x2F;var 系统默认日志存放目录录 日志管理rsyslogd日志管理服务，配置文件&#x2F;etc&#x2F;rsyslog.conf，各日志文件有： &#x2F;var&#x2F;log&#x2F;boot.log系统启动日志 &#x2F;var&#x2F;log&#x2F;cron记录定时任务 &#x2F;var&#x2F;log&#x2F;lastlog记录最后一次登录信息 &#x2F;var&#x2F;log&#x2F;message记录系统重要信息 &#x2F;var&#x2F;log&#x2F;secure记录验证授权信息 &#x2F;var&#x2F;log&#x2F;wtmp和&#x2F;var&#x2F;log&#x2F;btmp 记录登录和失败登录信息 &#x2F;var&#x2F;tuned&#x2F;ulmp&#x2F;记录当前登录用户的信息 日志类型auth #pam产生的日志 authpriv #ssh\\ftp等登录产生的日志 cron #时间任务 kern #内核 lpr #打印 mail #邮件 mark #服务内部信息 user #用户程序信息 uucp #主机通信 local 1-7 #自定义设备 日志级别由低到高： debug 调试信息 info 一般信息 notice 重要信息 warning 警告 err 错误 crit 严重错误 alert 修改 emerge 内核崩溃 none 不记录 日志轮替创建新的日志文件，删除旧的日志，日志轮替配置文件&#x2F;etc&#x2F;logrotate.conf。日志轮替依赖于系统定时任务，在&#x2F;etc&#x2F;cron.daily&#x2F;目录下有logrotate可执行文件。 keep 4 weeks worth of backlogsrotate 4 #共保存 4 份日志文件,当建立新的日志文件时,旧的将会被删。 use date as a suffix of the rotated file dateext #以日期为后缀 自定义日志轮替自定义日志轮替规则，如： &#x2F;var&#x2F;log&#x2F;wtmp { monthly create 0664 root utmp minsize 1M rotate 1} 1）直接在&#x2F;etc&#x2F;logrotate.conf中写入该日志轮替规则。 2）在&#x2F;etc&#x2F;logrotate.d&#x2F;目录中建立新的日志文件，在文件中写入轮替策略。 参数说明： daily，每天轮替 weekly，每周轮替 monthly ， 每月轮替 rotate 数字， 保留日志文件个数 compress ，轮替时对旧的日志压缩 create mode owner group ， 创建新日志时指定权限所有者所在组 mail address ，日志轮替时输出内容到指定邮件地址 missingok ， 若日志不存在则忽略该日志警告 notifepmty ， 若日志为空则不轮替 minsize 大小 ，日志大小达到最小值才会轮替 size 大小，日志只有大于指定大小才进行轮替 dateext ，使用日期作为日志文件后缀 sharedscripts， 在此关键字后脚本只执行一次 prerotate&#x2F;endscript，在日志轮替之前执行脚本 postrotate&#x2F;endscript ，在日志轮替之后执行脚本 内存日志journalctl 查看内存日志 journalctl -n 3，查看最近3条 journalctl –since 1:00 –until 1:30 ，查看某时间段日志 journalctl -p err，查看报错日志 journalctl -o verbose ，查看详细信息 journalctl _PID&#x3D;xxx _COMM&#x3D;sshd ，查看带某参数信息的日志 journalctl | grep sshd 内核升级将linux系统的内核升级到兼容的版本 uname -a：查看当前内核 yum info kernel -q：检测内核版本 yum update kernel：升级内核 yum list kernel -q：查看已安装的内核 数据备份和恢复2种方式： 1）把需要的文件用tar打包 2）dump和restore指令 若没有两个指令需要安装 yum -y install dump yum -y install restore dump分区备份，增量备份，备份上次增加或修改过的文件 dump -cu -[123456789] -f 备份后的文件 -T 日期 [目录或文件系统] 参数说明： -c，创建新的备份文件 -[0,1,2,3,4,5,6,7,8,9]，备份的层级，0为完整备份，0以上则备份上次修改或新增的文件，9以后再次轮替。 -f，指定备份后的文件名 -j，使用bizlib库压缩 -T，指定开始备份的时间和日期 -u，备份后在&#x2F;etc&#x2F;dumpdares中记录备份的文件系统，层级、日期时间 -t，指定文件名，若文件已备份则列出名称 -W，显示需要备份的文件及最后一次备份的层级时间 -w，只显示需要备份的文件 查看备份时间文件：cat &#x2F;etc&#x2F;dumpdates 应用案例： 案例1：将&#x2F;boot分区所有内容备份到&#x2F;opt&#x2F;boot.bak.bz2文件中，备份的层级为0 dump -0uj -f /opt/boot.bak.bz2 /boot/ 案例2：在&#x2F;boot下创建一个新的文件hello.txt，增量备份，备份层级为1 vi hello.txt dump -1uj -f /opt/boot.bak1.bz2 /boot/ 注意，dump不支持文件和目录的增量备份，只能0级备份 例：备份&#x2F;etc目录到&#x2F;opt&#x2F;etc.bak.bz2 dump -0j -f /opt/etc.bak.bz2 /etc/ restore恢复dump备份的数据文件。 restore [模式mode] [选项option] 首先指定一种模式执行，-C对比，-i交互，-r还原，-t查看文件。 选项：-f 备份文件，从dump备份文件中读取数据。 案例1：比较备份文件和原文件 restore -C -f /opt/boot.bak.bz2 案例2：查看备份了那些文件 restore -t -f /opt/boot.bak.bz2 案例3：还原备份文件&#x2F;opt&#x2F;boot.bak0.bz2到&#x2F;opt&#x2F;boottmp&#x2F;下 mkdir /opt/boottmp cd /opt/boottmp #恢复到第一次完全备份状态 restore -r -f /opt/boot.bak0.bz2 #若有增量备份文件boot.bak1.bz2则需要进行恢复，有几个恢复几个 restore -r -f /opt/boot.bak1.bz2 可视化管理bt宝塔可视化管理面板可以帮助运维人员提高效率，支持一键安装集群和数据库。 安装： yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh 安装成功后显示用户名和密码。 权限安全尽量使用普通用户登录服务器，执行root命令时使用sudo操作。对于重要的系统文件可以进行锁定，chattr +i /etc/passwd，使自己和他人无法操作文件。 使用SUID、SGID、Sticky设置特殊权限 使用chkrootkit&#x2F;rootkit hunter工具检查系统文件是否被修改或异常，监测root脚本，下载地址chkrootkit.org。 使用Tripwire检测系统文件完整性。 IO读写监控iotop可以监控磁盘读写情况，首先安装iotop，yum install iotop，iotop。","categories":[{"name":"linux","slug":"linux","permalink":"https://aachou.github.io/categories/linux/"}],"tags":[],"author":"沧海一粟"},{"title":"找回mysql密码","slug":"找回mysql密码","date":"2023-11-13T06:16:30.000Z","updated":"2023-11-13T06:20:30.000Z","comments":true,"path":"2023/1113/","permalink":"https://aachou.github.io/2023/1113/","excerpt":"这篇文章记录了如何在Linux和windows下找回mysql密码。","text":"这篇文章记录了如何在Linux和windows下找回mysql密码。 linux下找回Mysql密码1、修改&#x2F;etc&#x2F;my.cnf文件 2、插入skip-grant-tables 3、重启mysqld服务 service restart mysqld 4、进入mysql mysql -u root -p 5、修改mysql数据库中user表的authentication_string字段 use mysql; update user set authentication_string=password(&quot;12345678&quot;) where user=&#39;root&#39;; #刷新权限 flush privileges; 6、退出mysql，再次修改my.cnf配置文件 #skip-grant-tables windows下找回mysql密码1、停止MySQL服务 首先，我们需要停止MySQL服务。 net stop mysql 2、修改配置文件 在MySQL停止的情况下，我们需要修改MySQL的配置文件以跳过密码验证。在MySQL的安装目录中，找到名为my.ini或my.cnf的配置文件，使用文本编辑器打开该文件。在配置文件中找到[mysqld]部分，在该部分下添加以下一行代码：skip-grant-tables 3、重启MySQL服务 现在，我们需要重新启动MySQL服务，并且由于我们已经修改了配置文件，MySQL将不再需要密码进行验证。以下是重启MySQL服务的步骤： net start mysql 4、登录MySQL并修改密码 登录MySQL数据库并修改账户密码。 mysql -u root 如果使用的是其他账户，请将root替换为其他账户名。登录成功后，我们可以使用以下命令来修改密码： ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;new_password&#39;; 修改密码成功后，可以退出MySQL数据库。 5、恢复配置文件 打开MySQL的安装目录，打开之前修改的配置文件（my.ini或my.cnf），删除或注释掉之前添加的一行。","categories":[{"name":"mysql","slug":"mysql","permalink":"https://aachou.github.io/categories/mysql/"}],"tags":[],"author":"沧海一粟"},{"title":"Linux常用指令","slug":"Linux常用指令","date":"2023-11-12T09:49:23.000Z","updated":"2023-12-21T03:00:20.000Z","comments":true,"path":"2023/1112/","permalink":"https://aachou.github.io/2023/1112/","excerpt":"在学习linux的过程中，有一些指令经常使用，下面是学习笔记。","text":"在学习linux的过程中，有一些指令经常使用，下面是学习笔记。 登录注销su - 用户名，logout 注销用户登录（运行级别3下有效） 关机重启shutdown -h now 立刻关机shutdown -h 1 1分钟后关机，默认一分钟shutdown -r now 现在重启shutdown -c 取消关机，取消重启halt关机reboot重启sync同步内存数据 Vim编辑器快捷键拷贝当前行 ：yy粘贴：p删除当前行: dd，删除以下5行：5dd查找某个单词：命令行下&#x2F;关键词，回车，n查找下一个。设置文件行号：命令行set nu撤销：一般模式下，u移动到20行：一般模式下，输入20,然后shift+g移动到最末行最首行：一般模式下G， gg 文件目录类ls :显示当前目录下的文件，-a 所有文件,-l 列表展示信息,-h 方便浏览cat xxx:安全打开，只读vi xxx:用vim编辑器打开文件more: 分页打开less： 打开大文件head -n 11 xx 打开文件开头11行，默认10行tail -n 11 xxx 打开文件末尾11行 tail -f xxx实时监控文件 history: 命令执行记录history 10最近执行的10条指令!488执行第488条指令 rm: 删除文件 -f 强制删除, -r逐层递归删除文件cp: 复制文件或覆盖，-r递归复制整个文件夹 ，&#x2F;cp强制覆盖mv: 移动文件、重命名touch：创建空文件mkdir:创建文件夹rmdir:删除文件夹ln: 符号连接，软连接ln -s /root/ myroot 打包、解包、压缩和解压指令Linux 主要有3种压缩方式，zip，gzip，xz是压缩解压指令。gzip：压缩速度最快，应用广泛bzip2：压缩成的文件小xz：最新的方式，提供最佳的压缩率 tar是打包指令： -c，进行打包-v，显示详细信息-f，指定压缩或解压的文件包-z，支持gzip压缩和解压，-j支持bzip压缩，-J支持xz压缩-x，解包文件-t，显示文件的内容-k，保留原有文件不覆盖-C，切换到指定目录 案例1：压缩多个文件 tar -zcvf pc.tar.gz &#x2F;home&#x2F;pig.txt &#x2F;home&#x2F;cat.txt 案例2：将&#x2F;home文件夹压缩 tar -zcvf myhome.tar,gz &#x2F;home&#x2F; 案例3：将myhome.tar.gz解压到当前目录 tar -zxvf myhome.tar.gz 案例4：将myhome.tar.gz解压到&#x2F;opt&#x2F;tmp2下 mkdir &#x2F;opt&#x2F;tmp2tar -zxvf &#x2F;home&#x2F;myhome.tar.gz -C &#x2F;opt&#x2F;tmp2 1、tar打包：tar cvf xxx.tar xxx文件解包：tar xvf xxx.tar 2、.gz压缩：gzip xxx解压：gunzip xxx.gz 3、.tar.gz 和 .tgz压缩：tar zcvf xxx.tar.gz xxxx解压：tar zxvf xxx.tar.gz 4、.tar.bz2压缩：tar jcvf xxx.tar.bz2 xxx解缩：tar jxvf xxx.tar.bz2 5、.zip压缩：zip xxx.zip xxx解压：unzip xxx.zip 例：zip -r myhome.zip &#x2F;home&#x2F;把home文件夹及子文件压缩unzip -d &#x2F;opt&#x2F;tmp myhome.zip 把myhome.zip解压到&#x2F;opt&#x2F;tmp 6、.rar压缩：rar a xxx.rar xxx解压：rar x xxx.rar 7、.bz2压缩： bzip2 -z xxxx解压1：bzip2 -d &#x2F;xxx xxx.bz2解压2：bunzip2 xxx.bz2 输出重定向&gt;和追加&gt;&gt;指令ls -l &gt; info.txtcat 文件1&gt; 文件2echo “xxx”&gt;文件 echo $PATH $HOSTNAME 时间日期类date: 打印当前时间 date &quot;+%Y-%m-%D&quot;打印年月日date set &quot;+%Y-%m-%D %H:%M:%S&quot; cal :打印当前日历 cal 2023打印2023年日历 搜索查找类find :-name ；-user； -size find /home -name hello.txt -user root找到/home目录下用户名为root的hello.txt文件find / -size +200M 在根目录下找大于200M的文件 locate: 无需遍历整个系统，查询快 updatedblocate hello.txt 定位hello.txt所在的目录 grep: 过滤查找 cat hello.txt | grep -n &quot;hello&quot; 打开hello.txt并查找hello所在行 案例1：在&#x2F;home目录下查找所有内容含cat的文件名 grep -r &quot;cat&quot; /home | cut -d &quot;:&quot; -f 1 案例2：请统计&#x2F;home目录下所有文件个数及文件的总行数 find -r /home -name &quot;*.*&quot; | wc -l find -r /home -name &quot;*.*&quot; |xargs wc -l 用户管理添加用户：useradd xxx删除用户：userdel xxx修改用户所在组：usermod -g 新组名 user修改用户登录目录：usermod -d 目录 user查看用户是否存在：id user查看当前用户：whoami 文件所有者所在组添加&#x2F;删除组：groupadd&#x2F;groupdel查看了文件的所有者：ls -ahl xxx改变文件的所有者：chown 新用户 文件名&#x2F;目录改变文件所在组：chgrp 新组名 文件名&#x2F;目录改变文件目录所有者所在组：chown newowner:newgroup 加上参数-R将目录下所有文件都会改变 权限管理-rw-r--r--. 1 root root 239 10月 24 10:13 hello.java （1）drwxr-xr-x. 2 root root 4096 10月 23 13:56 桌面 （2） r:读 w:写 x:执行 [4,2,1] r+w+x&#x3D;7 0~9位： 1）0位：文件类型，-文件，d目录，c字符设备(键盘鼠标)，b块设备(硬盘)2）1~3位：所有者权限3）4~6：所在组权限4）7~9：其他组权限 [rwx]作用于文件r:只读cat； w:写修改但不能删除 ；x:可执行[rwx]作用于目录r: 查看目录内容ls，但对文件有独立的权限; w：可在目录内创建、删除文件 ; x：可进入目录cd 注（1）中数字1表示文件数或子目录数，第一个root为用户，第二个为用户组，239为文件大小单位字节，“10月 24 10:13”为最后修改日期。 变更权限chmod修改文件目录的权限, u所有者，g所在组，o其他组，a所有人(1)+ ，-， &#x3D;chmod u&#x3D;rwx,g&#x3D;rx,o&#x3D;x 文件名&#x2F;目录 ：给用户rwx，所在组rx，其他组xchmod o+x 文件名&#x2F;目录 ：给其他组执行权限chmod a-x 文件名&#x2F;目录 ：所有人剥夺执行权限 (2)通过数字变更 r：4 w：2 x：1 rwx&#x3D;7，rw：6，rx:5，r：4，wx：3，w：2，x：1 无权限：0 chmod u=rwx,g=rx,o=x 文件名/目录相当于chmod 751 文件名/目录 crond任务时间调度设置任务调度文件：&#x2F;etc&#x2F;crontab 设置个人调度任务：执行crontab -e指令，接着输入任务到调度文件。如： */1 * * * * ls -l /etc &gt; /tmp/to.txt 每小时每分钟执行ls -l /etc &gt; /tmp/to.txt 五个占位符参数： 第一个*：一小时中第几分钟，0~59 第二个*：一天中第几小时，0~23 第三个*：一个月中第几天，1~31 第四个*：一年中第几个月，1~12 第五个*：一周中星期几，0~7（0,7为星期日） crond相关指令： -r终止任务调度（删除），-e编辑任务，-l列出任务 service crond restart重启crond调度 特殊符号说明： * ：任何时间，若第一个为*表示每分钟执行。 ,：逗号代表不连续的时间，0 8,12,16 * * *表示每天8点12点16点0分执行。 -：表示连续时间范围， 0 5 ** 1-6周一到周六凌晨五点执行。 */n：表示每隔多久执行，*/10 表示每隔10分钟执行。 案例1：每隔一分钟将当前时间和日期追加到&#x2F;home&#x2F;mycal中1）vim my.sh写入date &gt;&gt; /home/mycal和cal &gt;&gt; /home/mycal2) 给my.sh增加执行权限，chmod u+x my.sh3) crontab -e写入任务*/1 * * * * /home/my.sh 案例2：每天凌晨2点备份数据库mydb1）crontab -e2）0 2 * * * mysqldump -u root -p 123456 mydb &gt; &#x2F;home&#x2F;db.bak at定时任务at命令是一次性定时任务，at的守护进程atd检查作业队列，以后台模式运行，每60秒检查一次，若时间与当前时间匹配则运行。使用at要保证atd在运行，使用以下命令查看进程： ps -ef | grep atd at [选项] [时间] atq查询任务，atrm删除Ctrl+D结束命令输入 at时间格式：1）hh:mm(04:00)当天或第二天执行2）midnight&#x2F;noon&#x2F;teatime3）12小时制，如9am ,3pm4）指定具体日期：month day或mm&#x2F;dd&#x2F;yy或dd.mm.yy，指定日期必须在时间后面04:00 2023-11-15）相对计时：now + count time-units，now是当前时间，count是数量，tim-units是时间单位，minutes,hours,days,months,weeks。 now + 5 days 五天后5pm + 2 days 两天后下午五点 6）today、tommorow 案例1：每天下午5点，把时间输入到&#x2F;root&#x2F;data.log里 at 5pm tommorow date &gt; /root/data.log 案例2：2天后五点执行&#x2F;bin&#x2F;ls &#x2F;home1)at 5pm + 2 days2)/bin/ls /home 案例3：删除5号at任务atrm 5 磁盘分区磁盘分区和文件系统之间通过挂载mount联系起来，分区构成整个文件系统。 查看设备挂载情况：lsblk -f Linux硬盘分为IDE和SCSI类型，目前主要为SCSI。 对于IDE硬盘，驱动器标识符为hdx~，hd表示IDE设备类型，x表示盘号(a主盘，b从属盘,c…)，~表示分区，前四个分区用1-4数字表示，5开始为逻辑分区。如hda2表示第一个IDE硬盘的第二个分区。 对于SCSI&#x2F;SATA硬盘，标识为“sdx~”，sd为SCSI硬盘类型，其余和IDE表示类似。 对于NVMe硬盘，以nvme0n开头，nvme0n1p1是第一块硬盘的第一个分区，而nvme0n2p3则是第二块硬盘的第三个分区。 案例：挂载一块硬盘 1.虚拟机添加硬盘 在虚拟机设置中在设备列表里添加一块硬盘，完成后重启才能识别。 2.分区 fdisk /dev/sdb m 显示命令列表p 显示磁盘分区，fdisk -ln 新增分区d 删除分区w写入并退出q 直接退出 3.格式化 格式化文件系统获得UUID：mkfs -t ext4 /dev/sdb1 4.挂载 将分区和文件目录联系起来：mount 设备名 文件目录 mount /dev/sdb1 /newdisk umount 设备名或挂载目录(mountpoint) umount /dev/sdb1或umount /newdisk 但是重启后失效 5.设置自动挂载 实现永久挂载，修改&#x2F;etc&#x2F;fstab文件，添加设备，重启或执行mount -a立刻生效。 /dev/sdb1 /newdisk 0.0 磁盘情况查询1）查看磁盘整体使用情况 ：df -h 2）查询指定目录的磁盘占用情况 du -h 默认当前目录 -s 占用大小汇总-h 带计量单位-a 带上文件–max-depth&#x3D;1子目录深度-c 列出明细，增加汇总值 案例1：查询&#x2F;opt目录下一层子目录的磁盘使用情况 du -h --max-depth=1 /opt 3）查看内存使用情况：free -h 查看系统负载命令：uptime-p，显示系统运行时间，-s，显示系统启动时间 1215:32:56 up 6:59, 2 users, load average: 0.04, 0.03, 0.0515:32:56当前时间，up运行时间，2个用户，过去1、5、15分钟负载 5）虚拟内存状态、io状态vmstat\\iostat 工作实用指令1）统计&#x2F;opt文件夹下文件的个数 ls -l /opt | grep &quot;^-&quot; | wc -l 2）统计&#x2F;opt文件夹下目录的个数 ls -l /opt | grep &quot;^d&quot; | wc -l 3）统计&#x2F;opt文件夹下文件的个数，包括子文件夹下的文件 ls -lR /opt | grep &quot;^-&quot; | wc -l 4）统计&#x2F;opt文件夹下目录的个数，包括子文件夹下 ls -lR /opt | grep &quot;^d&quot; | wc -l 5）树状显示目录结构 yum install treetree /opt Linux网络配置查看网络配置：ifconfig或ip addr测试网络连通：ping ip地址 1）DHCP动态路由分配 自动分配，ip不会冲突，但是不固定。 2）静态分配IP(固定IP) 修改网卡配置文件，vi /etc/sysconfig/network-scripts/ifcfg-ens33，将ip地址配置成静态的，添加固定ip如下。 DEVICE&#x3D;ens33 (设备网卡名)HWADDR&#x3D;00:0c:2x:6x:0x:xx (MAC地址)TYPE&#x3D;ethernet (网络类型)UUID&#x3D;029ad-d12e-dw23-32da-1d2c (随机id)ONBOOT&#x3D; yes (系统启动时网络接口是否开启)BOOTPROTO&#x3D;static (ip配置方法)[none;static;dhcp;bootp]IPADDR&#x3D;192.168.157.129 (ip地址)GATEWAY&#x3D;192.168.157.2 (网关)DNS1&#x3D;192.168.157.2 (DNS解析器) 在虚拟机中找到虚拟网络编辑器，找到该网络如vmnet8，修改子网ip地址为192.168.157.0，修改NAT配置中网关地址，点击确定再点击应用。之后重启系统或者输入service network restart生效。 设置主机名和HOST映射查看主机名：hostname修改主机名：vi /etc/hostname，重启 设置HOST映射： 1）在windows的”C:\\Windows\\System32\\drivers\\etc\\hosts”下添加ip与主机名的映射：192.168.157.129 CentOS7 ping CentOS7可ping通。windows cmd窗口ipconfig /displaydns列出本地dns缓存，ipconfig /flushdns清除缓存。 2）linux在&#x2F;etc&#x2F;hosts文件修改 监控网络状态netstat [options]，选项说明： -an，按一定顺序输出 ；-p，显示哪个进程在调用 例如：查看sshd服务的信息 netstat -anp |grep sshd ping ip，监测网络连接。 案例：统计连接到服务器的各个ip情况，并按连接数从大到小排 netstat -an | grep ESTABLISHED | awk -F &quot; &quot; &#39;&#123;print $5&#125;&#39; | cut -d &quot;:&quot; -f 1 | sort |uniq -c | sort -nr 案例：使用tcpdump监听本机来自192.168.300.1，端口为22的通信，并保存到tcpdump.log tcpdump -i ens33 host 192.168.300.1 and port 22 &gt;&gt; /opt/tcpdump.log 进程管理1、查看进程信息 ps指令： ps -A 显示当前所有进程信息ps -a 显示所有终端机下执行的程序ps -u 以用户的格式显示进程信息ps -x 显示后台进程运行的参数ps -aux | grep sshd 查看也没有sshd服务 USER进程执行用户，PID进程号，%CPU进程占CPU百分比，%MEM进程占物理内存的百分比，VSZ进程占虚拟内存的大小，RSS进程占物理内存的大小KB，TTY终端名称，STAT进程状态(S睡眠，R正在运行，Z僵尸进程，D短期等待，T被跟踪或被停止，&gt;高优先级)，START进程开始执行时间，TIME占用CPU时间，COMMAND启动进程的命令或参数。 ps -ef 以全格式显示所以进程，不会截断，System V格式。 ps -ef | grep sshd UID用户ID，PID进程号，PPID父进程PID，TTY终端设备号。 &#x2F;&#x2F;查找进程状态信息cat &#x2F;proc&#x2F;pid&#x2F;status&#x2F;&#x2F;查找进程启动命令行cat &#x2F;proc&#x2F;pid&#x2F;cmdline 2、终止进程 kill [option] PID ，终止进程，option&#x3D;-9表示强制终止。killall 进程名 ，终止该进程及子进程。 案例1：踢掉某个非法登录用户tomroot 1143 1 0 16:23 ? 00:00:00 &#x2F;usr&#x2F;sbin&#x2F;sshd -Droot 1741 1143 0 16:23 ? 00:00:00 sshd: root@pts&#x2F;0root 5031 1143 1 20:03 ? 00:00:00 sshd: tom [priv]tom 5043 5031 0 20:03 ? 00:00:00 sshd: tom@pts&#x2F;1 kill 5031 案例2：终止远程登录服务器sshd，合适时重启服务 kill 1143/bin/systemctl start sshd.service 案例3：终止多个gedit killall gedit 案例4：强制杀死终端 root 5277 5267 0 20:16 pts&#x2F;1 00:00:00 bash kill -9 5277 3、查看进程树 pstree ，-p 显示进程号，-u显示用户 4、top动态监控进程（性能监视器，任务管理器） top: 实时显示进程信息top -d 秒数，几秒后刷新top -i，不显示闲置和僵尸进程top -p PID，指定某进程ID监控进程 top交互操作说明，输入： P，以CPU使用率排序，默认N，以PID排序M，以内存使用率排序q，退出u，接着输入用户名，回车即可查看某用户相关进程k，接着输入进程号，回车即可终止某进程 案例1：监控用户tom的相关进程 top，输入u，接着输入tom 案例2：终止指定进程，踢掉tom PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND2060 tom 20 0 160988 2372 1028 S 0.0 0.1 0:00.01 sshd2064 tom 20 0 116876 3296 1676 S 0.0 0.2 0:00.04 bash top，输入u回车，输入tom回车，输入k回车，输入2064回车。 Service服务管理查看系统服务： 1）setup，系统服务。2）service指令管理服务在&#x2F;etc&#x2F;init.d查看，ls -l /etc/init.d/ service指令： service 服务名 [start|stop|restart|reload|status] CentOS7以后，大多服务不使用service，而使用systemctl。[使用service关闭network服务，一旦关闭，将无法连接SSH服务] 服务运行级别，在&#x2F;etc&#x2F;initab查看，systemctl get-default查看当前运行级别，systemctl set-default T.target设置默认级别。 chkconfig指令： 查看服务：chkconfig –list设置服务在level级别开启：chkconfig --level [0/1/2/3/4/5/6] 服务名 on/off 如设置network在3级别打开或关闭：chkconfig --level 3 network on/off，之后重启系统即可生效。 systemctl指令： systemctl [start |stop |restart |status |enable |disable] 服务名 该指令管理的服务在&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system查看。 systemctl list-unit-files，查看服务开机启动状态systemctl enable 服务名 ，设置服务开机启动systemctl disable 服务名，关闭服务自启动systemctl is-enabled 服务名 ，查看某个服务是否自启动 案例1：查看当前防火墙状态，关闭和打开防火墙服务 systemctl list-unit-files | grep firewalld 或systemctl is-enabled firewalld 或systemctl status firewalldsystemctl stop firewalldsystemctl start firewalld 【systemctl start&#x2F;stop 服务，服务在系统重启后恢复原样】 案例2：防火墙打开和关闭指定端口111 打开打开：firewall-cmd --permanent --add-port=端口/协议关闭打开：firewall-cmd --permanent --remove-port=端口/协议重载生效：firewall-cmd --reload查询端口是否开放：firewall-cmd --query-port=端口/协议查看那些已添加端口：firewall-cmd --list-port firewall-cmd --permanent --add-port=111/tcpfirewall-cmd --reload RPM和YUMrpm rpm是linux常用的下载和打包安装工具，生成.rpm结尾的文件。 软件包名基本格式：firefox-68.10.0-1.el7.centos.x86_64，名称：firefox，版本：68.10.0，适用操作系统：el7.centos.x86_64，norach表示32位64位通用。1）查询查询已安装的rpm包列表：rpm -qa | grep xxx查询所有rpm包：rpm -qa查询软件包是否安装：rpm -q 软件包名查询软件包信息：rpm -qi 软件包名查询软件包中的安装文件：rpm -ql 软件包名查询文件所属软件包：rpm -qf 文件全路径例：rpm -qf &#x2F;etc&#x2F;passwd 2）安装安装软件包：rpm -ivh 软件包全路径，-i安装，-h显示进度，-v显示安装信息例：rpm -ivh &#x2F;opt&#x2F;firefox-68.10.0-1.el7.centos.x86_643）卸载卸载安装包：rpm -e xx软件包名 [erase]强制卸载：rpm -e –nodeps xxx yum yum是一个Shell前端软件包管理器，基于rpm，能够从服务器中下载rpm包并安装，可以自动处理依赖关系，并一次性安装所以依赖，但需要连接网络。 -y:代替手动输入yes，自动执行安装查询服务器是否有可安装的xx软件：yum list | grep xxx查看可更新的软件：yum list updates查看已安装的软件：yum list installed安装包：yum install xxx删除软件：yum remove xxx更新所以软件：yum update更新一个软件：yum update xxx检查更新的包：yum check-update清除缓存目录下的软件包：yum clean all更新软件包缓存：yum makecache搜寻软件包：yum search xxx查看软件包信息：yum info xxx设置镜像的仓库：yum config-manager --add-repo http://mirrors.aliyun.com/repo/Centos-7.repo 影响yum使用的主要文件:基本设置： &#x2F;etc&#x2F;yum.conf仓库软件源集： &#x2F;etc&#x2F;yum.repo.d&#x2F;*.repo日志文件： &#x2F;var&#x2F;log&#x2F;yum.log *.repo的基本配置项：App-Stream BaseOS Extras[base]：名称，可以随意取name：描述repo含义baseurl：后面接地址，是指定一个固定地址enabled:是否启用此频道（1为启动，0为不启用）gpgcheck：是否需要查阅RPM文件内数字证书gpgkey：数字证书公钥文件所在位置，使用默认值 开启软件缓存 nano &#x2F;etc&#x2F;yum.conf 案例：使用yum安装firefoxrpm -e firefoxyum list | grep firefoxyum install firefox","categories":[{"name":"linux","slug":"linux","permalink":"https://aachou.github.io/categories/linux/"}],"tags":[],"author":"沧海一粟"},{"title":"Shell编程","slug":"Shell编程","date":"2023-11-11T04:58:45.000Z","updated":"2024-01-15T03:08:04.000Z","comments":true,"path":"2023/1111/","permalink":"https://aachou.github.io/2023/1111/","excerpt":"Shell是一个命令解释器，它提供一个向内核发送请求的界面系统级程序。","text":"Shell是一个命令解释器，它提供一个向内核发送请求的界面系统级程序。 1、shell入门脚本格式要求：以#!&#x2F;bin&#x2F;bash开头，脚本要有可执行权限。 编写一个shell脚本： vim hello.sh#!/bin/bashecho &quot;hello java~&quot; 脚本执行方式： 1）输入脚本的绝对或相对路径，前提要有执行权限 .&#x2F;hello.sh 2）sh +脚本，没有权限也能执行 sh .&#x2F;hello.sh 2、变量shell变量分为系统变量和自定义变量，变量名称可以由字母、数字、下划线组成，字母一般大写。 系统变量：$PATH $HOME $PWD $USER $SHELL显示当前所有变量：set定义变量：变量名&#x3D;值（等号不要空格）撤销变量：unset 变量声明静态变量：readonly 变量（不可以unset） #!/bin/bashA=10echo &quot;A=$A&quot; 将命令的返回值赋值给变量：A&#x3D;`date`或A&#x3D;$(date) 设置环境变量: export 变量名&#x3D;变量值 （将shell变量输出为环境变量\\全局变量）source 配置文件echo $变量名 案例：在&#x2F;etc&#x2F;profile中定义TOMCAT_HOME环境变量，查看环境变量的值，在另一个shell程序中使用TOMCAT_HOME 在profile文件中写入：export TOMCAT_HOME&#x3D;&#x2F;opt&#x2F;tomcat更新环境变量：source &#x2F;etc&#x2F;profile 位置参数变量： 在执行脚本时可以传入相应的参数，如：.&#x2F;myshell.sh 100 200 基本语法： $&#123;&#125;：获取变量的值，{}可省略；$n：(n代表数字，$0为命令本身，$1-9代表第一到第九个参数，10以上用大括号$&#123;10&#125;)；$@：代表所有参数，但区分每个参数；$# ：命令行中参数个数；$* ：代表所有参数，所有参数看为一个整体 预定义变量： $$:当前进程的进程号$!：后台运行的最后一个进程的进程号$?：最后一次执行命令的返回状态，0代表执行成功，非0失败 #!/bin/bashecho &quot;当前执行进程的id=$$&quot; #以后台运行一个脚本，并获取它的进程号。 .&#x2F;myshell.sh 100 200 &amp;echo &quot;最后一个执行进程id=$!&quot;echo &quot;执行结果=$?&quot; 3、shell注释单行注释：#多行注释： :&lt;&lt;!内容! 4、运算符（1）$$((运算式)) （2）$[运算式] （3）expr表达式（运算符之间要有空格） +、-、\\*、&#x2F;、%加减乘除取余 expr 5 + 3注意空格 案例1：计算(2+3)x4第一种方式res=$(((2+3)*4))或第二种res=$[(2+3)*4]或exprtemp&#x3D;`expr 2 + 3` res&#x3D;`$temp \\* 4` echo “$res” 5、条件判断(1)if语句 单分支： if [ 条件 ]then代码fi 两个分支： if [ 条件 ]then代码else代码fi 多分支： if [ 条件 ]then代码elif [ 条件 ]then代码else代码fi (2)条件语句： [ 条件 ] 注意左右空格 例： [ abc ] 返回true[ ] 返回false[ 条件 ] &amp;&amp; echo ok || echo !ok 条件满足执行后面语句 判断条件： 1)&#x3D;字符串比较 2)整数比较 -lt 小于（&lt;）-le 小于等于(&lt;&#x3D;)-eq 等于（&#x3D;&#x3D;）-gt 大于(&gt;)-ge 大于等于(&gt;&#x3D;)-ne 不等于(!&#x3D;) 3）按照文件权限判断 -r 有读权限-w 有写权限-x 有执行权限 4）按照文件类型判断 -f 文件存在&amp;普通文件-e 文件存在-d 文件存在&amp;为目录 案例：编写一个shell程序，输入一个数，大于大于60及格，小于不及格 #!/bin/bashif [ $1 -ge 60 ]thenecho &quot;及格&quot;elif [ $1 -lt 60 ]thenecho &quot;不及格&quot;fi 6、case语句case expression in pattern1) statement1 ;; pattern2) statement2 ;; pattern3) statement3 ;; #其他pattern情形 *) statement esac pattern支持正则表达式： * ：表示任意字符串。[abc]：表示 a、b、c 三个字符中的任意一个。比如，[15ZH] 表示 1、5、Z、H 四个字符中的任意一个。[m-n]：表示从 m 到 n 的任意一个字符。比如，[0-9] 表示任意一个数字，[0-9a-zA-Z] 表示字母或数字。| ：表示多重选择，类似逻辑运算中的或运算。比如，abc | xyz 表示匹配字符串 “abc” 或者 “xyz”。 expression 既可以是一个变量、一个数字、一个字符串，还可以是一个计算表达式，或者是命令的执行结果，只要能够得到 expression 的值就可以。pattern 可以是一个数字、一个字符串，甚至是一个简单的正则表达式。有时候相近的内容作为一个pattern时，这些内容以“|”隔开，比如 y|yes|YES)。如果 expression 和某个模式匹配成功，就会执行这模式后面对应的所有语句（该语句可以有一条，也可以有多条），直到遇见双分号;;才停止，然后整个 case 语句就执行完了，程序会跳出整个 case 语句，执行 esac 后面的其它语句。如果 expression 没有匹配到任何一个模式，那么就执行*)后面的语句，直到遇见双分号;;或者esac才结束。最后一个分支可以写;;，也可以不写。执行到 esac 都会结束整个 case in 语句。最后一个分支*)并不是什么语法规定，它只是一个正则表达式，*表示任意字符串。 case $1 in 1) echo “星期一” ;; 2) echo “星期二” ;; 3) echo “星期三” ;; #其他pattern情形 *) echo “others”esac 7、循环for循环案例一：编写一个num.sh，将输入的数字参数输出 #!/bin/bashfor i in &quot;$@&quot;doecho &quot;n is $i&quot;done 案例二：编写一个sum.sh对1到100求和输出结果 #!/bin/bashSUM=0for(( i=1;i&lt;=100;i++ ))do​ $SUM=$[$SUM+Si]doneecho $SUM while循环while [ 条件 ]do代码done 案例：从命令行输入一个参数n，计算1+2+…+n #!&#x2F;bin&#x2F;bashSUM=0i=1while [ $i -le $1 ]do​ SUM=$[ $SUM+$i ]​ i=$[ $i+1 ]doneecho $SUM 8、read读取输入-p : 读取时的提示；-t：读取等待的秒数 案例：读取控制台输入的两个数输出 read -p &quot;请输入一个数=&quot; NUM1echo $NUM1read -t 10 -p &quot;请在10秒内输入一个数=&quot; NUM2echo $NUM2 9、函数系统函数basename\\dirnamebasename返回路径后的文件名，dirname返回文件所在文件夹绝对路径 案例1：取出&#x2F;home&#x2F;myhome&#x2F;a.txt的a.txt文件名 basename /home/myhome/a.txt 案例2：取出&#x2F;home&#x2F;myhome&#x2F;a.txt的文件的绝对路径&#x2F;home&#x2F;myhome dirname /home/myhome/a.txt 自定义函数:function 函数名(){ } 调用函数：函数名+参数值 案例：定义一个函数getSum()求出输入参数之和 #!&#x2F;bin&#x2F;bashfunction getSum()&#123;​ SUM=$[$n1+$n2]​ echo &quot;$SUM&quot;&#125;read -p &quot;请输入一个数n1=&quot; n1read -p &quot;请输入一个数n2=&quot; n2getSum $n1 $n2 10、备份数据库练习在&#x2F;usr&#x2F;sbin下创建数据库备份脚本文件mysql_db_backup.sh #!&#x2F;bin&#x2F;bashBACKUP=/data/backup/db#时间DATETIME=$(date +%Y-%m-%d_%H%M%S)echo $DATETIME#主机HOST=localhost#用户DB_USER=root#密码DB_PASS=root#数据库名DATABASE=MyDB#创建备份目录[ ! -d &quot;$&#123;BACKUP&#125;/$&#123;DATETIME&#125;&quot; ] &amp;&amp; mkdir -p &quot;$&#123;BACKUP&#125;/$&#123;DATETIME&#125;&quot;#备份mysqldump -u&#123;DB_USER&#125; -p&#123;DB_PASS&#125; --host=$&#123;HOST&#125; -q -R --datebases $&#123;DATABASE&#125; | gzip &gt; $&#123;BACKUP&#125;/$&#123;DATETIME&#125;/$DATETIME.sql.gz#打包cd $&#123;BACKUP&#125;tar -zcvf $DATETIME.tar.gz $&#123;DATETIME&#125;#删除备份目录rm -rf $&#123;BACKUP&#125;/$&#123;DATETIME&#125;#删除10天前备份数据find $&#123;BACKUP&#125; -atime 10+ -name &quot;\\*.tar.gz&quot; -exec rm -rf &#123;&#125; \\echo &quot;备份$DATABASE 成功~&quot; 每天2点半定时备份crontab -e30 2 * * * /usr/sbin/mysql_db_backup.sh","categories":[{"name":"linux","slug":"linux","permalink":"https://aachou.github.io/categories/linux/"}],"tags":[],"author":"沧海一粟"},{"title":"Linux下进行JavaEE开发,安装JDK、Tomcat、MySQL","slug":"Linux下进行JavaEE开发-安装JDK、Tomcat、MySQL","date":"2023-11-06T09:38:47.000Z","updated":"2023-12-04T00:05:13.000Z","comments":true,"path":"2023/1106/","permalink":"https://aachou.github.io/2023/1106/","excerpt":"(1)安装JDK步骤： 1、创建目录mkdir &#x2F;opt&#x2F;jdk 2、将jdk压缩包通过xftp6上传到该目录 3、cd &#x2F;opt&#x2F;jdk 4、tar -zxvf jdk-8u151-linux-x64.tar.gz 5、mkdir &#x2F;usr&#x2F;local&#x2F;java","text":"(1)安装JDK步骤： 1、创建目录mkdir &#x2F;opt&#x2F;jdk 2、将jdk压缩包通过xftp6上传到该目录 3、cd &#x2F;opt&#x2F;jdk 4、tar -zxvf jdk-8u151-linux-x64.tar.gz 5、mkdir &#x2F;usr&#x2F;local&#x2F;java 6、mv &#x2F;opt&#x2F;jdk&#x2F;jdk1.8.0_151 &#x2F;usr&#x2F;local&#x2F;java 7、修改环境变量配置文件vim &#x2F;etc&#x2F;profile 8、export JAVA_HOME=/usr/local/java/jdk1.8.0_151 9、export PATH=$JAVA_HOME/bin:$PATH 10、更新环境变量source &#x2F;etc&#x2F;profile 测试是否配置成功，编写hello.java输出hello java。 (2)安装Tomcat步骤： 1、创建文件夹mkdir &#x2F;opt&#x2F; tomcat 2、将apache-tomcat-8.5.95.tar.gz上传至该文件夹 （注意：不要下载src源码版或exe二进制版的包） 3、解压tar -zxvf apache-tomcat-8.5.95.tar.gz 4、进入解压目录&#x2F;bin，.&#x2F;startup.sh启动tomcat（用户要有执行权限） 5、防火墙开放8080端口 firewall-cmd --permanent --add-port=8080/tcp firewall-cmd --reload (3)安装MySQL步骤 1、从Mysql官网或阿里云镜像网站https://mirrors.aliyun.com/mysql，下载MySQL的安装包mysql-5.7.38-1.el7.x86_64.rpm-bundle.tar 2、新建文件夹&#x2F;opt&#x2F;mysql 3、删除CentOS原有的Mariadb数据库，通过rpm -qa | grep maria查看 4、删除mariadb rpm -e --nodeps maria rpm -e --nodeps mariadb-libs-5.5.68-1.el7.x86_64 5、通过xftp将下载好的mysql安装包传输到&#x2F;opt&#x2F;mysql下 6、解安装包mysql-5.7.37-1.el7.x86_64.rpm-bundle.tar，得到rpm包如下 tar -xvf mysql-5.7.38-1.el7.x86_64.rpm-bundle.tar mysql-community-client-5.7.38-1.el7.x86_64.rpmmysql-community-common-5.7.38-1.el7.x86_64.rpmmysql-community-devel-5.7.38-1.el7.x86_64.rpmmysql-community-embedded-5.7.38-1.el7.x86_64.rpmmysql-community-embedded-compat-5.7.38-1.el7.x86_64.rpmmysql-community-embedded-devel-5.7.38-1.el7.x86_64.rpmmysql-community-libs-5.7.38-1.el7.x86_64.rpmmysql-community-libs-compat-5.7.38-1.el7.x86_64.rpmmysql-community-server-5.7.38-1.el7.x86_64.rpmmysql-community-test-5.7.38-1.el7.x86_64.rpm 7、开始安装对应rpm包 rpm -ivh mysql-community-common-5.7.38-1.el7.x86_64.rpmrpm -ivh mysql-community-client-plugin-5.7.38-1.el7.x86_64.rpmrpm -ivh mysql-community-libs-5.7.38-1.el7.x86_64.rpmrpm -ivh mysql-community-client-5.7.38-1.el7.x86_64.rpmrpm -ivh mysql-community-server-5.7.38-1.el7.x86_64.rpm 8、运行mysql systemctl start mysqld.service (默认开机自启动) 9、查看当前mysql密码 grep &quot;password&quot; /var/log/mysqld.log 10、登录mysql修改密码 mysql -u root -p 密码 set password for &#39;root&#39;@&#39;localhost&#39;=password(&quot;12345678&quot;);或update user set authentication_string=password(&quot;12345678&quot;) where user=&#39;root&#39;;或ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;12345678&#39;; 可设置密码策略：默认为1，要求长度，数字，字母大小写，特殊字符。 set global validate_password.policy&#x3D;0; 11、使密码生效，flush privileges; 12、Ctrl+Z退出","categories":[{"name":"linux","slug":"linux","permalink":"https://aachou.github.io/categories/linux/"}],"tags":[],"author":"沧海一粟"},{"title":"虚拟机IP突然消失的解决方法","slug":"虚拟机IP突然消失的解决方法","date":"2023-11-02T01:19:39.000Z","updated":"2023-12-01T19:43:59.000Z","comments":true,"path":"2023/1102/","permalink":"https://aachou.github.io/2023/1102/","excerpt":"基础方法如下：如果这个文件 ifcfg-ens33已经将ONBOOT改为yes了，之前用的还好好的还有ip地址的但是现在没有了。","text":"基础方法如下：如果这个文件 ifcfg-ens33已经将ONBOOT改为yes了，之前用的还好好的还有ip地址的但是现在没有了。 1.先重启网络服务 sudo service network restart但是重启网络失败的话，那就执行下边命令。 出现问题解决方式：禁用NetworkManager 2.执行下边这两条命令 systemctl stop NetworkManagersystemctl disable NetworkManager 3.执行完成之后重新启动网络服务。 sudo service network restart 然后重新启动网络服务就OK了 4.输入ip addr查看ip地址。在使用VMware过程中，有时候出现ssh工具连接不上的情况，在VMware中使用ip addr或者ifconfig命令查看ip，发现ip已消失 若为kali系统，可以试试以下命令：dhclient eth0eth0为网卡名字，该操作为网卡自动分配ip。 解决办法二：1、查看VMware的网络设置，网络适配器，将网络适配器设置为NAT模式2、设置VMware的虚拟网络编辑器，设置NAT模式的网段。（点击虚拟网络编辑器”更改设置“。如果不点击这里，“还原默认设置”按钮将是灰色的）3、点击虚拟网络编辑器“还原默认设置”。 解决办法三：重启网卡：service network restart如果报错，则可以停止网络管理，systemctl stop NetworkManager。若为kali则重启网络服务为service networking restart 解决办法四：由于启动服务器时未加载网卡，导致IP地址初始化失败。修改网络初始化配置，设定网卡在系统启动时初始化。cat /etc/sysconfig/network-scripts/ifcfg-ens33 进入目录：&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts 编辑文件：vi ifcfg-ens33，将ONBOOT&#x3D;no改为ONBOOT&#x3D;yes","categories":[{"name":"虚拟机","slug":"虚拟机","permalink":"https://aachou.github.io/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA/"}],"tags":[],"author":"沧海一粟"},{"title":"linux找回root密码，CentOS7","slug":"linux找回root密码，CentOS7","date":"2023-10-27T04:55:09.000Z","updated":"2023-10-27T04:59:49.000Z","comments":true,"path":"2023/1027/","permalink":"https://aachou.github.io/2023/1027/","excerpt":"linux找回密码需要进入单用户模式，linux运行级别有0~6，可以通过init切换。","text":"linux找回密码需要进入单用户模式，linux运行级别有0~6，可以通过init切换。 0：关机 1：单用户模式 2：多用户状态无网络 3：多用户状态有网络muti-user.target 4：系统未使用保留用户 5：图形用户graphical.target 6：系统重启 进入单用户模式通过以下步骤找回密码： 1.进入系统，在开机界面按住’e’进入编辑界面 2.进入编辑界面，找到’Linux16’开头的行，在末尾输入: init&#x3D; &#x2F;bin&#x2F;sh 3.按住快捷键ctrl+x进入单用户模式 4.在光标闪烁的位置输入：mount -o remount,rw &#x2F; ，完成后enter回车 5.在新的一行最后输入passwd回车，输入密码即可 6.接着输入touch &#x2F;.autorelabel回车 7.然后输入exec &#x2F;sbin&#x2F;init回车，等待系统完成重启","categories":[{"name":"linux","slug":"linux","permalink":"https://aachou.github.io/categories/linux/"}],"tags":[],"author":"沧海一粟"},{"title":"7月感悟","slug":"7月感悟","date":"2023-07-24T13:43:40.000Z","updated":"2023-08-09T10:13:33.000Z","comments":true,"path":"2023/0724/","permalink":"https://aachou.github.io/2023/0724/","excerpt":"7月份马上了快结束了，我已经从大学的苦海中暂时脱离出来了，在快毕业的时候我已经写了一篇感悟，那时还在考研复试，现在什么都结束了，研也考上了，已经离开学校了。","text":"7月份马上了快结束了，我已经从大学的苦海中暂时脱离出来了，在快毕业的时候我已经写了一篇感悟，那时还在考研复试，现在什么都结束了，研也考上了，已经离开学校了。 在4月回到学校后，每天都是在宿舍休息，休息其实在放纵自己，虽然毕设还没弄完，但是知道已经完成的差不多了，就躺在床上玩手机。到了晚上一般都会买瓶饮料，开始了大吃大喝，不过想想这几年遭的罪，喝饮料也是一种慰藉。有时候想到正在进行的毕设，又会打开软件写代码。没有人真正担心毕设过不了，确实不用担心，因为大家都清楚学校啥样，无疑这几个月是大学最为轻松的时光。 于是在5月初劳动节的那几天，有几个哥们想出去玩，商量着该去哪里花他们的假期。和宿友模棱两半天，我们三个决定去青岛玩几天。这是我们几个第一次去海边，我江西的，他两河南的，三个内陆孩子对海的向往得到了实现。从山东的日照再到青岛，我们住在一个小县城的小宾馆里，毕竟一人430，条件就这样了。我们第二天去的青岛，我当时是坐大巴车去的，坐了好几个小时，车上几乎是跟我们差不多的大学生。我们估计都是第一次看海，海的美景确实很震撼很吸引人，特别是在青岛胶州湾大桥上，那被海所包围的场景让我记忆深刻。进入熙熙攘攘的市区，青岛这座城市慢慢的在我眼前晃动。不过这一天并不好受，早上6点起来就出发，一直到10点，下车了，还是在海边下的车，临近网红景点栈桥。没走几步就累了，放纵的后果很大程度上减缓了我对青岛探索的步伐，之后我们分别到小青岛、海底世界、第一海水浴场、八大关和中山公园游玩，走到中山公园已经下午6点了，中间午饭都是问题，于是我受不了在浴场旁边的面馆解决，本来还想吃一顿海鲜自助，不过中午已经人满为患。期间走路还被圆石头柱绊了一跤，走了个趔趄，顺口一句国粹，这是这趟旅行的一大不快之一。对我们来说，青岛非常大，逛也逛不完，景区非常多，到了中山公园就止步了，哥几个准备回去了，有些遗憾，确实一天也玩不了什么。 6月初该提交论文的初稿了，我毕设也做完了，心里没什么负担。期间我们进行了答辩，答辩就那样，基本去了就过了，老师也不会故意让学生延毕的。过了两个礼拜，学校就举行毕业典礼，我们拿到了双证就这样毕业了，三年疫情，连工作都不好找，人都傻了，但还是向前走吧，23届的毕业生简直不能再惨了。我们宿舍6个人，四个考研，只有我上岸了，没考上的都准备再战一年。其余两个，一个签了三方去工作了，另一个混毕业，回家准备混进公司。就这样，大学宿舍生活结束了，大家各自东西南北中。 7月下我收到了研究生学校的录取通知书，不过并不开心，因为我不喜欢学校的生活，压抑沉闷，最主要的是没钱，经济上的问题一直催促我要早点工作赚钱，我很焦虑。而且，作为学生身份，难免要面对各种目光，我想要站起来，做一次自己的思考和选择 ，有一个稳定的环境真正让我能够放松下来，我还想看看外面的世界呢！不能再荒废下去了！","categories":[{"name":"碎碎念","slug":"碎碎念","permalink":"https://aachou.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}],"tags":[],"author":"沧海一粟"},{"title":"机器学习概念初步","slug":"机器学习概念初步","date":"2023-03-14T15:00:56.000Z","updated":"2023-08-09T10:13:40.000Z","comments":true,"path":"2023/0314/","permalink":"https://aachou.github.io/2023/0314/","excerpt":"最近在学关于机器学习的东西，感觉有点难消化，但还是坚持啃一啃，做一点笔记","text":"最近在学关于机器学习的东西，感觉有点难消化，但还是坚持啃一啃，做一点笔记 非显著式编程：让计算机自己总结事物的规律，通过已知的数据学习经验来获取算法最好性能指标的过程，来预测未知的样本。 打标签label：告诉机器数据是什么，对数据进行标记。 收益函数reward function：机器在特定环境下的行为所带来的收益。 监督学习supervised learning：从所有带标签的数据训练集中推出一个功能规律的机器学习 无监督学习unsupervised learning：从没有标签的的数据集中分析特征，推断出数据的关系的机器学习(聚类clustering；em算法expectation maximization；主成分分析法principle component analysis） 半监督学习semi-supervised learning：从带有少量标签的数据样本中推出经验规律的学习。 强化学习reinforement learning：计算机通过与环境的互动逐渐强化自己的行为模式 监督学习根据数据标签是否存在的分类，传统的监督学习：监督学习，无监督学习，半监督学习(支持向量机SVM，人工神经网络artificial neural network，深度神经网络deep neural network)。基于标签的固有属性，监督学习分为分类classification(标签是离散值)和回归regression(标签是连续值)，如识别某张人脸，人脸对比和预测股票，房价。 线性可分linear separable：一条直线可以分割两类数据集 线性不可分nonlinear separable：一条直线不可以区分两类数据集 特征空间：n个特征组成的n维平面，在特征空间上距离接近的样本，他们属于同一个类别的概率会更高 简单的神经元MP模型，基于神经元的生理结构建立起单个神经元的数学模型，多个加权输入偏置求和，经过激活函数非线性变换。 卷积神经网络convolution neural network：专门用来处理类似网络结构的数据的神经网络。卷积网格是指那些只至少在网络的一层中使用卷积计算来代替一般的矩阵计算的神经网络。卷积神经网络基本结构由输入层、卷积层、池化层、激活函数层和全连接层，输入层代表一张图片的像素矩阵；卷积层对图像和滤波矩阵filter做内积操作，每计算玩一个窗口(卷积核)，窗口平移直到计算完所有图像数据；池化层保留主要的特征同时减少参数(降维,效果类似PCA)和计算量,防止过拟合,提高模型泛化能力；激活函数进行非线性变换；全连接层则起到将学到的特征映射到样本标记空间。 depth深度：神经元个数，代表了滤波器的个数；stride步长：决定滑动多少步到边缘. 神经网络后向传播算法Background Propogation：核心是梯度下降法求局部极值。 自编码器auto-encoder：是一种无监督领域的神经网络模型，它可以表征到输入数据的隐含特征，这称为编码，同时用学习到的新特征可以重构出原始输入数据，称之为解码。比主成分分析法更强一些，能表征非线性变换。自动编码器还可以用于特征降维，将学习到的新特征送入有监督学习模型中，所以可以作为特征提取器。在引入语音识别系统后，EA代替了隐含马尔科夫模型Morkov和高斯混合模型。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://aachou.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[],"author":"沧海一粟"},{"title":"写在大学最后的时光","slug":"写在大学最后的时光","date":"2023-02-08T08:49:24.000Z","updated":"2023-08-09T10:13:45.000Z","comments":true,"path":"2023/0208/","permalink":"https://aachou.github.io/2023/0208/","excerpt":"当决定考研的那一刻，我并不知道我为什么一定要考研，内心的我是这样想的：考上了研究生，将来会更有优势。想法非常的单纯，在将近一年的准备的过程中，感觉身心疲惫，简直就是在折磨自己，每天三点一线的模式，大部分时间就是坐在板凳上看书学习，只能靠着听音乐和以后所谓的“美好将来”的幻想来迷惑自己","text":"当决定考研的那一刻，我并不知道我为什么一定要考研，内心的我是这样想的：考上了研究生，将来会更有优势。想法非常的单纯，在将近一年的准备的过程中，感觉身心疲惫，简直就是在折磨自己，每天三点一线的模式，大部分时间就是坐在板凳上看书学习，只能靠着听音乐和以后所谓的“美好将来”的幻想来迷惑自己。 到了考试前终于停下了，整个人一度的摆烂，考试那几天几乎没有看书，那些天有特殊情况，学校让隔离了，本来大家都要回家隔离再回来考试的，全宿舍都被感染了新冠，考试当天就发烧头痛。已经无所谓了，就这两三天，也没什么心思看书，只希望早点回家。当坐在回去的列车上，看着窗外飞速而过的树木，我知道这一年真的太不容易。 就像22年的卡塔尔世界杯，梅西带领阿根廷闯进世界杯决赛，我在拼命的刷数学题，我们每个人都在拼命地朝着目标前进，都在付出，最后阿根廷赢了，而我并不知道自己赢没赢，人生真的是一场比赛或者游戏吗？ 回想大学四年的时光，自己懵懵懂懂地进入大学，把以前的无知和天真带了进来，左右折腾也没有找到那些大牛口中声称的“热爱”，可能是校园太小了吧，或者是我的能力和资源有限的原因吧，我迷茫地花掉了大学的大部分时光，期间也曾起来试图摆脱平庸，和其他人一起考了大学英语四六级，但是考过了又怎样。进入大三了，我又开始陷入另一种迷茫，要不要考研？网上各种声音，说考研是人生的一个转折点；说考研是一种逃避毕业工作的途径；又说考研是为了将来更好的自己，还说是在提高自己，我不懂在提高自己的什么，血压和体重吗？还是自己的受骗率？只是为了学历就算了，说实话，我还是挺佩服那些努力考上研的同学，网上基本上都是知名大学，每当看到我们这些双非院校的能逆袭985、211的视频，我更加迷茫了，我不知道是为了什么，我只是照着别人的路线继续按部就班地走下去罢了，从来没有听听内心的真实想法。所以一年下来也非常痛苦，搬书来来回回，晚上10点多才回宿舍，总是在逃避着什么。我也不清楚，进入大学以来一个人突然地像被释放了，自由独立多了，没有什么约束，也就迷茫了。从来没有人向我介绍大学生活，也没有人告诉我们大学里应该怎么做，网上倒是有很多教程，有关生活的各个方面，都被安排的明明白白。 马上就要毕业了，我依然是这样的不知所措，准备毕设加可能的研究生复试加就业，我不可能面面俱到，人生就是这样，有得有失，我准备好了面对结果了。也许我并不在乎最终结果，大概只是喜欢努力过后能有一点收获的感觉吧，可能有付出并不会有回报，就挺打击的。 如果我如愿考上研究生，那就针对的起大学这几年的颓废和迷茫吗？我又陷入了一种“迷茫”，我在读研究生，每天看着各种文献，敲着代码，导师可能一个星期就联系一次，等到毕业了又不知道如何面对以后的生活，如何融入这个陌生的社会，如何在这个世界生存下去，只能说学校建了一堵厚厚的墙，把里面的我们保护的很好，看起来我只是换了一个学校继续迷茫罢了。当初大学填报志愿的时候只是怀着一丝好奇选择了计算机专业，大学之前也没有太多机会接触计算机，直到枯燥的课程扑面而来，我才算是入门计算机了，之后的话几乎停留在理论的基础上，运用的最多是和同学一起玩游戏，大学期间电脑游戏也算是入门了。 可能是时间的原因，推着我们向前走，直到认清自己，开始接受现实，我只是一个“被编好程序的人”，安排来接受教育之后进入社会打工罢了，不然怎么叫程序员呢。当程序员也好呀，走到了人生的最后几步了，不用担心没有钱吃喝住了，心里踏实平静多了，也许不迷茫了，当然买房可能是个问题，不过比待业在家啃老强，好歹有个稳定收入养活一家子。以后操心事多了，就不继续遐想了，总之顺其自然吧，父母希望子女有个出息，但是我也就这样了，他们知不知道我们现在的压力呢，年轻人拼了命的努力，最后只为了在目标城市买到一块安生之地。 虽然现在考试分数还没出来，但是毕设和企业春招已经开始了，是时候走出迷茫了，走一个令人舒畅的路了，疫情这几年真不容易，真是难受！","categories":[{"name":"碎碎念","slug":"碎碎念","permalink":"https://aachou.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}],"tags":[],"author":"沧海一粟"},{"title":"关于28岁的字节工程师离世的感慨","slug":"关于28岁的字节工程师离世的感慨","date":"2022-02-24T08:36:49.000Z","updated":"2023-08-09T10:13:52.000Z","comments":true,"path":"2022/0224/","permalink":"https://aachou.github.io/2022/0224/","excerpt":"此前网传年轻的字节跳动员工吴同学已离世，字节跳动的内网一则通知显示，从医院获知，吴同学不幸离世。经过大概是这样的，2月21日晚上18点，28岁的吴同学走进字节跳动的健身房，吴同学在运动约1小时后出现头晕现象，情况加重。当晚19时30分许，急救人员到场救治，并将其送上救护车","text":"此前网传年轻的字节跳动员工吴同学已离世，字节跳动的内网一则通知显示，从医院获知，吴同学不幸离世。经过大概是这样的，2月21日晚上18点，28岁的吴同学走进字节跳动的健身房，吴同学在运动约1小时后出现头晕现象，情况加重。当晚19时30分许，急救人员到场救治，并将其送上救护车。2月23日0时30分，医院反馈，该员工情况危重。不久，吴同学便去世了。 说到这，我是软件的本科生，起初同样是怀着兴趣报考了计算机相关的专业，以至于来到了之后不太满意的学校。28岁可以称他为‘学长’了，大了我几岁，但还是年轻的生命啊！吴学长有着名校的学历，很早就有了从事IT行业的想法，在毕业后进入字节努力地工作，结了婚，买了房，出了书，几个月前妻子还有了孩子。很难想到这样一位年轻的学长，本应在日后获得更加幸福美好的生活，然而现实却是如此的残酷，他是匆匆地离开世间。 从吴学长生前的个人平台和当前报道来看，吴学长是一位有梦想、活泼开朗的人，而且能力还是很强的，还买了房，虽然是贷款的。尽管在医院奋力的抢救，还是没能挽回吴学长的生命。吴学长的逝世给了吴学长妻子很大的压力，她打算退了房子回到小县城，和她母亲孕育孩子，抚养成人。 关于以上的消息，我对吴学长的离开感到难过和一点惋惜，惋惜他是一位值得被生活善待的人，结局令人悲痛；还对软件专业的自己感到迷茫，因为面临着就业和考研的烦恼，现在怀疑要不要继续学习计算机或进入相关的行业；也对计算机相关专业在读的同学或即将从事计算机相关行业的人感到一丝忧虑和庆幸，庆幸我们还有当前健康的身体和生活，庆幸我们还有一些选择。 吴学长的离世不是孤例，另一位26岁的年轻人也上了热搜。上海一家设计事务所的设计师，疑似因加班过度，于15日清晨在出租屋内猝死。两个年轻人的离世消息撞到一起，给人的冲击格外大，难道生活的真相就是如此吗？大家都知道IT行业普遍加班，工作压力很大，生活压力也大，而且相关从业者都生活在大城市。据了解，字节这样的公司喜欢自律能力强的人，基本上福利多，有免费三餐和酒水，免费健身房，五险一金等等，在这样的环境中，人不想向上爬都难，回到家也是不断地学习。 总之，IT行业就一个字，“卷”！因为社会的某种普遍共识，行业薪资高，不光是入职找工作卷，高考和研究生报考也开始卷起来了，考啥一定考计算机相关的专业，甚至跨考，光想着以后会待遇高，可是也看到了报考人数上涨，招生扩招都无法满足大家的录取，只能越来越卷。不是其他行业不卷，是计算机卷得太厉害了，炸天了！不管适不适合读相关专业，做不做的了相关工作，都涌入大潮之中，特别是人工智能开始发展兴起之后。 与此同时，在当前像字节这样的大公司里工作，可以自由地享受各种优厚待遇，也会感受到了一种被限制的自由。尽管有弹性的工作制，工作的员工要完成各种任务，和优秀的人在一起会更优秀，但是也要抗住辛苦和劳累。不是说大家不要努力向上，而是看看给自己带来了什么，忽视了长远的利益发展和被迫劳累所带来的危害，即使是强壮的巨人最终也会倒下。 当时看到吴学长的新闻，就十分感慨，他为何遭遇这样的不幸。因为很难说清他的猝死和加班有没有关联，但应该反思一下，如何在如此的生活压力下，让巨头字节和它的员工的心都保持跳动。·","categories":[{"name":"碎碎念","slug":"碎碎念","permalink":"https://aachou.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}],"tags":[],"author":"沧海一粟"},{"title":"ACM、OI、IOI编程竞赛模式介绍","slug":"ACM、OI、IOI编程竞赛模式介绍","date":"2021-11-23T12:07:51.000Z","updated":"2023-08-09T10:14:04.000Z","comments":true,"path":"2021/1123/","permalink":"https://aachou.github.io/2021/1123/","excerpt":"介绍一下编程比赛：ICPC是国际大学生程序设计竞赛(ACM International Collegiate ProgrammingContest（ACM-ICPC或ICPC）是由美国计算机协会(ACM)主办的，一项旨在展示大学生创新能力、团队精神和在压力下编写程序、分析和解决问题能力的年度竞赛。经过近30多年的发展，ACM国际大学生程序设计竞赛已经发展成为最具影响力的大学生计算机竞赛。","text":"介绍一下编程比赛：ICPC是国际大学生程序设计竞赛(ACM International Collegiate ProgrammingContest（ACM-ICPC或ICPC）是由美国计算机协会(ACM)主办的，一项旨在展示大学生创新能力、团队精神和在压力下编写程序、分析和解决问题能力的年度竞赛。经过近30多年的发展，ACM国际大学生程序设计竞赛已经发展成为最具影响力的大学生计算机竞赛。 CCPC中国大学生程序设计竞赛(China Collegiate Programming Contest) 是由中国大学生程序设计竞赛协会主办的面向世界大学生的国际性年度赛事，旨在激励当代大学生运用计算机编程技术和技能来解决实际问题，激发其学习算法和程序设计的兴趣，培养其团队合作意识、创新能力和挑战精神。 IOI是国际信息学奥林匹克竞赛 (International Olympiad in Informatics），是面向中学生的一年一度的信息学科竞赛。举办历史较长，第一届国际信息学奥林匹克竞赛于1989年在保加利亚举行。 NOI是中国计算机学会举办了全国青少年计算机程序设计竞赛，即全国青少年信息学奥林匹克竞赛(简称NOI）。 NOIP是全国青少年信息学奥林匹克联赛（National Olympiad in Informatics in Provinces）自1995年至今已举办19次，每年由中国计算机学会统一组织。 介绍一下编程比赛中最常见的三种赛制：ACM赛制、OI赛制、IOI赛制。先普及一些常见的竞赛术语：提交反馈，实时排名，按点给分，题数罚时，测试点(测试用例)等。 提交反馈：一般为“通过AC”、“答案错误”、“运行超时”等等反馈 实时排名：比赛中能看到排名，如ACM赛制 全有或全无：只有通过全部测试点才算通过，只要有一个测试点不通过就不能AC(答案accept) 按点给分：每道题有多个测试点，通过几个测试点就给相应分值 题数罚时：题数多者排名靠前，只有当题数相同时才比较时间，时间少者排名靠前，或再比较罚时，罚时为提交错误答案给予相应的罚时，罚时和比赛时间没有关系，只用来排名，每做错一道题会有罚时相加，罚时少排名靠前。 先看通过的题目数量，单独绿色表示通过，然后看罚时，罚时短的靠前，每个题目下面黑色数字表示做出这个题的时间，然后把ac的题的时间数累加到罚时中，其间每一次提交运行结果被判错误的话将被加罚20分钟时间，未正确解答的试题不记时。红色- 表示没通过的题和错误提交次数，蓝色的表示比赛结束后的通过。 赛制 提交反馈 实时排名 计分方式 排名方式 相关比赛 ACM制 有 有 全有或全无 题数+时间 ICPC、CCPC、牛客小白赛、传智杯 OI制 无 无 按点给分 分数 NOI、计算机能力挑战赛、蓝桥杯 IOI制 有 有 按点给分 分数 PAT、团体程序设计天梯赛、CCF ACM赛制：每道题提交之后都有反馈，但看不到错误的测试样例(leetcode周赛可以看到)，每道题都有多个测试点，每道题必须通过了所有的测试点才算通过。每道题不限制提交次数，没通过的话会有罚时，比赛过程中可以看到实时排名，通过题数相同的情况下按照答题时间+罚时来排名。 ACM赛制的比赛：ICPC、CCPC、codeforces、leetcode周赛及全国编程大赛、传智杯 OI赛制：每道题提交之后都没有反馈，根据每道题通过的测试点的数量获得相应的分数。每道题不限制提交次数，如果提交错误没有任何惩罚，仅以最后一次提交为准，赛后按照总得分来排名。 OI赛制的比赛：NOI、考研机试、蓝桥杯、计算机能力挑战赛。 IOI赛制：每道题提交之后都有反馈，可以实时看到自己每道题得了多少分，但看不到错误的测试样例。每道题都有多个测试点，根据通过的测试点的数量获得相应的分数。每道题不限制提交次数，如果提交错误没有任何惩罚。比赛过程中一般可以看到实时排名，按照总得分来排名。IOI赛制是结合了OI赛制和ACM赛制的特点。 IOI赛制的比赛：PAT、团体程序设计天梯赛、CCF、CSP、洛谷月赛。 注意Tips：OI赛制和IOI赛制没有提交限制，提交错误也没有惩罚，所以可以大胆地提交，但ACM赛制的罚时会很大拉开差距。","categories":[{"name":"碎碎念","slug":"碎碎念","permalink":"https://aachou.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}],"tags":[],"author":"沧海一粟"},{"title":"Github-Readme-Stats项目介绍","slug":"Github-Readme-Stats项目介绍","date":"2021-09-27T09:25:51.000Z","updated":"2023-08-09T10:14:11.000Z","comments":true,"path":"2021/0927/","permalink":"https://aachou.github.io/2021/0927/","excerpt":"这个项目可以在你的README中获取动态生成的 GitHub 统计信息，生成有你的github数据(包括总提交数Commits、项目被收藏数Stars、总PR数、贡献次数Contributed)，编程语言使用情况，和Pinned推荐置顶项目仓库卡片","text":"这个项目可以在你的README中获取动态生成的 GitHub 统计信息，生成有你的github数据(包括总提交数Commits、项目被收藏数Stars、总PR数、贡献次数Contributed)，编程语言使用情况，和Pinned推荐置顶项目仓库卡片。这个README是在以用户名命名的仓库中，例如’coderxm’，这是一个特殊的仓库，github会告诉你，而不是coderxm.github.io命名的仓库，这个仓库一般用来建立个人博客，而且会得到一个和仓库名一样的个人域名，使用GItPage就能获得。而coderxm这个仓库是用来介绍自己的 profile，一般只有README.md一个文件，打开github个人主页的时候，就能看到这个profile，但是利用这个项目可以得到方便的扩展和美化，项目是利用javascript写的，部署和配置都很简单。有如下配置： GitHub 统计卡片将这行代码复制到你的 markdown 文件中，就是如此简单！ 更改 ?username= 的值为你的 GitHub 用户名。 1[![Anurag&#x27;s GitHub stats](https://github-readme-stats.vercel.app/api?username=anuraghazra)](https://github.com/anuraghazra/github-readme-stats) 隐藏指定统计想要隐藏指定统计信息，你可以调用参数 ?hide=，其值用 , 分隔。 选项：&amp;hide=stars,commits,prs,issues,contribs 1![Anurag&#x27;s GitHub stats](https://github-readme-stats.vercel.app/api?username=anuraghazra&amp;hide=contribs,prs) 将私人项目贡献添加到总提交计数中你可以使用参数 ?count_private=true 把私人贡献计数添加到总提交计数中。 注：如果你是自己部署本项目，私人贡献将会默认被计数，如果不是自己部署，你需要分享你的私人贡献计数。 选项: &amp;count_private=true 1![Anurag&#x27;s GitHub stats](https://github-readme-stats.vercel.app/api?username=anuraghazra&amp;count_private=true) 显示图标如果想要显示图标，你可以调用 show_icons=true 参数，像这样： 1![Anurag&#x27;s GitHub stats](https://github-readme-stats.vercel.app/api?username=anuraghazra&amp;show_icons=true) 主题你可以通过现有的主题进行卡片个性化，省去手动自定义的麻烦。 通过调用 ?theme=THEME_NAME 参数，像这样： 1![Anurag&#x27;s GitHub stats](https://github-readme-stats.vercel.app/api?username=anuraghazra&amp;show_icons=true&amp;theme=radical) 主题样式有dark, radical, merko, gruvbox, tokyonight, onedark, cobalt等几个主题，一般用dark、algolia，默认主题也行。详细见项目地址！ 自定义卡片样式你可以通过使用 URL 参数的方式，为你的 Stats Card 或 Repo Card 自定义样式。 常用选项： title_color - 卡片标题颜色 （十六进制色码） text_color - 内容文本颜色 （十六进制色码） icon_color - 图标颜色（如果可用）（十六进制色码） bg_color - 卡片背景颜色 （十六进制色码） 或者 以 angle,start,end 的形式渐变 hide_border - 隐藏卡的边框 (布尔值) theme - 主题名称，从所有可用主题中选择 cache_seconds - 手动设置缓存头 （最小值: 1800，最大值: 86400） locale - 在卡片中设置语言 (例如 cn, de, es, 等等) bg_color 渐变你可以在 bg_color 选项中提供多个逗号分隔的值来呈现渐变，渐变的格式是 :- 1&amp;bg_color=DEG,COLOR1,COLOR2,COLOR3...COLOR10 缓存的注意事项: 如果 fork 数和 star 数 少于 1k , Repo 卡片默认缓存是 4 小时 （14400 秒） ，否则是 2 小时（7200）。另请注意缓存被限制为最短 2 小时，最长 24 小时。 统计卡片专属选项: hide - 隐藏特定统计信息 (以逗号分隔) hide_title - (boolean) hide_rank - (boolean) show_icons - (boolean) include_all_commits - 统计总提交次数而不是仅统计今年的提交次数 (boolean) count_private - 统计私人提交 (boolean) line_height - 设置文本之间的行高 (number) Repo 卡片专属选项: show_owner - 显示 Repo 的所有者名字 (boolean) 语言卡片专属选项: hide - 从卡片中隐藏指定语言 (Comma seperated values) hide_title - (boolean) layout - 在两个可用布局 default &amp; compact 间切换 card_width - 手动设置卡片的宽度 (number) GitHub 更多置顶GitHub 更多置顶允许你在使用 GitHub readme profile 时，在个人资料中置顶多于6个repo 。你不再受限于置顶最多 6 个存储库了。复制粘贴这段代码到你的 README 文件中，并更改链接： 端点: api/pin?username=anuraghazra&amp;repo=github-readme-stats 1[![Readme Card](https://github-readme-stats.vercel.app/api/pin/?username=anuraghazra&amp;repo=github-readme-stats)](https://github.com/anuraghazra/github-readme-stats) 热门语言卡片热门语言卡片显示了 GitHub 用户常用的编程语言。将此代码复制粘贴到您的 README.md 文件中，并修改链接。 端点: api/top-langs?username=anuraghazra 1[![Top Langs](https://github-readme-stats.vercel.app/api/top-langs/?username=anuraghazra)](https://github.com/anuraghazra/github-readme-stats) 隐藏指定语言可以使用 ?hide=language1,language2 参数来隐藏指定的语言。 1[![Top Langs](https://github-readme-stats.vercel.app/api/top-langs/?username=anuraghazra&amp;hide=javascript,html)](https://github.com/anuraghazra/github-readme-stats) 紧凑的语言卡片布局你可以使用 &amp;layout=compact 参数来改变卡片的样式。 1[![Top Langs](https://github-readme-stats.vercel.app/api/top-langs/?username=anuraghazra&amp;layout=compact)](https://github.com/anuraghazra/github-readme-stats) 快速提示 (对齐 Repo 卡片)你通常无法将图片靠边显示。可以使用以下方法： 123456&lt;a href=&quot;https://github.com/anuraghazra/github-readme-stats&quot;&gt; &lt;img align=&quot;center&quot; src=&quot;https://github-readme-stats.vercel.app/api/pin/?username=anuraghazra&amp;repo=github-readme-stats&quot; /&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/anuraghazra/convoychat&quot;&gt; &lt;img align=&quot;center&quot; src=&quot;https://github-readme-stats.vercel.app/api/pin/?username=anuraghazra&amp;repo=convoychat&quot; /&gt;&lt;/a&gt; 部署因为 GitHub 的API 每个小时只允许5千次请求，源项目的 https://github-readme-stats.vercel.app/api ，各人项目的API可能会不一样，可以自己制作Vercel服务API。虽然项目的配置是使用markdown语法，但markdown不拒绝html标签，标签的话大家都容易看懂，也比较整齐。所以我的README.md是直接使用标签配置，一点不比md麻烦。具体的README.md配置如下，注意修改?usename等相应参数： 12345678910111213&lt;p align=&quot;center&quot;&gt; &lt;a href=&quot;https://github.com/coderxm&quot;&gt; &lt;!--statics主页地址，可修改--&gt; &lt;img src=&quot;https://github-readme-stats-eight-theta.vercel.app/api?username=coderxm&amp;show_icons=true&amp;theme=algolia&amp;include_all_commits=true&amp;count_private=true&amp;hide=issues&quot;/&gt; &lt;!--可修改--&gt; &lt;/a&gt;&lt;/p&gt;&lt;p align=&quot;center&quot;&gt; &lt;a href=&quot;https://github.com/coderxm&quot;&gt; &lt;!--热门语言，可修改--&gt; &lt;img src=&quot;https://github-readme-stats-eight-theta.vercel.app/api/top-langs/?username=coderxm&amp;layout=compact&amp;langs_count=5&amp;theme=algolia&quot;/&gt; &lt;!--可修改--&gt; &lt;/a&gt; &lt;a href=&quot;https://https://github.com/coderxm/CNblogs-Theme-NewSakura&quot;&gt; &lt;!--pinned推荐项目,可修改--&gt; &lt;img src=&quot;https://github-readme-stats.anuraghazra1.vercel.app/api/pin/?username=coderxm&amp;repo=CNblogs-Theme-NewSakura&amp;theme=algolia&quot;/&gt; &lt;/a&gt; &lt;!--可修改--&gt;&lt;/p&gt; 项目地址：https://github.com/anuraghazra/github-readme-stats","categories":[{"name":"项目","slug":"项目","permalink":"https://aachou.github.io/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[],"author":"沧海一粟"},{"title":"CC知识共享许可协议简介","slug":"CC知识共享许可协议简介","date":"2021-09-16T13:07:56.000Z","updated":"2023-08-09T10:13:57.000Z","comments":true,"path":"2021/0916/","permalink":"https://aachou.github.io/2021/0916/","excerpt":"在博客文章下面一般都有版权声明，标明文章作者、链接和版权类型，最常见的类型就是CC BY-SA。这种版权声明是知识共享许可协议Creative Commons license，又叫CC协议或创作公共协议，是一种允许他人分发作品的公共版权许可。2002年美国非盈利性组织知识共享Creative Commons首次发布了CC协议，它并不是什么法律法规，而是基于一定的知识产权法律基础上建立的一种知识作品等分享约定协议，旨在促进创意作品流通和分享。 在经历了三个不同版本之后，CC4.0版本于2013年发布。自此之后，CC4.0被鼓励在全球范围内适用。除了放弃版权将作品完全公布到公共领域 (即CC0协议) 之外，CC4.0版本中一共有6种常用的版权规定组合","text":"在博客文章下面一般都有版权声明，标明文章作者、链接和版权类型，最常见的类型就是CC BY-SA。这种版权声明是知识共享许可协议Creative Commons license，又叫CC协议或创作公共协议，是一种允许他人分发作品的公共版权许可。2002年美国非盈利性组织知识共享Creative Commons首次发布了CC协议，它并不是什么法律法规，而是基于一定的知识产权法律基础上建立的一种知识作品等分享约定协议，旨在促进创意作品流通和分享。 在经历了三个不同版本之后，CC4.0版本于2013年发布。自此之后，CC4.0被鼓励在全球范围内适用。除了放弃版权将作品完全公布到公共领域 (即CC0协议) 之外，CC4.0版本中一共有6种常用的版权规定组合。下面这六种不同的许可协议，这里从基础许可到受限许可开始列举： CC BY CC BY : 此类型许可允许进行版本分发，作品合成修改和建立在任何媒介或格式的材料上，只要归属于创造者。许可证允许商业使用。包括以下： BY – 版权必须归属于作者，必须按照作者或授权人所指定的方式，保留其姓名标示。 CC BY-SA CC BY-SA : 此类型允许进行版本分发，作品合成修改和建立在任何媒介或格式的材料上，只要归属于创造者。许可证允许商业使用。假如你合成修改或者建立生成新作品，必须在相同的条款下许可授权，不能变更许可协议 。CC BY-SA 包括以下条件: BY – 版权必须归属于作者，必须按照作者或授权人所指定的方式，保留其姓名标示。 SA – 修改必须在相同的条款协议下共享(Shared) CC BY-NC CC BY-NC : 本许可证允许使用者仅出于非商业目的，以任何媒体或格式分发、合成、改编和构建材料作品，并且版权要归属创作者。CC BY-NC 包括以下条件: BY – 版权必须归属于作者，必须按照作者或授权人所指定的方式，保留其姓名标示。 NC – 只能用于非商业用途(NonCommercial) CC BY-NC-SA CC BY-NC-SA : 本许可证允许使用在仅出于非商业目的下，以任何媒体或格式分发、合成、改编和构建材料作品，并且版权要归属创作者。要合成修改或者建立生成新作品，必须在相同的条款协议下许可。CC BY-NC-SA 包括以下条件: BY – 版权必须归属于作者，必须按照作者或授权人所指定的方式，保留其姓名标示。 NC – 只能被用于非商业用途 SA – 修改必须在相同的条款协议下共享(Shared) CC BY-ND CC BY-ND : 此类许可允许仅以未修改的形式，以任何媒介或格式复制和分发作品材料，版权归属作者，但可以用于商业用途。CC BY-ND 包括以下: BY – 版权必须归属于作者，必须按照作者或授权人所指定的方式，保留其姓名标示。 ND – 作品的衍生和改编是不允许的(No derivatives or adaptations ) CC BY-NC-ND CC BY-NC-ND : 此类许可允许仅以未修改的形式在仅出于非商业目的下，以任何媒介或格式复制和分发作品材料, 最后版权依然归于作者。CC BY-NC-ND 包括以下: BY – 版权必须归属于作者，必须按照作者或授权人所指定的方式，保留其姓名标示。 NC – 只能被用于非商业用途 ND – 作品的衍生和改编是不允许的 知识共享公共领域公开CC0 CC0 (又名CC Zero)是一个知识作品公布共享协议，它表示创作者放弃他们的版权，将他们的作品放到全球公共领域，CC0允许使用者无条件地以任何媒介或格式分发、合成、改编和构建材料，是一种彻底的开放版权协议，建议谨慎使用。 附录：参考CC官网","categories":[{"name":"碎碎念","slug":"碎碎念","permalink":"https://aachou.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}],"tags":[],"author":"沧海一粟"},{"title":"在Windows下安装linux子系统WSL(Ubuntu)","slug":"在Windows下安装linux子系统WSL-Ubuntu","date":"2021-09-01T08:08:20.000Z","updated":"2023-08-09T10:22:22.000Z","comments":true,"path":"2021/0901/","permalink":"https://aachou.github.io/2021/0901/","excerpt":"最近学习Linux命令，主要通过虚拟机来学习，但是发现在虚拟机里学习挺麻烦的，从装OS到配置都要按步骤来小心地进行。所以干脆通过在Windows装一个WSL(windows subsystem for Linux)学习，直接在Microsoft Store微软商店搜索WSL，安装常用的Ubuntu 20.04 LTS就行了。","text":"最近学习Linux命令，主要通过虚拟机来学习，但是发现在虚拟机里学习挺麻烦的，从装OS到配置都要按步骤来小心地进行。所以干脆通过在Windows装一个WSL(windows subsystem for Linux)学习，直接在Microsoft Store微软商店搜索WSL，安装常用的Ubuntu 20.04 LTS就行了。 点击安装就是了，这里我已经安装好了，安装时确保你的操作系统是windows10。 打开控制面板，打开程序，点击启用或关闭Windows功能，找到适用于Linux的Windows子系统选项，打勾确定。 打开下载好的的Ubuntu 20.04LTS，按照提示创建一个普通账户，如下设置： 输入的密码是看不见的，不用担心输入问题，完成后即创建了一个账户。接下来设置root账户，输入命令sudo passwd root修改root密码，提示updated successfully成功，然后就可以转换成root用户操作了，命令为su root，输入刚刚的密码即可。想回到原来的普通账户，输入命令su 普通账户名。另外如果要提升权限可以换root用户，或者sudo+命令以超级管理员身份执行。 注意这个WSL子系统只有文字界面，没有图形界面，所以只能在这敲命令，但是对学习掌握Linux命令很有帮助，Linux命令在这里不做过多介绍了。","categories":[{"name":"linux","slug":"linux","permalink":"https://aachou.github.io/categories/linux/"}],"tags":[{"name":"WSL","slug":"WSL","permalink":"https://aachou.github.io/tags/WSL/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://aachou.github.io/tags/Ubuntu/"},{"name":"windows","slug":"windows","permalink":"https://aachou.github.io/tags/windows/"}],"author":"沧海一粟"},{"title":"在服务器上安装halo博客","slug":"最近博客动态","date":"2021-02-28T13:46:22.000Z","updated":"2023-08-09T10:22:16.000Z","comments":true,"path":"2021/0228/","permalink":"https://aachou.github.io/2021/0228/","excerpt":"博客部署本来是想弄Coding实现和Github双部署博客的，所以www的域名停止访问，可是最后Coding也没能部署完成，关键就是Page之后的仓库域名不符合条件，最后项目也署失败，所以干脆直接放弃了，索性弄一个动态的。","text":"博客部署本来是想弄Coding实现和Github双部署博客的，所以www的域名停止访问，可是最后Coding也没能部署完成，关键就是Page之后的仓库域名不符合条件，最后项目也署失败，所以干脆直接放弃了，索性弄一个动态的。 买了一台1核1G的云服务器，不是在阿里云买的，比较便宜些，也没便宜多少，就十几块钱吧，如果在阿里云开发者计划上购买能续费三年，主要是只买了一年的，以后续费就不好续了，优惠价买的，原价贵的要死，只能说上个云太难了。装了个CentOS系统镜像，起初准备搭建一个PHP博客，原因是handsome主题十分美观简洁，但是要付费(建议购买正版，有配套服务，我没钱所以用盗版)，选好了后台用的typecho，前端主题准备用handsome(盗版)。等到安装好LAMP之后，发现这个博客后台框架并不咋滴，虽然有很多人用，本身硬件就不行，运行起来特别慢，要下载好多插件，还要动手改源码，对于一个不懂php的新手来说很不友好。过了几天直接换成halo框架，操作很简单，如果选择这种的，根本不需要安装LAMP，halo是一个Java动态开源的博客项目，所以直接到官网下载一个项目JAR包就行，放到服务器上，只需要配置好Java环境，一道nohup java -jar halo-1.4.2.jar &amp;命令就运行起来了，速度快， 特别方便！而且halo的后台页面比较美观，功能齐全，不像typecho还要弄一个插件美化一下，一个有几十KB的，有几十M的，明显增加了服务器运行负担。 备案另外服务器在ICP备案之后才能进行域名解析，一般要十天左右完成！所以买了服务器和域名就尽早备案，别耽误博客上线时间。可以把博客放到服务器上运行，之后就是安装博客，和前端博客的美化，halo主题有不少，可以到主题仓库挑选，下载压缩包或者远程拉取都行。 handsome主题如果你选择安装typecho购买handsome主题的话，建议直接让他给你买好服务器安装好，一条龙服务嘛，毕竟花了钱的！但如果你只是买主题的话，安装操作会比较麻烦一点，首先配置好环境，需要LAMP或者LNMP，反正Mysql和php是一定要安装的，Php和Mysql服务要一直开启，若遇到yum没用相应的安装包，安装包版本低的情况，可以更换yum包管理器的安装源。 1234567cd /etc/yum.repos.d/ # 进入yum源配置文件夹,根据centos版本下载对应的新源# 如果wget命令不生效，说明还没有安装wget工具wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo curl -O http://mirrors.aliyun.com/repo/Centos-7.repo yum clean all #清除缓存yum makecache #生成缓存，会把新下载CentOS-Base.repo源生效yum -y update #更新 很多软件包在yum官方源里面没有的，也可以使用epel源,也就是安装epel-release软件包。EPEL (Extra Packages for Enterprise Linux)是基于Fedora的一个项目，为“红帽系”的操作系统提供额外的软件包，适用于RHEL、CentOS等系统。 1yum install epel-release #安装epel Mysql注意事项在安装Mysql时，注意CentOS7放弃了MySQL，而改使用MariaDB，MariaDB数据库管理系统是MySQL的一个分支，主要由开源社区在维护 。开发这个分支的原因之一是甲骨文公司收购了MySQL后，有将MySQL闭源的潜在风险， 因此社区采用分支的方式来避开这个风险。MariaDB的目的是完全兼容MySQL，包括API和命令行，使之可以成为MySQL的代替品。 在存储引擎上，从10.0.9版起使用XtraDB来代替MySQL的InnoDB。 MariaDB由MySQL的创始人麦克尔主导开发，他早前曾将自己创建的公司MySQL AB卖给了SUN公司，此后，随着SUN被甲骨文收购。 123456yum list | grep mariadb #查看yum源中mariadb安装包列表yum install mariadb-5.5.56-2.el7.x86_64 #安装相应版本rpm -qa | grep MariaDB #查看mariadb安装包systemctl enable mysqld #开机启动mysql服务systemctl start mysqld.service #开启服务(systemctl status查看服务)#然后创建typecho博客需要的数据库typecho(默认)和用户名、密码 端口映射由于halo项目的默认端口为8090，所以需要进行服务器端口的映射，不然访问不到，将80端口映射到8090，如下： 123iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-port 8090 #映射端口80到8090iptables -t nat -A PREROUTING -p tcp --dport 443 -j REDIRECT --to-port 8090 #映射端口443到8090service iptables restart #重启防火墙 备案之后可以进行域名解析就完事了，通过域名能访问就正常。 另外你也可以深入了解一下halo框架的具体实现，学习学习，确实是一个不错的Java项目。 另外你也可以深入了解一下halo框架的具体实现，学习学习，确实是一个不错的Java项目。","categories":[{"name":"碎碎念","slug":"碎碎念","permalink":"https://aachou.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://aachou.github.io/tags/%E5%8D%9A%E5%AE%A2/"}],"author":"沧海一粟"},{"title":"Java多线程(五)-线程池","slug":"Java多线程-五-线程池","date":"2021-01-27T13:46:22.000Z","updated":"2023-08-09T10:22:09.000Z","comments":true,"path":"2021/0127/","permalink":"https://aachou.github.io/2021/0127/","excerpt":"线程池-前言系统启动一个线程的成本较高，而使用线程池可以提高性能，尤其在菜鸡大量短期线程时。与数据库连接池类似，线程池在系统启动时创建大量空闲线程，程序将一个Runnable对象或Callable对象传给线程池，线程池就会执行他们的run()或call()方法，当执行结束后线程不会死亡，而是回到线程池变成空闲状态，等待执行run或call方法。","text":"线程池-前言系统启动一个线程的成本较高，而使用线程池可以提高性能，尤其在菜鸡大量短期线程时。与数据库连接池类似，线程池在系统启动时创建大量空闲线程，程序将一个Runnable对象或Callable对象传给线程池，线程池就会执行他们的run()或call()方法，当执行结束后线程不会死亡，而是回到线程池变成空闲状态，等待执行run或call方法。 此外，使用线程池可以有效控制系统并发的数量，当系统包含大量的并发线程时，将导致系统性能降低，而线程池的最大线程数可以有效控制并发数量。 线程池用Executors工厂类创建线程池，该工厂类包含如下几个静态工厂方法来创建线程池： newCachedThreadPool()：创建一个具有缓存功能的线程池。 newFixedThreadPool(int n)：创建一个可重用的、具有固定线程数的线程池。 newSingleThreadExecutor()：创建只有一个线程的线程池，相当于上一个方法参数n&#x3D;1。 newScheduledThreadPool(int Size)：创建具有指定线程数size的线程池，它可以在指定延迟后执行线程任务。 newSingleThreadScheduledExecutor()：创建只有一个线程的线程池，它可以在指定延迟后执行线程任务。 前三个方法返回一个ExecutorService对象，代表一个线程池，后两个方法返回一个ScheduledExecutorService线程池，它是ExecutorService的子类，可以延迟后执行线程。以下是Java8新增的方法： ExecutorService newWorkStealingPool(int parallelism)：创建持有足够线程的线程池来支持给定的并行级别(数目)。 ExecutorService newWorkStealingPool()：上一个简化版的方法，cpu有多少，相当于上一个方法的参数传入多少。 随着硬件的发展，多核cpu的出现，这两个方法可以利用cpu的并行能力，生成的WorkStealing池相当于后台线程池。 ExecutorService代表亟待执行线程的线程池，只要有空闲的线程就会立即执行线程任务。程序只要将一个Runnable或Callable对象交给线程池，该线程池会尽快执行线程。而ExecutorService提供了如下几个方法： Future&lt;?&gt; submit(Runnable t)：将一个Runnable对象交给线程池，线程池将在有空闲线程时执行Runnable对象。Future对象将在线程run方法执行结束后返回null，可以调用Future的isDone()，isCancelled()方法获取Runnable的执行状态。 &lt;T&gt; Future&lt;T&gt; submit(Runnable t,T r)：将一个Runnable对象交给线程池，线程池将在有空闲线程时执行Runnable对象。其中r显式指定执行结束后端返回值，所以Future对象将在run方法执行结束后返回r。 &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; t)：将一个Callable对象交给线程池，线程池将在有空闲线程时执行Callable对象。其中Future代表Callable对象的call方法的返回值。 ScheduledExecutorService是可在延迟后或可周期性执行线程的线程池，提供了如下四个方法： ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; c,long delay,TimeUnit u)：指定c任务将在delay延迟后执行。 ScheduledFuture&lt;?&gt; schedule(Runnable c,long delay ,TimeUnit u)：指定c任务将在delay延迟后执行。 ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable c,long initialDelay,long period,TimeUnit u)：指定c任务将在initialDelay延迟后执行，依次在initialDelay+period、initialDelay+2*period···处重复执行。 ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable c,long initialDelay,long delay,TimeUnit u)：创建并执行一个在给定初始延迟后的定期操作，随后在每次执行中止和下一次执行开始之间都存在给定的延迟，具有周期性。如果任务遇到异常，就会取消后续执行。 在使用完一个线程池后应该调用其shutdown()方法，该方法启动线程池关闭序列，不会接收新的线程任务，将已提交的线程任务完成后结束所有线程；类似的另外一个方法shutdownNow()，该方法将停止所有正在执行和等待的任务，并返回等待执行的任务列表。 综上，线程池执行任务的过程如下： 调用Executor类的静态工厂方法创建一个ExecutorService对象，即线程池。 创建Runnable或Callable实现类的实例，作为线程执行任务。 调用线程池大小的submit方法来提交Runnable或Callable实例。 想要关闭线程池时，调用其shutdown()方法。 12345678910111213public class ThreadPoolTest&#123; public static void main(String[] args) throws Exception&#123; ExecutorService pool = ExecutorS.newFixedThreadPool(5); Runnable t = -&gt;&#123; for(int i=0;i&lt;100;i++)&#123; System.out.println(Thread.currentThread().getName()+&quot;： &quot;+i); &#125; &#125;;//这里没有直接创建启动线程来执行Runnable对象，是通过线程池执行 pool.submit(t); pool.submit(t); pool.shutdown(); &#125;&#125;//两个线程将交替执行 ForkJoinPool拆分任务Java提供的ForkJoinPool是ExecutorService的实现类，能将一个任务拆分成多个小任务并行计算，再把结果合并，是比较特殊的线程池。ForkJoinPool提供了如下两个构造器： ForkJoinPool(int p)：创建一个包含p个并行线程的ForkJoinPool。 ForkJoinPool()：以Runtime.availableProcessors()方法的返回值作为p参数创建线程池。 Java8又增加了通用池功能，ForkJoinPool提供了两个静态方法： ForkJoinPool commonPool()：该方法返回一个通用池，通用池的运行不会受shutdown()和shutdownNow()的影响，除非退出JVM，中止虚拟机工作。 int getCommonPoolParallelism()：该方法返回通用池并行级别(数量)。 创建了ForkJoinPool实例后，就可调用submit(ForkJoinTask t)或invoke(ForkJoinTask t)方法执行任务，其中ForkJoinTask代表一个可并行、合并的任务。ForkJoinTask是一个抽象类，RecursiveAction和RecursiveTask是它的两个抽象子类，RecursiveAction代表没有返回值的任务，RecursiveTask代表有返回值的任务。 线程相关类Java为线程安全提供了一些工具类，如ThreadLocal类，它代表一个线程局部变量，通过把数据放在ThreadLocal就可以让每个线程创建一个该变量的副本，从而避免并发访问的线程安全问题。 ThreadLocal类工具类ThreadLocal支持泛型，通过该类可以简化多线程编程的并发访问。它提供如下三个public方法： T get()：返回此线程局部变量中当前线程副本中的值。 void remove()：删除此线程局部变量中的值。 void set(T value)：设置此线程局部变量中线程副本中的值。 ThreadLocal和同步机制一样，都是为了解决多线程中对变量访问的冲突问题。在同步机制中，通过对对象加锁来实现安全访问，该变量为多个线程所共享；而ThreadLocal从另一个角度解决并发访问，它将所访问的资源复制多份，每个线程拥有一份，从而避免了线程之间的访问冲突。 ThreadLocal不能代替同步机制，同步机制是同步多个线程对同一资源的访问，是多个线程之间进行通信的方法；ThreadLocal是为了隔离多个线程对资源的共享，根本上避免线程为竞争资源的冲突。 包装线程不安全的集合之前讲过的Java集合ArrayList、HashSet、HashMap、TreeMap等线程不安全的集合，当线程并发访问时可能会集合数据的完整。所以需要包装成安全的集合，Collections通过了如下静态方法： static &lt;T&gt; Collection&lt;T&gt; synchronizedCollection(Collection&lt;T&gt; c)：返回指定Collection对应的线程安全的集合Collection static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list)：返回指定List对象对应的线程安全的List对象。 static &lt;K,V&gt; Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m)：返回指定Map对象对应的线程安全的Map对象。 static &lt;T&gt; Set&lt;T&gt; synchronizedSet(Set&lt;T&gt; s)：返回指定Set对象对应的线程安全的Set对象。 static &lt;K,V&gt; sortedMap&lt;K,V&gt; synchronizedSortedMap(SortedMap&lt;K,V&gt; m):返回指定SortedMap对象对应的线程安全的SortedMap对象。 static &lt;T&gt; SortedSet&lt;T&gt; synchronizedSortedSet(SortedSet&lt;T&gt; s)：返回指定SortedSet对象对应的线程安全的SortedSet对象。 需要包某个集合包装成线程安全的集合，应该在创建后立即包装。 1HashMap m = Collections.synchronizedMap(new HashMap());//包装成线程安全的HashMap 线程安全的集合在java.util.concurrent包下提供了大量支持高效并发访问的集合接口和实现类，这些线程安全的集合类可分为： 以Concurrent开头的集合类，如ConcurrentHashMap、ConcurrentSkipListMap、ConcurrentLinkedQueue。 以CopyOnWrite开头的集合，如CopyOnWriteArrayList、CopyOnWriteArraySet。 Concurrent集合 其中以Concurrent开头的集合类代表了支持并发访问的集合，它们可以支持多个线程并发写入访问，而且都是安全的，读取操作不必锁定。以CopyOnWrite开头的集合采用了复杂算法保证不会锁住整个集合，因此在并发写入时有很好的性能。 当多个线程共享一个公共集合时，ConcurrentLinkedQueue是一个恰当的选择，它不允许使用null元素，实现了多线程无需等待访问。 默认情况下，ConcurrentHashMap支持16给线程并发写入，当超过16个线程时，可能有一些线程需要等待，程序可通过设置concurrencyLevel构造参数(默认为16)来支持更多并发写入。Java8又新增了多个方法增加ConcurrentHashMap功能，大致分为三类： forEach（forEach,forEachKey,forEachEntry） search（search,searchKeys,searchValues） reduce（reduce,reduceToDouble,reduceKeys,reduceValues） 此外还添加了mappingCount()，newKeySet()等方法，增强后的ConcurrentHashMap更合适作为缓存实现类。 CopyOnWriteArrayList集合 由于CopyOnWriteArraySet底层封装了CopyOnWriteArrayList，因此它的实现机制类似于CopyOnWriteArrayList集合。 当线程对CopyOnWriteArrayList集合进行读取操作时，线程会直接读取集合本身，无需加锁和阻塞；当线程对CopyOnWriteArrayList集合进行写入操作时(包括add(),remove(),set())，该集合会在底层复制一份新的数组，接下来对新数组执行写入操作。由于写入操作是对数组副本进行的，所以保证了线程安全。 然而线程安全并不是没有代价，CopyOnWriteArrayList执行写入操作时要多次复制数组，所以性能较差，但是读取和写入操作的数组不是同一个，因此读取操作就很快又安全，比较适合用来读取缓存。 这是多线程的最后一篇，估计也是Java的最后一篇，以后可能就不会给大家整理Java基础的文章了，但会在Java道路上一直陪伴大家，谢谢大家的关注！","categories":[{"name":"java","slug":"java","permalink":"https://aachou.github.io/categories/java/"}],"tags":[{"name":"线程池","slug":"线程池","permalink":"https://aachou.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"}],"author":"沧海一粟"},{"title":"Java多线程(四)-线程通信","slug":"Java多线程-四-线程通信","date":"2021-01-23T09:18:08.000Z","updated":"2023-08-09T10:22:00.000Z","comments":true,"path":"2021/0123/","permalink":"https://aachou.github.io/2021/0123/","excerpt":"前言当线程在系统内运行时，程序无法精准控制线程轮换执行，Java提供了一些机制来保证线程协调运行。 synchronized线程通信相关方法借助Object类提供的wait(),notify(),notifyAll()三个方法(不属于Thread类)，但这三个必须由同步监视器调用，这可以分成以下情况：","text":"前言当线程在系统内运行时，程序无法精准控制线程轮换执行，Java提供了一些机制来保证线程协调运行。 synchronized线程通信相关方法借助Object类提供的wait(),notify(),notifyAll()三个方法(不属于Thread类)，但这三个必须由同步监视器调用，这可以分成以下情况： 对于同步方法，该类的默认实例(this)就是同步监视器，所以可以在同步方法中直接调用这三个方法。 对于同步代码块，同步监视器是synchronized后括号里的对象，所以要使用该对象调用。 关于这三个方法的解释： wait()：让当前线程等待，直到其他线程调用该同步监视器的notify()或notifyAll()方法来唤醒线程。无参则一直等待，带参则等待long millis毫秒时间自动唤醒。 notify()：唤醒在此同步监视器上等待的单个线程，如果有多个线程在等待同步监视器，则随机唤醒其中一个线程。只有当前线程主动放弃锁，被唤醒线程才获得执行。 notifyAll()：唤醒在此同步监视器上等待的所有线程。 使用Condition的线程通信如果不使用synchronized关键字保证线程同步，而使用Lock对象保证线程同步，则系统中不存在隐式的同步监视器，也就不能使用wait()，notify()，notifyAll()方法进行线程通信。因此，当使用Lock对象来保证同步时，Java提供了Condition类来保证协调，使用Condition可以让那些已经得到Lock对象却无法执行的线程释放Lock对象，同时也能唤醒其他处于等待的线程。 Condition将同步监视器的方法(wait()，notify()，notifyAll())分成不同的对象，便于与Lock对象结合，Lock代替了同步方法和代码块，Condition代替了同步监视器功能。Condition实例被绑定在Lock对象上，想要获得Lock对象的Condition实例，就要调用Lock对象的newCondition()方法。 Condition类提供如下方法： await()：类似隐式同步监视器的wait()方法，导致当前线程等待，直到其他线程调用该Condition的signal()或signalAll()方法来唤醒该线程。衍生的方法有很多，awaitUninterruptibly()，awaitUntil(Date deadline)。 signal()：唤醒在此Lock对象上等待的单个线程，若有多个线程等待，则随机唤醒其中一个。 signalAll()：唤醒所有在此Lock对象等待的所有线程，只有当前线程放弃对该Lock对象的锁定后才可以执行被唤醒的线程。 使用阻塞队列(BlockingQueue)的线程通信Java5提供了一个BlockingQueue接口，是Queue的子接口，但它的主要途径并不是容器，而是作为线程同步的工具。BlockingQueue具有一个特征：当生产者线程试图向BlockingQueue中放入元素时，如果该队列已满，则该线程被阻塞，当消费者线程试图从BlockingQueue中取出元素时，如果该队列为空，则该线程被阻塞。 程序的两个线程交替向BlockingQueue中放入，取出元素，就能控制线程通信。BlockingQueue提供了如下两个方法： put(T t)：把T元素放入BlockingQueue中，如果该队列已满，则阻塞该线程。 take()：从BlockingQueue的头部取出元素，如果该队列的元素已空，则阻塞该线程。 BlockingQueue继承了Queue接口，当然也可以使用Queue接口中的方法。 在队尾插入元素。包括add(T t)，offer(T t)，put(T t)方法，当队列已满，这三个方法分别会抛出异常，返回false，阻塞队列。 在队首删除并返回元素。包括remove()、poll()、take()方法，当队列为空时，这三个方法分别会抛出异常，返回false，阻塞队列。 在队首仅仅取出元素。包括element()、peek()方法，当队列为空，方法分别抛出异常和返回false。 可用如下表格表示： 抛出异常 返回false 阻塞线程 指定超时时长 队列已满时，队尾插入元素 add() offer() put() offer(e,time,unit) 队列已空时，队首删除元素 remove() poll() take() poll(time,unit) 队列已空时，队首取出元素 element() peek() BlockingQueue包含以下几个实现类： ArrayBlockingQueue：基于数组实现的BlockingQueue队列。 LinkedBlockingQueue：基于链表实现的BlockingQueue队列。 SynchronousQueue：同步队列，对该队列的存取必须交替进行。 PriorityBlockingQueue：不是标准的阻塞队列，与PriorityQueue类似，该队列调用remove()，poll()，take()方法取出元素时，并不是取出队列中存在时间最长的元素，而是最小的元素。判断元素大小可根据元素(实现Comparable接口)的本身大小进行自然排序，也可使用Comparator自定义排序。 DelayQueue：底层基于PriorityBlockingQueue实现，要求元素都实现Delay接口，接口里只有一个long getDelay()方法，DelayQueue根据元素的getDelay()方法的返回值进行排序。 12345678public class BlockingQueueTest&#123; public static void main(Strings[] args) throws Exception&#123; BlockingQueue&lt;String&gt; b = new ArrayBlockingQueue&lt;&gt;(2); b.put(&quot;阻塞队列&quot;); b.put(&quot;阻塞队列&quot;); b.put(&quot;阻塞队列&quot;);//队列已满，阻塞线程 &#125;&#125; 线程组和未处理异常Java使用ThreadGroup来表示线程组，它可以对一批线程进行管理，允许程序直接对线程进行控制。如果没有显式指定创建的线程属于哪个线程组，则属于默认线程组。默认情况下，子线程和创建它的线程属于同一线程组。一旦线程加入了指定的线程组，则该线程一直属于该线程组，直至死亡不能改变。 Thread类提供了如下几个构造器来设置创建的线程属于哪个线程组： Thread(ThreadGroup group,Runnable target)：以target的run方法作为线程执行体创建新的线程，属于group线程组 Thread(ThreadGroup group,Runnable target,String name):同样的，只不过指定了创建的线程名字。 Thread(ThreadGroup group,String name)：创建新线程，指定线程名。 虽然不能改变所在指定的线程组，但可以通过getTreadGroup()方法返回所属线程组，返回值是ThreadGroup对象。而ThreadGroup类提供了两个构造器创建相应实例： ThreadGroup(String name)：以指定的线程组名字来创建新的线程组。 ThreadGroup(ThreadGroup parent,String name)：以指定的的名字和父线程组创建新的线程组。 通过以上构造器可以发现，线程组必然有一个名字，这个名字可以通过ThreadGroup的getName()方法获取，但是不允许改变线程组的名字，也就没有set方法。除了构造器，ThreadGroup还提供了几个方法来操作线程组里的所有线程： activeCount()：返回线程组中活动线程的数目。 interrupt()：中断此线程组的所有线程。 isDaemon()：判断该线程组是否是后台线程组。 setDaemon()：把线程组设置为后台线程组，若后台线程组的最后一个线程死亡，则线程组自动毁灭。 setMaxPriority(int p)：设置线程组的最高优先级。 此外，线程组对于出现的异常也提供了一个方法void uncaughtException(Thread t,Throwable e)，该方法可以处理该线程组内的任意线程所抛出的未处理异常。如果线程抛出一个异常，JVM会在线程结束前自动查找对应的Thread.UncaughtExceptionHandler对象，如果找到该异常处理器对象，则会调用该对象的uncaughtException(Thread t,Throwable e)方法处理异常。 Thread.UncaughtExceptionHandler是Thread类的一个静态内部接口，里面只有一个方法uncaughtException(Thread t,Throwable e)，t代表异常的线程，e代表抛出的异常。Thread类提供了如下方法来设置异常处理器： static setDefaultUncaughtExceptionHandler(Thread.UncaughtExceptionHandler h)：为该线程类的所有实例设置默认异常处理器。 setUncaughtExceptionHandler(Thread.UncaughtExceptionHandler h)：为线程实例设置异常处理器。 ThreadGroup类实现了Thread.UncaughtExceptionHandler接口，所以每个线程的线程组都将作为默认的异常处理器。当一个线程抛出异常时，JVM会先查找线程实例指定的异常处理器，否则会调用所属线程组对象的uncaughtException()方法(默认的异常处理器)处理异常。 线程组默认异常处理器处理过程如下： 如果该线程组有父线程组，则调用父线程组的uncaughtException()方法处理。 如果该线程所属的默认线程组有默认异常处理器，那么就调用该异常处理器处理。 如果该异常是ThreadDeath的对象，则不做任何处理，否则将异常跟踪栈的信息打印到System.err输出流，并结束该线程。 123456789101112Class MyHandler implements Thread.UncaughtExceptionHandler&#123;//自定义处理器 public void uncaughtException(Thread t,Throwable e)&#123; System.out.println(t+&quot; 出现异常 &quot;+e); &#125;&#125;public class ExHandler&#123; public static void main(String[] args)&#123; Thread.currentThread().setUncaughtExceptionHandler(new MyExHandler()); int a = 1/0;//ArithmeticException System.out.println(&quot;程序已结束！&quot;);//不会正常结束，所以不会输出 &#125;&#125; 上诉代码虽然捕获了异常，但是出现不会正常结束。因为与try...catch异常捕获不同，异常处理器对异常进行处理后会将异常抛给上一级调用者，而catch捕获异常不会。","categories":[{"name":"java","slug":"java","permalink":"https://aachou.github.io/categories/java/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://aachou.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"线程通信","slug":"线程通信","permalink":"https://aachou.github.io/tags/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/"}],"author":"沧海一粟"},{"title":"Java-IO流(三)-NIO","slug":"Java-IO流-三-NIO","date":"2021-01-21T06:39:09.000Z","updated":"2023-08-09T10:21:54.000Z","comments":true,"path":"2021/0121/","permalink":"https://aachou.github.io/2021/0121/","excerpt":"Java-IO流(三)-NIO在前面所介绍的输入输出流都是阻塞式的输入、输出，即当数据源中没有数据时，它会阻塞该线程。传统的输入、输出都是通过字节的移动来处理的，就是输入输出系统一次只能处理一个字节，因此效率并不高。从JDK1.4开始，Java改进了IO流体系，提供来一些新功能，被称作NIO。新增的功能类被放在java.nio包及子包下，并且对原java.io包中的很多类都以NIO为基础进行改写，新增满足NIO功能。","text":"Java-IO流(三)-NIO在前面所介绍的输入输出流都是阻塞式的输入、输出，即当数据源中没有数据时，它会阻塞该线程。传统的输入、输出都是通过字节的移动来处理的，就是输入输出系统一次只能处理一个字节，因此效率并不高。从JDK1.4开始，Java改进了IO流体系，提供来一些新功能，被称作NIO。新增的功能类被放在java.nio包及子包下，并且对原java.io包中的很多类都以NIO为基础进行改写，新增满足NIO功能。 NIO采用不同的方式来处理输入&#x2F;输出，用内存映射文件的方式来处理输入&#x2F;输出，NIO将文件或文件的一段区域映射到内存中，这样就可以像访问内存一样访问文件，这种方式比传统的方式快。它有如下包： java.nio包：主要各种与Buffer相关的类 java.nio.channels包：主要包含与Channel和Selector相关的类 java.nio.charset包：字符集相关类 java.nio.channels.spi：与Channel相关的服务接口 java.nio.charset.spi：包含与字符集相关的服务接口 Channel(通道)和Buffer(缓冲)是新IO中两个核心对象，CHannel是对传统的输入&#x2F;输出的模拟，在NIO中所有数据都需要通过通道传输；Channel与传统的InputStream、OutputStream区别在于它提供一个map()方法，通过该map()方法可以直接将一块数据映射到内存中。 Buffer可以被理解成一个容器，它本质是一个数组，发送到Channel中都所有对象都必须首先放在Buffer中，而从Channel中读取的数据也必须放到Buffer中。 除Channel和Buffer外，NIO还提供了将Unicode字符串映射成字节序列以及逆映射操作的Channel类，也提供了非阻塞式输入&#x2F;输出的Selector类。 使用BufferBuffer是一个抽象类，其最常用的子类是ByteBuffer，它可以在底层字节数组上进行get/set操作。对应其他类型的Buffer类有：CharBuffer、ShortBuffer、IntBuffer、LongBuffer、FloatBuffer等。以上类都没有提供构造器，而是提供static XxxBuffer allocate(int capacity)方法，创建一个容量为capacity的XxxBuffer对象。 MappedByteBuffer是ByteBuffer子类，用于表示Channel将磁盘文件的部分或全部内容映射到内存中后得到的结果，相应对象由Channel的map()方法返回。 在Buffer中有三个重要的概念：容量(Capacity)、界限(limit)、位置(position) 容量(capacity)：缓冲区的容量(capacity)表示最大数据容量，创建后不能改变。 界限(limit)：第一个不能被读写的缓冲区位置索引。 位置(position)：指明下一个可以被读出或写入的缓冲区位置索引，类似记录指针。 Buffer还有一个可选标记mark，允许直接将position定位到该mark处，并满足： 0&lt;&#x3D;mark&lt;&#x3D;position&lt;&#x3D;limit&lt;&#x3D;capacity Buffer的主要作用就是装入数据，然后输出数据。开始时，position为0，limit为capacity，程序可以通过put()方法向Buffer中放入一些数据，每放入一些数据，Buffer的position相应的向后移动一些。当Buffer装入数据结束后，调用Buffer的flip()方法，该方法将limit设置为position所在位置，并将position设为0，为输出作准备。输出数据后，Buffer调用clear()方法，将position设为0，将limit设为capacity，这样为装数据做准备。 总结来讲：就是flip()方法为取出数据做好准备，clear()方法为装数据做好准备。此外Buffer的常用方法还有capacity()、limit()、hasRemaining()等。 除了有移动position、limit、mark的方法外，Buffer的所有子类还提供了两个重要的方法：put()和get()方法，用于向Buffer中放入和取出数据，可以单个也可以批量。当用这两个方法访问数据时，分为相对和绝对两种： 相对(relative)：从Buffer的当前Position处开始读取或写入数据，然后Position值按处理元素个数增加。 绝对(Absolute)：直接根据索引向Buffer中读取或写入数据，使用绝对方式访问Buffer的数据，position值不变。 通过allocate()方法创建的对象是普通的Buffer对象，ByteBuffer还提供一个allocateDirect()方法来创建直接Buffer，成本会比普通Buffer创建·成本高，但好处是读取效率更高。 由于只有ByteBuffer提供了allocateDirect()方法，所以只能在ByteBuffer级别上创建直接Buffer。如果需要使用其他类型，则应该将该Buffer转换成其他类型Buffer。直接Buffer更适于长期生存的Buffer，因为创建成本较高。 使用ChannelChannel类似于传统的流对象，但还是有区别。Channel可以直接将指定文件的部分或全部直接映射成Buffer；程序不能直接访问Channel中的数据，读取、写入都不行；Channel只能和Buffer进行交互，也就是说程序要取出数据要通过Buffer，写入数据要还要通过Buffer。 Java为Channel接口提供了DatagramChannel、FileChannel、Pipe.SinkChannel、ServerSocketChannel、SocketChannel等实现类，并且有各自相应的功能。所有的Channel都不应该通过构造器来直接创建，而是通过传统的节点InputStream、OutputStream的getChannel()方法来返回对应的channel，不同的节点流获得的Channel不一样。 Channel中最常用的方法是map()、read()、write()，其中map()方法用于将Channel对应的部分或全部数据映射成ByteBuffer；而read()或write()方法都有一系列重载形式，这些方法用于从Buffer中读取或写入数据。 map(FileChannel.MapMode mode,long position,long size)，映射模式有只读、读写等，第二三个参数用于映射数据的范围。在RandomAccessFile中也包含了一个getChannel()方法，RandomAccessFile返回的FileChannel()是只读的还是读写的，取决RandomAccessFile打开文件的模式。 字符集和charset数据是以字节码的形式储存的，明文字符序列经过编码成二进制序列。Java默认使用Unicode字符集，当读取数据到java程序时，就可能出现乱码。JDK1.4提供了Charset来处理字节序列和字符序列之间的转换关系，该类包含了用于创建解码器和编码器的方法，还提供了获取Charset所支持字符集方法，Charset类是不可变的。Charset类还提供了一个availableCharsets()静态方法来获取当前JDK所支持的所有字符集。 GBK：简体中文 BIG5：繁体中文 ISO-8859-1：ISO拉丁字母表 UTF-8：8位UCS转换格式 UTF-16BE：16位UCS转换格式，地位地址放高位字节 UTF-16：16位UCS转换格式 可以使用System的getProperties()方法访问本地系统的文件编码格式，属性名为file.encoding。 一旦知道字符集别名，就可以调用Charset的forName()方法来创建对应的Charset对象，forName()的参数是相应字符集的别名。通过对象的newDecoder()和newEncoder()方法分别返回CharsetDecoder和CharsetEncoder对象，代表解码器和编码器，将字符和字节序列相互转换。 文件锁使用文件锁可以阻止多个进程同时修改一个文件，在NIO中java提供了FileLock来支持文件锁定功能，在FieChannel中提供的lock()/tryLock()方法可以获得文件锁FileLock对象，从而锁定文件。当lock()试图锁定某个文件时，如果无法得到文件锁，程序将一直阻塞；而tryLock()是直接返回文件锁，否则返回null。 lock(long position,long size,boolean shared)：对文件从position位置开始，长度为size的内容加锁。 tryLock(long position,long size,boolean shared)：非阻塞式的加锁方法，参数与上面类似。 当shared为true时，表明是一个共享锁，它允许多个进程读取该文件，阻止进程获取该文件的排它锁。当为false时，表明是一个排它锁，可提高FileLock的isShared()来判断。注意：直接使用上述两个方法获取的都是排它锁，处理完文件后通过FileLock的release()方法释放文件锁。 NIO.2Java7对原有的NIO进行了改进，主要有： 提供来全面的文件IO和文件系统访问支持 基于异步的Channel的IO 第一个表现为新增的java.nio.file包及各个子包；第二个表现为在java.nio.channels包下增加多个以Asynchronous开头的Channel接口和类。 早期只能通过File类来访问文件系统，现在引入一个path接口，代表一个与平台无关的平台路径。除此之外，还提供了Files、Paths两个工具类，Files包含了静态的工具方法；Paths包含了两个返回path的静态工厂方法。命名都加上s，代表一个工具类。 使用FileVisitor遍历文件和目录Files类提供了如下方法来遍历文件和子目录： walkFileTree(Path start,FileVisitor&lt;? super Path&gt; visitor)：遍历start路径下的所以文件和子目录 walkFileTree(Path start,Set&lt;FileVisitOption&gt; options,int maxDepth,FileVisitor&lt;? super Path&gt; visitor)：该方法最多遍历maxDepth深度的文件 使用WatchService监控文件变化早期是通过一个后台线程每隔一段时间去遍历指定文件目录，如果结果与上一次不同，则发生变化。NIO的Path类提供来一个方法来监听文件变化。 register(WatchService watcher,WatchEvent.kind&lt;?&gt; ...events)：用watcher监听该path代表的目录下的文件变化，events参数指定要监听那些事件。 获取文件系统的WatchService对象： 1WatchService watchservice = FileSystem.getDefault().newWatchService; 接下来使用WatchService的方法获取文件事件： WatchKey poll()：获取下一个watchkey,没有返回null。 WatchKey poll(long timeout,TimeUnit unit)：尝试等待timeout时间去获取下一个WatchKey。 WatchKey take()：获取下一个watchkey，没有就一直等。 公众号：菜鸡干Java","categories":[{"name":"java","slug":"java","permalink":"https://aachou.github.io/categories/java/"}],"tags":[{"name":"IO流","slug":"IO流","permalink":"https://aachou.github.io/tags/IO%E6%B5%81/"},{"name":"NIO","slug":"NIO","permalink":"https://aachou.github.io/tags/NIO/"}],"author":"沧海一粟"},{"title":"Java多线程(二)-控制线程","slug":"Java多线程-二-控制线程","date":"2021-01-20T11:48:51.000Z","updated":"2023-08-09T10:17:45.000Z","comments":true,"path":"2021/0120/","permalink":"https://aachou.github.io/2021/0120/","excerpt":"Java线程Thread提供一些工具方便控制线程的执行。 join线程Thread提供了让一个线程等待另一个线程完成的方法——join()方法，当程序调用线程的join()方法时，调用线程(比如主线程)将被阻塞，直到被join()方法加入的join线程执行完为止。","text":"Java线程Thread提供一些工具方便控制线程的执行。 join线程Thread提供了让一个线程等待另一个线程完成的方法——join()方法，当程序调用线程的join()方法时，调用线程(比如主线程)将被阻塞，直到被join()方法加入的join线程执行完为止。 123JoinThread jt = new JoinThread(&quot;被join的线程&quot;);jt.start();//main线程调用了子线程jt的join方法jt.join();//jt线程结束，主线程才会执行 join()方法有三种形式： join()：等待join的线程执行完成 join(long millis)：等待最长millis毫秒时间，若join了的线程还没结束，不再等待。 join(long millis,int nanos)：等待最长millis毫秒加nanos毫微秒时间。 后台线程顾名思义，在后台运行的线程，为其他线程提供服务，又称守护线程，例如JVM垃圾回收线程。如果前台的线程全部死亡，后台线程也就没有存在的必要了。 调用线程对象的setDaemon(true)方法可以将指定线程设置为后台线程，Thread类还提供了一个isDaemon()方法，用于判断线程是否为后台线程。主线程默认是前台线程，那子线程默认也是前台线程，后台线程创建的子线程默认是后台线程。需要注意的是，将一个线程设置为后台线程，要在线程启动前设置。 123DaemonThread t = new DaemonThread();t.setDaemon(true);t.start(); 线程睡眠Sleep再多线程(一)里已经提到过线程的sleep会让线程进入阻塞状态，线程的sleep()方法是Thread类的静态方法，它有两种重载形式： static void sleep(long millis)：让当前线程暂停millis毫秒进入阻塞状态，会受系统精度的影响。 static void sleep(long millis,long nanos)：暂停millis毫秒加nanos毫微秒进入阻塞，同样受精度影响。 无论有没有其他线程，调用sleep方法的线程都不能得到执行。 12345678public class SleepTest&#123; public static void main(String[] args) throws Exception&#123; for(int i=0;i&lt;10;i++)&#123; System.out.println(&quot;当前时间：&quot;+ new Date()); Thread.sleep(1000);//暂停1秒 &#125; &#125;&#125; 线程让步Yield与sleep()类似的是，线程yield()也是该类的静态方法，但是不同的是它不会阻塞线程，而是让线程进入就绪状态，等待线程调度器的重新调度(有可能下一次被重新调用)。当调用了yield()方法暂停后，只有优先级与当前线程相同或更高的处于就绪状态的线程才会获得执行机会，而sleep()方法不是，暂停之后不会理会其他线程的优先级。 sleep方法声明抛出了InterruptedException异常，所以调用sleep方法时要么捕获该异常，要么显式声明抛出异常；而yield方法没有声明抛出任何异常。 设置线程优先级线程执行时都具有一定优先级，优先级高的获得较多执行机会。每个线程的优先级与创建它的父线程优先级相同，默认下main线程具有普通优先级，其子线程也具有普通优先级。 Thread类提供了setPriority(int priority)、getPriority()方法来设置和获取线程的优先级，其中setPriority()中的参数可以说1~10的整数，也可以是三个静态常量： MAX_PRIORITY：10 MIN_PRIORITY：1 NORM_PRIORITY：5 123456public static void main(String[] args)&#123; Thread.currentThread().setPriority(6); MyThread low = new MyThread(); low.start(); low.setPriority(Thread.MIN_PRORITY);&#125; 需要说明的事，不同系统的优先级范围并不一样，不一定是1~10，所以应该尽量使用静态常量进行设置。 公众号：菜鸡干Java","categories":[{"name":"java","slug":"java","permalink":"https://aachou.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://aachou.github.io/tags/java/"},{"name":"多线程","slug":"多线程","permalink":"https://aachou.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"author":"沧海一粟"},{"title":"Java多线程(一)-线程的创建","slug":"Java多线程-一-线程的介绍和创建","date":"2021-01-19T03:40:40.000Z","updated":"2023-08-09T10:14:32.000Z","comments":true,"path":"2021/0119/","permalink":"https://aachou.github.io/2021/0119/","excerpt":"Java多线程(一)-线程的介绍和创建进程和线程的区别当一个程序进入内存运行，就变成一个进程，进程是系统进行资源分配和调度的最小单位，具有独立性，动态性和并发性。这里需要说明一点：并发性(concurrency)和并行性(parallel)两个概念，并发是指同一时间只能有一个指令被执行，多个进程指令被快速轮换执行；并行指多条执行同时在多个处理器上被执行。","text":"Java多线程(一)-线程的介绍和创建进程和线程的区别当一个程序进入内存运行，就变成一个进程，进程是系统进行资源分配和调度的最小单位，具有独立性，动态性和并发性。这里需要说明一点：并发性(concurrency)和并行性(parallel)两个概念，并发是指同一时间只能有一个指令被执行，多个进程指令被快速轮换执行；并行指多条执行同时在多个处理器上被执行。 多线程指一个进程同时并发处理多个任务，线程是进程的执行单元。进程被初始化后，主线程就被创建，同时还可以创建多个顺序执行流，这些执行流就是线程，线程之间相互独立。线程可以拥有堆栈，变量等，与其他线程共享该进程所有的资源，线程的调度管理由进程本身来完成。 线程的生命周期线程有五种状态，新建，就绪，运行，阻塞，死亡五种。 新建和就绪使用new创建一个线程后，线程处于新建状态，和对象一样由虚拟机分配内存，并初始化成员变量的值。当调用了start()方法后，线程处于就绪状态，虚拟机为其创建方法调用栈和程序计数器，然而线程并没有开始运行，何时运行则取决于JVM的线程调度器的调度。 如果不调用start()方法，而是直接执行run()方法，则其他线程无法并发执行，相当于执行了一个普通方法，而不是线程执行体。对于新建状态的线程，只能调用start()方法。 运行和阻塞当一个线程获得CPU资源时，开始执行run()的线程执行体，它不可能一直处于运行状态，需要被中断让其它线程获得执行机会。线程的调度取决于底层平台所采用的策略，如抢占式策略，系统给每个线程一小段时间处理任务，之后会剥夺资源给其他线程，在选择线程时，系统会考虑线程的优先级。 当线程主动放弃了所占用的资源时，会进入阻塞状态，一般有如下情况： 调用了sleep()主动放弃 线程调用了阻塞式IO方法，该方法返回前被阻塞 试图获得一个被其他线程拥有的同步监视器 等待通知 程序调用suspend()方法挂起线程(容易导致死锁) 被阻塞后需要重新进入就绪状态，等待线程调度器的调用。当发生以下情况线程可重新进入就绪状态： sleep()方法结束 阻塞式的IO方法已返回 成功获得同步监视器 等待通知时，收到其他线程的通知 被挂起后调用了resume()方法恢复 线程进入阻塞后只能回到就绪状态，而就绪和运行状态的转换不受程序控制，由线程调度决定。 线程死亡线程会以三种方式结束： run方法或call方法执行完成 线程抛出未捕获的异常或错误 调用线程的stop()结束(会产生死锁) 注意，主线程结束即死亡后，其他线程不受影响，它们和主线程有同样地位。要测线程死没死，可以调用线程的isAlive()方法，当处于就绪，运行,阻塞状态时，返回true；否则返回false，新建也不例外。当线程死亡后就回不来了，不能重新启动。 创建线程三种方法线程对象必须是Thread类或其子类的实例。 通过继承Thread类创建 定义子类，重写run方法。run方法体就代表线程需要完成的任务，也叫线程执行体。 创建Thread子类的实例，即创建了线程对象。 调用对象的start()方法启动。 注意，程序至少创建一个主线程，其线程执行体不是run方法，而是main()方法。 有三个方法需要介绍： Thread.currentThread()：Thread类的静态方法，返回正在执行的线程对象 getName()：Thread类的实例方法，可返回线程对象的名字。 setName(String name)：设置线程的名字。 通过Runnable接口创建 定义Runnable接口的实现类，并重写该接口的run方法。 创建实现类的实例，以该实例来创建线程对象。 调用start()方法。 123//MyThread为实现Runnable接口的类MyThread t = new MyThread();new Thread(t,&quot;runnable实现的线程&quot;).start(); 实现类的run方法仅作为线程执行体，线程对象则负责执行run方法。通过实现Runable接口，在run方法中获得线程对象，则必须使用Thread.currentThread()方法，而通过继承方法的线程类，直接使用this即可获得线程对象。 使用Callable和Future创建Java5开始提供了一个Callable函数式接口，接口提供了一个call()方法作为线程执行体，它不像run方法，call方法有返回值，而且可以声明抛出异常。然而Callable接口不是Runnable的子接口，所以不能用来直接创建线程对象。 Future接口代表Callable接口里call方法的返回值，Java为Future接口提供了FutureTask实现类，该类实现了Future接口，还实现了Runnable接口，可以用来创建new线程对象，接口里有几个公共方法来控制它关联的Callable任务。比如V get()方法，返回Callable任务里call方法的返回值，该方法将导致阻塞，等线程结束才返回。 创建Callable实现类，并实现call方法，再创建实现类的实例，该call方法将作为线程执行体。 使用FutureTask类包装Callable对象。 使用FutureTask对象作为target，创建线程对象。 调用FutureTask对象的get方法获得子线程执行完后的返回值。 使用Lambda表达式直接创建Callable对象，无需先创建实现类，再创建Callable对象。 三种方式的对比线程类继承了Thread类，不能再继承其他父类，并且不能共享实例变量，但访问当前线程简单；而通过接口的方式可以共享实例变量，还可以继承其他类，但是比较繁琐，访问当前线程对象需要使用Thread.currentThread()。以上就是线程的简单介绍和创建，希望有所帮助！","categories":[{"name":"java","slug":"java","permalink":"https://aachou.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://aachou.github.io/tags/java/"},{"name":"多线程","slug":"多线程","permalink":"https://aachou.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"author":"沧海一粟"},{"title":"Java-IO(二)输入输出流体系","slug":"Java-IO-二-输入输出流体系","date":"2020-11-04T09:21:34.000Z","updated":"2023-08-09T10:21:47.000Z","comments":false,"path":"2020/1104/","permalink":"https://aachou.github.io/2020/1104/","excerpt":"输入输出流体系处理流的用法使用处理流来包装节点流，程序通过处理流来执行输入输出，让节点流与底层I&#x2F;O设备、文件交互。如通过PrintStream处理流来包装OutputStream，使用处理流后的输出流更加方便。","text":"输入输出流体系处理流的用法使用处理流来包装节点流，程序通过处理流来执行输入输出，让节点流与底层I&#x2F;O设备、文件交互。如通过PrintStream处理流来包装OutputStream，使用处理流后的输出流更加方便。 输入输出流体系提供了近40个类，常用的类分成如下： 分类 字节输入流 字节输出流 字符输入流 字符输出流 对象流 ObjectInputStream ObjectOutputStream 抽象基类 FilterInputStream FilterOutputStream FilterReader FilterWriter 抽象基类 IuputStream OutputStream Reader Writer 访问文件 FileInputStream FileOutputStream FileReader FileWriter 访问数组 ByteArrayInputStream ByteArrayOutputStream CharArrayReader CharArrayWriter 访问管道 PipedInputStream PipedOutputStream PipedReader PipedWriter 访问字符串 StringReader StringWriter 缓冲流 BufferedInputStream BufferedOutputStream BufferedReader BufferedWriter 通常字节流的功能更加强大，因为计算机的数据都是二进制的，而字节流可以处理所有二进制文件；如果要处理文本文件，则应该考虑使用字符流处理。另外还有一些不在java.io包下的字节流，它们具有特殊的功能。表中有四个访问管道的IO流，它们用于实现进程间的通信。四个缓冲流增加了缓冲功能，提高输入输出效率，同时需要使用flush()才能将缓冲区内容写入IO节点。对象流用于实现对象的序列化。 转换流有两个转换流用于实现字节流转换成字符流，其中InputStreamReader将字节输入流转换成字符输入流，OutputStreamWriter将字节输出流转换成字符输出流。Java使用System.in代表标准输入，它是InputStream类的实例，使用不是很方便，所以用InputStreamReader将其转换成字符输入流；再者，普通的Reader读取输入输入内容不方便，可以将Reader包装成BufferedReader，利用readLine()方法一次读取一行内容。 12InputStreamReader reader = new InputStreamReader(System.in);BufferedReader br = new BufferedReader(reader); 推回输入流在IO流体系中有两个流比较特殊，PushbackInputStream和PushbackReader,它们都提供如下三个方法： voidunread(byte[]/char[] buf)：将一个字节&#x2F;字符数组内容推入缓冲区，从而能重复读取刚刚读取的内容。 void unread(byte[]/char[] b,int off,int len)：将一个字节&#x2F;字符数组里从off开始，长度为len字节&#x2F;字符内容推入缓冲区，从而允许重复读取。 void unread(int b)：将一个字节&#x2F;字符推入缓冲区，从而允许重复读取。 这三个方法与InputStream和Reader中的三个方法相对应，它们各有一个推回缓冲区，当调用unread()方法时，系统会把指定数组内容推回缓冲区，并且每次调用read()方法时总是从推回缓冲区读取。当完全读取缓冲区内容后，但还没有装满read()的存放数组时才会从输入流中读取。当创建PushbackInputStream和PushbackReader时需要指定缓冲区大小，而默认大小为1。如果超出大小将会引发IO异常。 重定向输入输出Java的标准输入&#x2F;输出分别通过System.in和System.out代表，获取输入和输出，输出是输出到屏幕上。在System类下有如下三个重定向的方法： static void setErr(PrintStream err)：重定向标准错误输出流。 static void setIn(InputStream in)：重定向标准输入流。 static void setOut(PrintStream out)：重定向标准输出流。 12PrintStream p = new PrintStream(new FileOutputStream(&quot;out.txt&quot;));System.setOut(p); 以上代码重定向输出流到一个文本文件中，所以输出时将不会输出到屏幕上，而到了文件中。同样也可以重定向输入，指定从文件输入。 Java虚拟机读写进程数据使用Runtime对象的exec()方法可以运行其他程序，该方法产生一个Process对象，代表程序启动的子进程。Process类提供了如下三个方法，用于让程序和其子进程进行通信。 InputStream getErrorStream()：获取子进程的错误流。 InputStream getInputStream()：获取子进程的输入流。 OutputStream getOutputStream()：获取子进程的输出流。 需要注意的是，此处的输入输出流应该站在程序的角度上理解，让子进程读取程序中的数据，要用输出流而不是输出流，相当于子进程代替了文件节点一样。 RandomAccessFile文件随机访问类与普通的输入输出流不同，RandomAccessFile支持随机任意访问，程序可以直接跳到文件任意地方来读写文件。它允许自由定位文件记录指针，RandomAccessFile可以不从开始地方输出，所以可以在后面追加内容。同时，需要注意的是该类不能读写其他IO流节点，只能读写文件。每一个对象包含一个记录指针，用以标识当前读写处位置。 long getFilePointer()：返回文件记录指针的位置。 void seek(long pos)：将文件记录指针定位到pos位置。 RandomAccessFile包含类似于InputStream的三个read()方法，用法和其他read()方法完全一样，同样也包含类似的write()方法。该类有两个构造器，只是形参不同，一个是使用String参数指定文件名，另一个是使用File参数指定文件名。此外，还需要指定一个mode访问模式参数。 r：只读打开文件。 rw：读写方式打开文件，若不存在则创建文件。 rws：读写方式打开，文件和元数据的更新都同步写入底层储存设备。 rwd：读写方式打开。文件更新都同步写入底层设备。 RandomAccessFile依然不能向指定位置插入内容，如果移动文件指针到中间位置，则新输出的会覆盖文件中原有的内容。如果先把插入点后面的内容读入缓冲区，等新内容写入后再把缓冲区内容追加到后面便可实现。","categories":[{"name":"java","slug":"java","permalink":"https://aachou.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://aachou.github.io/tags/java/"},{"name":"IO流体系","slug":"IO流体系","permalink":"https://aachou.github.io/tags/IO%E6%B5%81%E4%BD%93%E7%B3%BB/"}],"author":"沧海一粟"},{"title":"Java-IO流","slug":"Java-IO流","date":"2020-11-01T09:20:57.000Z","updated":"2023-08-09T10:15:01.000Z","comments":false,"path":"2020/1101/","permalink":"https://aachou.github.io/2020/1101/","excerpt":"Java-IO流(一)java的IO通过java.io包下的类和接口来支持，在该包下主要有输入、输出两种IO流，每种输出、输入流又可分为字节流和字符流。此外，Java的IO流使用了一种装饰器设计模式，将IO流分成底层节点流和上层处理流，其中节点流用于和物理储存节点直接关联，不同物理节点获取节点流的方式可能有差异，但程序可以把不同物理节点流包装成统一的处理流","text":"Java-IO流(一)java的IO通过java.io包下的类和接口来支持，在该包下主要有输入、输出两种IO流，每种输出、输入流又可分为字节流和字符流。此外，Java的IO流使用了一种装饰器设计模式，将IO流分成底层节点流和上层处理流，其中节点流用于和物理储存节点直接关联，不同物理节点获取节点流的方式可能有差异，但程序可以把不同物理节点流包装成统一的处理流，从而允许程序使用统一的输入输出代码来读取不同的物理存储节点的资源。java.nio及其子包提供了一系列API，是对原IO的升级。 File类访问文件和目录File类是java.io包下代表与平台无关的文件和目录，也就是说它并不能访问文件，需要时使用IO流。File可以使用文件路径字符串来创建File实例，通过调用实例方法来访问，如下： 访问文件名相关 String getName()：返回此File对象所表示的文件名或路径名。 String getPath()：返回此File对象所对应的路径名。 File getAbsoluteFile()：返回此File对象的绝对路径。 String getAbsolutePath()：返回File对象对应的绝对路径名。 String getParent()：返回File对象对应目录的父目录名。 boolean renameTo(File newName)：重命名文件或目录，成功返回true。 还有文件检测方法、获取常规文件、文件操作相关和目录操作相关的方法等。注意文件路径用斜杠/表示！ 文件过滤器在File类的list()方法中可以接收一个FilenameFilter参数，通过该参数可以列出符合条件的文件，这里的FilenameFilter接口和javax.swing.filechooser包下的FileFilter抽象类的功能非常相似，可以把FileFilter当成FilenameFilter实现类，但实际上没有实现该接口。 FilenameFilter接口包含一个accept(File dir,String name)方法，该方法对File所指定的目录或文件进行迭代，如果返回true，则list()方法会列出该子目录或文件。FilenameFilter接口内只有一个抽象方法，因此该接口也是一个函数式接口，则可使用Lambda表达式创建该接口对象。 12File file = new File(&quot;.&quot;);String[] nameList = file.list( (dir,name)-&gt;name.endsWith(&quot;.java&quot;)||new File(name).isDirectory()); Java的IO流Java输入&#x2F;输出源抽象表述为“流”stream，然后通过流的方法访问不同的输入&#x2F;输出源。stream是从起源到接收sink的有序数据。所有的传统流的类都在java.io包下，以实现输入&#x2F;输出功能。 输入输出流 输入流：只能从中读取数据，而不能写入数据 输出流：只能向其写入数据，不能读数据。 Java的输入流主要由InputStream和Reader作为基类，输出流由OutputStream和Writer作为基类。 字节流和字符流两者区别在于所操作的数据单元不同，字节流操作的数据单元是8位字节，而字符是16位的字符。字节流主要由InputStream和OutputStream作为基类，字符流由Reader和Writer作为基类。 节点流和处理流可以向一个特定的IO设备读写数据的流称为节点流low level stream；处理流则对一个已存在的流进行连接或封装，通过封装后的流来实现数据读写功能，不会连接到实际的数据源，同时它被称作高级流。Java使用处理流来包装节点流是一种典型的装饰器设计模式，通过来包装不同的节点流来消除节点间的差异，以通过更多方法完成输入输出，也叫包装流。 IO流涉及40多个类，这些类非常有规则，它们都是从以下4个抽象基类派生而成。 IuputStream/Reader：所有输入流的基类，前者是字节输入流，后者是字符输入流。 OutputStream/Writer：所有输出流的基类，前者是字节输出流，后者是字符输出流。 此外，处理流的功能体现在以下两个方面： 性能提高：增加缓冲的方式提高IO效率。 操作便捷：处理流提供大量方法输入输出大批内容。 字节流和字符流InputStream和ReaderInputStream包含如下三个方法： int read()：从输入流读取单个字节，并返回数据 int read(byte[] b)：从输入流中最多读取b.length个字节并存储在数组中，返回实际读取的字节数。 int read(byte[] b,int off,int len)：从off开始读，最多读取len个字节数据，放入b中，返回实际读取字节。 Reader也有三个类似方法，但是读取字符数据。最后要显式关闭IO流，回收资源。 OutputStream和Writer void witer(int c)：将指定字节&#x2F;字符输出到输出流中，c可以是字节或字符。 void writer(byte[]/char[] buf)：将字节或字符数据输出到指定输出流中 void writer(byte[]/char[] buf,int off,int len)：从off开始，将长度为len的数据输出到输出流。 Writer还包含void writer(String str),void writer(String str,int off,int len)方法，用字符串代替字符数组。","categories":[{"name":"java","slug":"java","permalink":"https://aachou.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://aachou.github.io/tags/java/"},{"name":"IO流","slug":"IO流","permalink":"https://aachou.github.io/tags/IO%E6%B5%81/"}],"author":"沧海一粟"},{"title":"Java反射篇","slug":"Java反射篇","date":"2020-10-21T09:20:32.000Z","updated":"2023-08-09T10:15:19.000Z","comments":false,"path":"2020/1021/","permalink":"https://aachou.github.io/2020/1021/","excerpt":"Java反射对象在运行时会有两种类型，编译时类型和运行时类型，例如：String a = new Name()，编译时为String，运行时为Name。为了准确知道该对象的类型，可以通过instanceof()方法，但是在什么都不知道的情况下，只能通过反射获取该对象的信息。","text":"Java反射对象在运行时会有两种类型，编译时类型和运行时类型，例如：String a = new Name()，编译时为String，运行时为Name。为了准确知道该对象的类型，可以通过instanceof()方法，但是在什么都不知道的情况下，只能通过反射获取该对象的信息。 获取Class对象每个类被加载后就会有Class对象生成，通过该对象就可以访问JVM中的这个类了。这里介绍三种获取Class对象的方法： 使用Class类的forName(String clazzName)静态方法，参数为类的全限定类名。 调用class属性来获取Class对象，例如：Human.class。 调用类实例的getClass()方法。该方法在java.lang.Object已定义。 从Class对象中获取信息Class类提供了大量实例方法来获取对应的类信息，一些如下： Constructor getConstructor(Class&lt;?&gt; Types)：返回对应类的带参的public构造器。 Constructor&lt;?&gt;[ ] getDeclaredConstructors()：返回所有构造器，不受访问权限限制。 Method getDeclaredMethod(String name,Class&lt;?&gt; …parameterTypes)：返回带指定形参的方法，访问权限无关。 Field getField(String name)：返回对应类的指定名称的public成员变量。 以下用于访问注解： A getAnnotation(Class annotationClass)：用于获取指定类型的注解，不存在返回null A getDeclaredAnnotation(Class annotationClass) Annotation[ ] getAnnotations()：返回对应类上所有注解。 A[ ] getAnnoationByType(Class annotationClass)：获取修饰该类的、指定的多个注解，例如重复注解。 如下方法访问内部类：Class&lt;?&gt;[] getDeclaredClasses()：返回类中的全部内部类。 访问外部类方法： Class&lt;?&gt; getDeclaringClass()：返回对应类所在的外部类。 Class&lt;?&gt;[] getInterfaces()：返回对应类实现的全部接口。 Class&lt;? super T&gt; getSuperclass()：返回对应类的父类的Class对象。 以下用于获取对应类的修饰符、所在包、类名： int getModifiers()：返回修饰符，返回的整数用Modifier工具类来解码。 Package getPackage()：获取类的包名。 String getName()：返回类名 String getSimpleName()：返回类名简称。 还有方法判断类是否为一个接口或注解的，如：boolean isAnnotation()。上述大量方法都是分好的，很有规律。之所以有大量重复类名的方法，是因为在获取Method的时候，类重载了许多方法，想要获取指定的方法必须给出相应的形参列表： 1clazz.getMethod(&quot;info&quot;,String.class); 而获取构造器时无需传入构造器名，只需要给出形参列表即可。 Java8新增的方法参数反射Java8在java.lang.reflect包下新增一个Executable抽象基类，该对象代表可执行的类成员，同时该类派生了Constructor、Method两个子类。抽象基类提供了获取修饰方法或构造器注解信息的方法，通过getModifiers()方法获取该方法或构造器的修饰符。此外有两个方法来得到方法和形参名及个数： int getParameterCount()：获取构造器或方法的形参个数。 Parameter[] getParameters()：获取该构造器或方法的所有形参。 同时在获取形参parameter之后，还提供几个方法获取形参的参数信息： getModifiers()：获取形参修饰符。 String getName()：获取形参名 Type getParameterizedType()：获取带泛型的形参。 Class&lt;?&gt; getType()：获取形参类型 boolean isNamePresent()：返回类的class文件中是否包含方法的形参名信息。 boolean isVarArgs()：判断参数是否为个数可变的形参 使用反射生成并操作对象Class对象可以获得类的方法(Method对象)，构造器(Constructor对象)，成员变量(Field对象)，这三个类都位于java.lang.reflect包下，并实现了java.lang.reflect.Member接口，程序可以提供Method调用方法，通过Constructor调用构造器创建实例，能提供Field对象访问并修改成员变量值。 创建对象通过反射来生成对象有以下两种方式： 通过Class对象的newInstance()方法来创建实例，前提是要有默认构造器。 先获取Constructor对象，再调用它的newInstance()方法创建，特点是可以指定构造器创建。 12Class&lt;?&gt; clazz = Class.forName(clazzName);return clazz.newInstance(); 第二种方法获取指定构造器可以通过getConstructor()方法来获取指定构造器。 调用方法通过调用Class对象的getMethod()方法可以获取对应的Method对象，每个对象对应一个方法。Method对象有一个invoke()方法，签名如下： 123//Object invoke(Object obj,args)Method m = clazz.getMethod(Name,String.class);m.invoke(o,config.getProperty(name));//执行名为Name的方法 当通过invoke方法调用对应方法时，需要有调用该方法的权限。若是private方法，可以先调用Method的setAccessible(boolean f)方法，f为true，则该Method使用时取消访问权限检查。 访问成员变量通过Class对象的getField()可以获取该类的成员变量，Field对象提供了如下方法来读取或设置成员变量值： getXxx(Object obj)：获取obj对象的该成员变量的值。Xxx对应8种基本类型，引用类型则取消后面Xxx。 setXxx(Object obj,Xxx val)：将obj对象的成员变量设置成val值，同理。 使用两个方法可以访问指定对象的所有成员变量，包括private修饰的成员变量。 操作数组java.lang.reflect包下还提供一个Array类，Array对象可以代表数组，创建数组。 static Object newInstance(Class&lt;?&gt; componentType,int length)：创建一个指定元素、长度的数组。 static xxx getXxx(Object array,int index)：返回array数组中第index个元素。引用类型为get(Object array,int index) static void setXxx(Object array,int index,Xxx val)：将数组第index个元素的值设为val，如果数组元素为引用类型则方法变成set。 123Object arr = Array.newInstance(String.class,10);//多维再添加数字Array.set(arr,5,&quot;某菜鸡&quot;);Object o = Array.get(arr,5); 用反射生成JDK动态代理在Java的java.lang.reflect包下提供一个proxy类和InvocationHandle接口，通过使用代理类和接口可以生成JDK动态代理类和对象。 使用proxy和InvocationHandle创建动态代理Proxy提供了用于创建动态代理类和对象的静态方法，它是所有动态代理类的父类。如果在程序中为一个或多个接口动态生成实现类，就可以使用Proxy来创建动态代理类；如果需要为一个或多个接口动态创建实例，也可以使用Proxy来创建动态代理实例。 static Class&lt;?&gt; getProxyClass(ClassLoader loader,Class? &gt;interface)：创建一个代理类对应的Class对象，该代理类将实现interfces所指定的多个接口。 static Object newProxyInstance(ClassLoder loder,Class&lt;&gt;[] interfaces,InvocationHandler h)：创建一个动态代理对象，该对象实现了一些接口，执行代理对象的每个方法时都会被替换执行InvocationHandle对象的invoke方法。 采用第一个方法生成代理类的时候，如果需要通过代理类创建对象，依然需要传入一个InvocationHandler对象，即一个代理对象关联一个InvocationHandler对象。 123456789interface person&#123; void walk(); void sayHello(String name);&#125;class MyInvocationHandler implements InvocationHandler&#123; public Object invoke(Object proxy,Method m,Object[] args)&#123; System.out.println(&quot;方法&quot;+m); &#125; &#125; 动态代理和AOP由于JDK动态代理只能为接口创建动态代理，所以下面先提供一个Dog接口： 123456789101112public interface Dog&#123; void info(); void run();&#125;public class GDog implements Dog&#123; public void info&#123; System.out.println(&quot;狗&quot;); &#125; public void run&#123; System.out.println(&quot;疾跑&quot;); &#125;&#125; 如果直接使用代理类为该接口创建动态代理对象，则动态代理对象的所有方法的执行效果将完全一样。下面提供一个DogUtil类。 123456789public class DogUtil&#123; //拦截器方法 public void method1()&#123; System.out.println(&quot;第一个通用方法&quot;); &#125; public void method2()&#123; System.out.println(&quot;通用方法&quot;); &#125;&#125; 借助于Proxy和InvocationHandler就可以实现，当调用info方法和run方法时，系统将自动把两个通用方法插入info和run方法中执行。 1234567891011121314151617181920public class MyInvocationHandler implements InvocationHandler&#123; private Object target; public void setTarget(Object target)&#123; this.target = target; &#125; public Object invoke(Object proxy,Method m,Object[] args) throws Exception&#123; DogUtil d = new DogUtil(); d.method1(); Object result = method.invoke(target,args); d.method2(); return result; &#125;&#125;public class MyProxyFactory&#123;//为target生成动态代理对象 public static Object getProxy(Object target) throws Exception&#123; MyInvocationHandler h = new MyInvocationHandler(); h.setTarget(target); return Proxy.newProxyInstance(target.getClass().getClassLoader(),target.getClass().getIInterfaces(),h); &#125;//返回动态代理&#125; 上面动态代理工厂类提供一个getProxy()方法，该方法为target对象生成一个动态代理对象，这个对象与target实现了同样的接口。当调用动态代理对象的指定方法时，实际上将变为执行MyInvocationHandler对象的invoke方法。执行步骤为： 创建DogUtil实例 执行DogUtil实例的method1()方法 使用反射以target作为调用者执行该方法 执行DogUtil实例的method2()方法 当使用动态代理对象来代替target对象时，代理对象的方法既能插入通用方法，但GDog方法又没有像过去一样调用method1和method2方法。 12345678public class Test&#123; public static void main(String[] args)&#123; Dog target = new GDog(); Dog dog = (Dog)MyProxyFactory.getProxy(target); dog.info(); dog.run; &#125;&#125; dog为实际动态代理对象，实现了Dog接口，动态代理可以很容易实现解耦，这种动态代理在AOP中称为AOP代理，AOP代理包含了目标对象的全部方法。代理中的方法与目标对象的方法有差异：AOP代理包含的方法可以在执行目标方法之前、之后插入一些通用处理。 反射与泛型String.class的类型实际上是Class&lt;String&gt;，如果类型未知，则使用Class&lt;?&gt;，反射中使用泛型可以避免生成的对象需要类型转换。前面介绍了Array类创建数组，其实并不常用，newInstance()返回一个数组，而不是Object对象，如果要当String[]数组使用则要强制类型转换。 1public static Object newInstance(Class&lt;?&gt; componentType,int .... dimension) 如果改为： 1public static &lt;T&gt; T[] newInstance(Class&lt;T&gt; componentType,int length) 则无需类型转换，但是得到参数可变的接收了。 使用反射获取泛型信息得到成员变量对应的Field对象后就可以获得具体的数据类型了，首先应该获得所含的成员变量： 1Class&lt;?&gt; a = f.getType();//获取成员变量的类型 如果成员变量是含有泛型类型，则使用如下方法获取： 1Type t = f.getGenericType(); 之后就可以将Type对象强制转换成ParametericedType对象(被参数化的类型)，它提供了两个方法： getRawType()：返回原始类型，没有泛型信息。 getActualTypeArguments()：返回泛型参数的类型。 getType()方法只能获取普通类型的成员变量的数据类型，而带泛型的成员变量，应该使用getGenericType()方法。Type是java.lang.reflect包下的接口，代表所有类型的高级接口，Class是Type接口的实现类。Type包括原始类型、参数化类型、数组类型、类型变量和基本类型。","categories":[{"name":"java","slug":"java","permalink":"https://aachou.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://aachou.github.io/tags/java/"},{"name":"反射","slug":"反射","permalink":"https://aachou.github.io/tags/%E5%8F%8D%E5%B0%84/"}],"author":"沧海一粟"},{"title":"Java类加载篇","slug":"Java类加载篇","date":"2020-10-18T09:19:51.000Z","updated":"2023-08-09T10:14:52.000Z","comments":false,"path":"2020/1018/","permalink":"https://aachou.github.io/2020/1018/","excerpt":"Java类加载这部分知识比较深入底层，将重点介绍类加载和反射，会提到JDK动态代理、AOP，反射等诸多知识点。当调用Java命令允许程序时，该命令会启动多个线程，它们都处于该Java虚拟机进程里。所有线程、变量处于同一个进程里，它们都使用JVM进程的内存区。当出现以下情况，进程将终止：","text":"Java类加载这部分知识比较深入底层，将重点介绍类加载和反射，会提到JDK动态代理、AOP，反射等诸多知识点。当调用Java命令允许程序时，该命令会启动多个线程，它们都处于该Java虚拟机进程里。所有线程、变量处于同一个进程里，它们都使用JVM进程的内存区。当出现以下情况，进程将终止： 程序结束 使用System.exit()或Runtime.getRuntime().exit()代码 未捕获到异常 强制结束进程 123public class A&#123; public static int a = 6;&#125; 1234567public class Test1&#123; public static void main(String[] args)&#123; A a = new A(); a.a++; System.out.println(a.a); &#125;//输出7&#125; 123456public class Test2&#123; public static void main(String[] args)&#123; A b = new A(); System.out.println(b.a); &#125;//输出6&#125; 上述代码表明，不同的进程之间是不会共享资源的，运行Test1和Test2是运行两次进程，所以第二次依然重新初始化A类。 类的加载当需要使用某个类时，系统会通过加载、连接、初始化三个步骤完成对类的初始化。类加载指的是类加载器将类的class文件读入内存，并为之创建一个java.lang.Class对象。类加载器通常由JVM提供，也称系统类加载器，除此之外，开发者可以通过继承ClassLoader基类来创建类加载器。使用不同类加载器，可以从不同来源加载类的数据通常有以下来源： 本地加载class文件 JAR包中加载class文件 网络加载 把一个Java源文件动态编译并加载 类的连接创建了Class对象后，系统将二进制数据合并到JRE中，这一过程可分为三个阶段： 验证：验证加载的类是否有正确的内部结构 准备：为类变量分配内存，并设置默认值 解析：将类的二进制数据中的符号引用替换成直接引用 类初始化在初始化阶段，JVM负责对类进行初始化，主要对类变量进行初始化。初始化有两种方式： 声明变量时就指定初始值 使用静态代码块指定初始值 JVM初始化一个类是按照一定规则进行的，如下： 如果没有加载和连接，则先加载并连接该类 如果父类没有初始化，则优先初始化其父类 如果有初始化语句，则系统先执行初始化语句 所以JVM总是最先初始化java.lang.Object类，并顺着继承链依次加载并初始化类。程序通过以下6种方式来使用某个类和接口时，系统就会初始化该类或接口： 创建类实例。包括：使用new关键字；反射创建；反序列化创建。 调用类方法。 访问类变量或赋值。 反射强制创建某个类或接口对应的java.lang.Class对象。(如果还未初始化该类) 初始化某类的子类。 使用java.exe命令运行某个类。 对于final型的类变量，如果该类变量的值在编译时就确定下来，那么这个类变量相当于“宏变量”。因此使用静态类变量也不会导致该类初始化，相当于使用常量。如果final修饰的变量不能确定下来，必须等到运行时确定，则将使该类初始化。 类加载器类加载器负责将.class文件加载到内存中，并生成一个java.lang.Class实例，一旦一个类被加载到JVM中，同一个类就不会被再次载入。所谓同一个类指的是有唯一标识的类，唯一标识是用全限定类名作为载入标识。在JVM中一个类用其全限定类名和其类加载器作为其全限定类名，例如：(类、package、加载器实例)。 当JVM启动时，会形成由三个类加载器组成的初始类加载器层次结构，加载顺序如下。 Bootstrap ClassLoader：根类加载器(不是Java实现，一般无法访问) Extension ClassLoader：扩展类加载器 System ClassLoader：系统类加载器 Bootstrap ClassLoader也叫引导(启动)类加载器，负责加载Java核心类。它不是java.lang.ClassLoader的子类，而是由JVM自己实现。 123456789public class BootstrapTest&#123; public static void main(String[] args)&#123; URLS[] u = sun.misc.Launcher.getBootstrapClassPath().getURLS(); //遍历输出根类加载器的全部URL for(int i=0;i&lt;u.length;i++)&#123; System.out.println(u[i].toExternalForm()); &#125; &#125;&#125; Extension ClassLoader，ExtClassLoader(sun.misc.Launcher$ExtClassLoader)的实例，负责加载JRE的扩展目录中的JAR包的类，通过这种方式可以为Java扩展核心类以外的功能，只要把开发的类打包成JAR包即可，然后放入JAVA_HOME/jre/lib/ext路径即可。 System ClassLoader，应用类加载器AppClassLoader的实例，它负责在JVM启动时加载来自命令-classpath或CLASSPATH环境变量所指定的JAR包和类路径。可以通过调用ClassLoader的getSystemClassLoader()方法来获取系统类加载器。 系统类加载器是当前路径，扩展类加载器的加载路径是JAVA_HOME/jre/lib/ext，所以可以说其父加载器为null也不为过，getParent()方法返回null，但根加载器可以作为其父加载器。 类加载机制加载机制有三种： 全盘委托：当某加载器加载一个类时，该类所引用和依赖的其他类也将由该类加载器负责加载。 父类(双亲)委托：先让父类加载器加载class，如果无法加载则从自己的类路径中加载。 缓存机制：保证所有已加载过的类都被缓存，当需要使用某个类时，加载器先从缓存区加载该类，如不存在才会加载对应的二进制数据，并将其转换成Class对象存入内存。(所以修改某个类后需重启JVM才会生效) 一个类加载器查找class和resource时，是通过“委托模式”进行的，它首先判断这个class是不是已经加载成功，如果没有的话它并不是自己进行查找，而是先通过父加载器，然后递归下去，直到Bootstrap ClassLoader，如果Bootstrap ClassLoader找到了，直接返回；如果没有找到，则一级一级返回，最后到达自身去查找这些对象。这种机制就叫做双亲委托。 JDK搜索类的方式ClassLoader使用的是双亲委托模型来搜索类的，每个ClassLoader实例都有一个父类加载器的引用(不是所谓的&#x2F;&#x2F;继承的关系，是一个包含的关系），虚拟机内置的类加载器Bootstrap ClassLoader本身没有父类加载器，但可以用作其它ClassLoader实例的的父类加载器，但是访问ExtClassLoader的父加载器返回null。 当一个ClassLoader实例需要加载某个类时，它会试图在亲自搜索某个类之前，先把这个任务委托给它的父类加载器，这个过程是由上至下依次检查的，首先由最顶层的类加载器Bootstrap ClassLoader试图加载，如果没加载到，则把任务转交给Extension ClassLoader试图加载，如果也没加载到，则转交给AppClassLoader进行加载，如果它也没有加载得到的话，则返回给委托的发起者，由它到指定的文件系统或网络等URL中加载该类。如果它们都没有加载到这个类时，则抛出ClassNotFoundException异常。否则将这个找到的类生成一个类的定义，并将它加载到内存当中，最后返回这个类在内存中的实例对象。 好处：因为这样可以避免重复加载，当父亲已经加载了该类的时候，就没有必要让子ClassLoader再加载一次。考虑到安全因素，我们试想一下，如果不使用这种委托模式，那我们就可以随时使用自定义的String来动态替代java核心API中定义的类型，这样会存在非常大的安全隐患，而双亲委托的方式，就可以避免这种情况，因为String已经在启动时就被引导类加载器(Bootstrap ClassLoader)加载，所以用户自定义的ClassLoader永远也无法加载一个自己写的String类，除非你改变JDK中ClassLoader搜索类的默认算法。 类加载步骤 检查是否有载入过。 如果父类加载器不存在，则使用根类加载器来载入类并返回对应java.lang.Class对象，否则执行第5步；如果存在则使用父类加载器去加载类并返回Class对象，不成功则执行第3步。 当前加载器从与它相关的类路径中寻找，找到就执行第4步，否则执行第5步。 从文件中载入Class，成功后同样返回Class对象。 抛出ClassNotFoundException异常。 JVM规范中规定如果用户自定义的类加载器将父类加载器强制设置为null，那么会自动将启动类加载器设置为当前用户自定义类加载器的父类加载器。同时，即使用户自定义类加载器不指定父类加载器，那么同样可以加载到&#x2F;lib下的类。自定义类加载器不指定父类加载器是默认系统类加载器为父类加载器，按照双亲委派加载。若强制父类加载器为null，则其他加载器就可能不被加载。 加载流程为：系统类加载器–&gt;扩展类加载器–&gt;启动类加载器，强制设置parent为null时关系就已经断了 源代码中走findBootstrapClassOrNull(name)加载 创建自定义类JVM中除根加载器外，其他都是ClassLoader抽象类的子类实例，开发者可以扩展其子类并重写所含方法来实现自定义类加载器。类加载器有两个关键方法： loadClass(String name,boolean resolve)：类加载器的入口点，根据指定名称加载类，并获取Class对象。 findClass(String name)：根据指定名称查找类。 如果需要实现自定义类加载器，则可以通过重写以上两个方法来实现。loadClass()方法的执行步骤如下： 用findLoadedClass(String)来检查是否已经加载类，已加载则返回。 在父类加载器上调用loadClass()方法。如果父类为null，则使用根类加载器来加载。 调用findClass(String)方法查找。 重写finsClass()方法可以避免覆盖默认类加载器的双亲委托、缓存机制，在ClassLoader里还有一个核心方法Class defineClass(String name,byte[] b,int off,int len)，负责将类的字节码文件读入字节数组byte[] b内，并把它转化为Class对象。defineClass()方法管理JVM的许多复杂的实现，不能被重写，因为是final的。除此外还有一些普通方法如下： findSystemClass(String name)：从本地文件系统装入文件，存在就用defineClass()方法将字节码转换成Class对象。 static getSystemClassLoader()：返回系统类加载器 getParent()：获取父类加载器。 resolveClass(Class&lt;?&gt; c)：链接指定类。 findLoaderClass(String name):如果已加载该类，则返回Class实例，否则返回null。 使用自定义类的好处它能用来实现以下功能： 执行代码前自动验证数字签名 根据提供的密码解密代码，避免反编译 动态加载类 把数据以字节码形式加载到应用中 URLClassLoader实现类该类是SystemClassLoader和ExtClassLoader的父类，注意不同上面的所谓“父类”，这里是类之间的继承关系。有如下两个构造器： URLClassLoader(URL[] urls)：使用默认父类加载器创建一个ClassLoder对象，并从指定路径加载类。 URLClassLoader(URL[] urls,ClassLoader parent)：不同上面的构造器，它可以指定一个父类加载器加载类。 获得URLClassLoader对象后，就可以调用loadClass()方法来加载指定类。 123456789101112131415161718private static Connection coon;public static Connection getConn(String url,String user,String pass) throws Exception&#123; if(conn = null)&#123; URL[] urls = &#123;new URL(&quot;file:mysql-connector-java-5.1.30-bin.jar&quot;)&#125;; URLClassLoader myClassLoader = new URLClassLoader(urls); //加载MySQL的JDBC驱动，并创建一个实例 Driver driver = (Driver)myClassLoader.loaderClass(&quot;com.mysql.jdbc.Driver&quot;).newInstance(); //创建一个设置JDBC连接属性的properties对象 Properties props = new Properties(); props.setProperty(&quot;user&quot;,user); props.setProperty(&quot;password&quot;,pass); conn = driver.connect(url,props);//连接数据库 &#125; return conn;&#125;public static void main(String[] args) throws Exception&#123; System.out.println(getConn(&quot;jdbc:mysql://localhost:3306/mysql&quot;),&quot;root&quot;,&quot;123456&quot;);&#125;","categories":[{"name":"java","slug":"java","permalink":"https://aachou.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://aachou.github.io/tags/java/"},{"name":"类加载","slug":"类加载","permalink":"https://aachou.github.io/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD/"}],"author":"沧海一粟"},{"title":"Java注解篇","slug":"Java注解篇","date":"2020-10-16T09:19:31.000Z","updated":"2023-08-09T10:14:38.000Z","comments":false,"path":"2020/1016/","permalink":"https://aachou.github.io/2020/1016/","excerpt":"Java注解从Java5开始，Java增加对元数据的支持，也就是Annotation，不是一般的注释。这些标记在编译、类加载、运行时被读取，并执行相应处理。通过使用注解，开发人员在源文件中嵌入一些补充信息，进而代码分析和部署工具可以通过这些补充信息进行部署","text":"Java注解从Java5开始，Java增加对元数据的支持，也就是Annotation，不是一般的注释。这些标记在编译、类加载、运行时被读取，并执行相应处理。通过使用注解，开发人员在源文件中嵌入一些补充信息，进而代码分析和部署工具可以通过这些补充信息进行部署。某方面看，Annotation就像修饰符一样，可用于修饰包、方法和构造器、变量等，这些信息被储存在Annotation的”name&#x3D;value”对中。 Annotation是一个接口，程序可以通反射来获取指定程序元素的Annotation对象，然后通过注解对象来取得里面的元数据。 基本注解注解必须使用工具提取元数据，工具还会根据元数据增加额外的功能，这种处理访问注解的工具统称APT。5个注解都在Java.lang包下，5个基本注解如下： @Override @Deprecated @SuppressWarnings @SafeVarargs(Java7新增) @FunctionalInterface(Java8新增) 限定重写父类：@Override@Override就是用来指定方法覆盖的，它强制一个子类必须重写父类方法，告诉编译器检查这个方法，避免低级错误。注意的是：@Override只能修饰方法，不能修饰其他程序元素！ 标识已过时：@Deprecated该注解表示类、方法、接口已过时，当其他程序使用已过时的类、方法时，编译器将警告。 抑制编译器警告：@SuppressWarnings顾名思义，注解让编译器不会发出警告，如果修饰在类上，则该类不会有任何警告出现，如果修饰方法，则该方法不会有任何警告出现。 123456@SuppressWarnings(value=&quot;unchecked&quot;)public class SuppressTest&#123; public static void main(String[] args)&#123; List&lt;String&gt; myList = new ArrayList(); &#125;//此处泛型语法警告将被抑制&#125; Java7堆污染警告和@SafeVarargs上次讲泛型的时候，把一个不带泛型的对象赋给一个带泛型的变量时，将有可能引起转换异常，这种错误的原因可以称为堆污染。有些时候，开发者不希望看到该警告，可以用以下三种方法抑制警告： @SafeVarargs修饰该方法或构造器 @SuppressWarnings(“unchecked”) 编译使用-Xlint:varargs Java8的函数式接口与@FunctonalInterfaceJava8规定：如果接口中只有一个抽象方法，该接口就是函数式接口。而该注解就是用来指定某个接口必须为函数式接口的，只能含有一个抽象方法。注意：该注解只能修饰接口！ 元注解JDK除了5个基本注解外，还提供了6个元注解，其中5个都用于修饰其他注解定义，其中的@Repeatable专门用于定义Java8新增的重复注解。 @Retention只能用于修饰注解定义，用于指定注解可以保留多长时间。@Retention包含一个RetentionPolicy类型的Value成员变量，使用时指定值。value成员变量的值只能是如下三个： RetentionPolicy.CLASS：编译器把注解记录在class文件中，当运行程序时，JVM不可获取注解信息。默认值！ RetentionPolicy.RUNTIME：编译器把注解记录在class文件中，当运行程序时，JVM可以获取注解信息，程序可以通过反射获取注解信息。 RetentionPolicy.SOURCE：注解只保留在源代码中，编译器之间丢弃。 123@Retention(value=RetentionPolicy.RUNTIME)public class Test&#123;...&#125;//@Retention(RetentionPolicy.RUNTIME) 也可以,当成员变量为value时，可直接填入值 @Target只能修饰一个注解定义，用于指定被修饰的注解能用于修饰哪些程序单元。。同样它也包含一个名为value的成员变量，其值有： ElementType.ANNOTATION_TYPE：指定注解只能修饰注解 ElementType.CONSTRUCTOR：指定该注解只能修饰构造器 ElementType.FIELD：只能修饰成员变量 ElementType.LOCAL_VARIABLE：只能修饰局部变量 ElementType.METHOD：只能修饰方法 ElementType.PACKAGE：只能修饰包 ElementType.PARAMETER：修饰参数 ElementType.TYPE：可以修饰类、接口、注解或枚举定义 同样的操作，在括号内指定value值，可以省去name=value形式，直接填入值。 1@Target(ElementType.FIELD)//只能修饰成员变量 @Documented指定修饰的Annotation类将被javadoc工具提取成文档，如果定义Annotation类使用了该注解，则所有使用该Annotation修饰的程序元素的API文档中将包含该Annotation说明。 12345@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)@Documentedpublic @interface Test&#123;...&#125;//自定义一个注解，该注解信息将被提取进入API文档 @Inherited指定被它修饰的Annotation具有继承性，即某个类使用了该Annotation，则其子类将自动被该Annotation修饰。 12345@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Inheritedpublic @interface i&#123;...&#125;//使用i注解的类，其子类自动含有该注解 自定义注解上面已经提到了自定义注解，跟定义接口差不多，只不过在interface前添加@符号。通常自定义注解可以修饰任何程序元素，比如类、接口、方法等。然而我们可以根据Annotation是否包含成员变量，可以分为两类： 标记注解：没有成员变量，仅提供标记信息。 元数据注解：包含成员变量的Annotation，它们可以接收更多的元数据。 一旦在注解内定义成员变量后，使用时就应该指定成员变量的值，或者直接在注解内指定默认值，可使用default关键字。 1234567891011public @interface MyTag&#123; String name() default &quot;James&quot;; int age() default 32; //int[] ages();&#125;public class Test&#123; @MyTag public void test&#123; ... &#125;&#125; 提取注解信息Java使用Annotation接口来代表程序元素前的注解，该接口是所有注解的的父接口，同时在java.lang.reflect包下新增AnnotatedElement接口，该接口表示可以接收注解的程序元素。该接口的实现类主要有： Class：类定义 Constructor：构造器定义 Field：类的成员变量 Method：类的方法 Package：类的包 包同时还包含一些反射功能的工具类，AnnotatedElement接口是所有程序元素的父接口，所以程序通过反射获取某个类的AnnotatedElement对象之后，就可以调用对象的几个方法来访问Anntation信息。 A getAnnotation(Class annotationClass)：返回指定类型的注解，不存在返回null A getDeclaredAnnotations(Class annotationClass)：获取直接修饰该程序元素、指定类型的Annotation，不存在返回null。 Annotation[ ] getAnnotation()：返回该程序元素上存在的所有注解 Annotation[ ] getDeclaredAnnotations()：返回直接修饰该程序元素的指定Annotation。 boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass)：判断该程序元素上是否有指定类型的注解。 使用第一种的自定义注解，即没有成员变量的注解，它的作用是标记。如下： 123@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface Testable&#123;&#125; 上面的@Testable注解用于标记哪些方法是可以测试的，该注解可以作为JUnit测试的补充。 Java8新增注解重复注解在Java8以前，同一程序元素前最多只能使用一个类型的Annotation，如果需要使用多个相同类型的注解，则必须使用Annotation容器。Java8以前为如下形式： 1@Results(&#123;@Result(name=&quot;James&quot;,location=&quot;james.jsp&quot;),@Result(name=&quot;Kameron&quot;,location=&quot;kameron.jsp&quot;)&#125;) @Results注解只包含一个名为value、类型为Result[]的成员变量，指定多个@Result作为value的属性的数组元素。改进后为： 12@Result(name=&quot;James&quot;,location=&quot;james.jsp&quot;)@Result(name=&quot;Kameron&quot;,location=&quot;kameron.jsp&quot;) 上述即为重复注解，可以被多次使用修饰某一程序元素。开发此类重复注解需要使用@Repeatable修饰。 新增TypeAnnotation注解Java8为ElementType枚举增加了TYPE_PARAMETER、TYPE_USE两个枚举值，这样允许定义枚举时使用@Target(ElementType.TYPE_USE)修饰，这种注解被称为TypeAnnotation 类型注解，TypeAnnotation可用在任何用到类型的地方。比如： 创建对象时(new) 类型转换时 实现接口时 throws声明抛出异常时 以上情况都会用到类型，因此可以使用注解来修饰。 12345678@Target(ElementType.TYPE_USE)@NotNullpublic class TypeTest&#123; public static void main(@NotNull String[] args) throws @NotNull FileNotFoundException&#123; Object a = new @NotNull String(&quot;菜鸡一号&quot;); &#125; public void foo(List&lt;@NotNull String) info)&#123;...&#125;&#125; 要想让这些TypeAnnotation起作用，开发者需要自己实现Type Annotation检查框架或者使用第三方框架。 编译时处理注解APT(Annotation Processing Tool)是一种注解处理工具，它对源代码进行检查，并找出源文件所包含的Annotation信息，做额外处理。使用APT的目的是简化开发者的工作量，因为APT可以在编译程序源代码的同时生成一些附属文件，比如源文件、类文件、XML文件等，内容与源代码文件相关。简而言之，APT可以替代对代码信息和附属文件的维护工作。 Java.exe工具有一个-processor选项，可指定一个Annotation处理器，如果指定了这个处理器，那么这个处理器会在编译时提取并处理源文件中的注解。每个注解处理器都需要实现javax.anntation.processing包下的Processor接口。不过实现该接口必须实现所有方法，因此会采用继承AbstractProcessor方式来实现注解处理器。一个处理器可以处理一种或多种Annotation类型！ 12javac -processor HibernateAnnotationProcessor Person.java//路径下生成一个Person.hbm.xml文件 XML文件根据源代码文件中的Annotation生成，这是使用APT的结果！","categories":[{"name":"java","slug":"java","permalink":"https://aachou.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://aachou.github.io/tags/java/"},{"name":"注解","slug":"注解","permalink":"https://aachou.github.io/tags/%E6%B3%A8%E8%A7%A3/"}],"author":"沧海一粟"},{"title":"Java泛型篇","slug":"Java泛型篇","date":"2020-10-13T09:19:13.000Z","updated":"2023-08-09T10:15:11.000Z","comments":false,"path":"2020/1013/","permalink":"https://aachou.github.io/2020/1013/","excerpt":"Java泛型上次讲了集合，就是放对象的容器，但是集合并不知道对象的具体数据类型，所以很容易发生异常。比如：","text":"Java泛型上次讲了集合，就是放对象的容器，但是集合并不知道对象的具体数据类型，所以很容易发生异常。比如： 12345List a = new ArrayList();a.add(&quot;as&quot;);a.add(&quot;end&quot;);a.add(2);a.forEach(a-&gt;System.out.println(((String)a).length()) );//强制转换错误 Java 泛型generics是JDK 5中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。 假定我们有这样一个需求：写一个排序方法，能够对整型数组、字符串数组甚至其他任何类型的数组进行排序，该如何实现？使用 Java 泛型的概念，我们可以写一个泛型方法来对一个对象数组排序。然后，调用该泛型方法来对整型数组、浮点数数组、字符串数组等进行排序。这样不仅大大减少了代码量，还利于避免不必要的异常！ 泛型菱形语法从Java7开始，在用构造器创建对象时后面不用再带上泛型了，简化了代码，例如： 1List&lt;String&gt; a = new ArrayList&lt;&gt;(); 定义接口、类和泛型方法Java5为接口和类增加了泛型支持，从而可以在创建集合对象时传入类型实参。 12345678910111213141516171819202122232425262728public interface List&lt;E&gt;&#123; void add(E x); Iterator&lt;E&gt; iter(); &#125;public interface StrList extends List&#123; void add(String x); Iterator&lt;String&gt; iter();&#125;public interface StrList extends List&lt;String&gt;&#123; void add(String x); Iterator&lt;String&gt; iter();&#125;public interface Map&lt;K,V&gt;&#123; ...&#125;public class human&lt;T&gt;&#123;//定义一个泛型类 public T man; public human()&#123;&#125; public human(T)&#123;&#125; public T getInfo()&#123; return this.man; &#125;&#125;public class A extends human&lt;String&gt;&#123; public String getInfo()&#123; return &quot;:&quot;+super.getInfo(); &#125;&#125; 上述代码中，定义一个泛型接口，可以衍生出多个类型子接口，同样一个带泛型的父类可以衍生出许多子类，当使用这些接口和父类时，不能再包含类型形参！但是可以不传入类型实参，例如： 12345public class A extends human&#123; public String getInfo()&#123; return super.getInfo().toString(); &#125;//返回字符串类型&#125; 如果需要重写继承父类的子类方法，则需要注意类型。对于泛型，只是允许程序员在编译时检测到非法的类型而已。但是在运行期时，其中的泛型标志会变化为Object类型。 泛型方法方法想定义自己的泛型形参也是允许的，这样还提供了对泛型方法的支持。&lt;&gt;括号内为类型形参声明！ 格式为：修饰符 &lt;T,V&gt; 返回值类型 方法名(形参列表)&#123;...&#125; 123456789101112public class Test&#123; static &lt;T&gt; void test(Collection&lt;? extends T&gt; ele,Collection&lt;T&gt; a)&#123; for(T ele: a)&#123; a.add(ele); &#125; &#125; public static void main(String[] args)&#123; List&lt;Object&gt; ao = new ArrayList&lt;&gt;(); List&lt;String&gt; as = new ArrayList&lt;&gt;(); test(as,ao); &#125;&#125; 泛型构造器123456789101112class Output&#123; public &lt;T&gt; Output(T t)&#123; System.out.println(t); &#125;&#125;public class Test&#123; public static void main(String[] args)&#123; new Output(&quot;发&quot;); new Output(666); new &lt;String&gt; Output(3.14);//实参是Double类型出错 &#125; &#125; 泛型构造器可以认为是泛型方法的特殊一种，不过大致上它们都差不多！ 类型通配符?使用泛型类时，都应该为这个泛型类传入实参，否则会提出警告。类型通配符一般是使用?代替具体的类型参数，它可以匹配任何类型，List&lt;?&gt;在逻辑上是List等所有具体类型实参的父类。 123public void test(List&lt;?&gt; c)&#123; System.out.println(c.get(0));&#125; 这种类型通配符的List仅表示它是各种泛型List的父类，并不能直接添加元素。例如： 12List&lt;?&gt; c = new ArrayList&lt;String&gt;();c.add(new Object()); 由于无法得知c中的元素类型，所以不能向其中添加对象，除了添加null。 类型通配符上限123public void getNumber(List&lt;? extends Number&gt; data) &#123; System.out.println(&quot;data :&quot; + data.get(0));&#125; &lt;? extends T&gt;表示该通配符所代表的类型是T类型的子类(或本身)，&lt;? super T&gt;表示该通配符所代表的类型是T类型的父类。 类型通配符下限类型通配符下限通过形如List&lt;? super Number&gt;来定义，表示类型只能接受Number本身及其父类类型，如Object类型的实例。 泛型方法与类型通配符的区别什么时候用类型通配符，什么时候用泛型方法呢？ 通配符能用来支持灵活的子类化 泛型方法允许类型形参用来表示一个或多个参数或参数与返回值之间的依赖关系 类型通配符可以在方法名中定义形参类型，也可以定义变量类型；但泛型方法的类型形参必须在显示声明 设定类型形参的上限泛型不仅允许使用通配符形参上限，还可以设置类型形参的上限。例如： 123456public class Apple&lt;T extends Number&gt;&#123;//Number及其子类 public static void main(String[] args)&#123; Apple&lt;Integer&gt; a = new Apple&lt;&gt;(); Apple&lt;String&gt; b = new Apple&lt;&gt;();//String不是Number的子类，将引起异常 &#125;&#125; 上面定义了一个泛型类，形参上限是Number及其子类，传入一个String类将导致编译错误。如果需要设定多个上限和接口，表示该形参类型既是父类及其子类，并且实现了多个上限接口。需要注意的是所有接口上限必须在类上限之后，类上限始终在前面。 1public class Apple&lt;T extends Number &amp; java.io.Serializable&gt;&#123;&#125; 擦除和转换严格泛型代码里，带泛型声明的类总应该带着类型参数。但是允许使用带泛型声明的类时，不指定类型实参，如果没有指定的话，则该类型参数被称作raw type原始类型，默认声明为该类型参数的第一个上限类型！ 当把一个带泛型信息的对象赋给另一个没有泛型信息的变量时，泛型信息将抛弃，称擦除。比如一个List&lt;String&gt;类型转给List类型，该List的类型上限变为Object。 如果将List对象赋给一个List&lt;String&gt;对象，不会引起编译错误，但是提示未经检查的转换。 12345List&lt;Integer&gt; a = new ArrayList&lt;&gt;();a.add(6);List list = a;List&lt;String&gt; ls = list;//引起警告System.out.println(ls.get(0));//转换将引起错误 泛型与数组数组元素类型不能包含类型变量或形参，除非无上限类型通配符，但可以声明元素类型包含类型变量或形参的数组。比如：只能说明List&lt;String&gt;[]形式的数组，不能创建ArrayList&lt;String&gt;[10]这样的数组。 1List&lt;String&gt;[] a = new ArrayList[10]; //没有问题","categories":[{"name":"java","slug":"java","permalink":"https://aachou.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://aachou.github.io/tags/java/"},{"name":"泛型","slug":"泛型","permalink":"https://aachou.github.io/tags/%E6%B3%9B%E5%9E%8B/"}],"author":"沧海一粟"},{"title":"Java工具类","slug":"Java工具类","date":"2020-10-12T09:18:33.000Z","updated":"2023-08-09T10:15:34.000Z","comments":false,"path":"2020/1012/","permalink":"https://aachou.github.io/2020/1012/","excerpt":"排序操作Collections提供了如下方法用于对List集合排序： void reverse(List list)：反转顺序 void shuffle(List list)：随机排序 void sort(List list)：按升序排序 void sort(List list ,Comparator)：根据Comparator的顺序指定排序 void swap(List list,int i,int j)：指定元素之间交换 void rotate(List list,int d)：当d为正时，将集合后d个元素整体移到前面；为负时，将前d个元素整体移到后面","text":"排序操作Collections提供了如下方法用于对List集合排序： void reverse(List list)：反转顺序 void shuffle(List list)：随机排序 void sort(List list)：按升序排序 void sort(List list ,Comparator)：根据Comparator的顺序指定排序 void swap(List list,int i,int j)：指定元素之间交换 void rotate(List list,int d)：当d为正时，将集合后d个元素整体移到前面；为负时，将前d个元素整体移到后面 查找替换Collections还提供了如下方法用于查找和替换元素： int binarySearch(List list,Object o)：二分搜索指定List集合，获得对象的索引，前提是集合是有序的。 Object max(Collection c)：根据自然排序，返回最大元素 Object max(Collection c,Comparator comp)：根据指定排序，返回集合中的最大元素 Object min(Collection c)：根据自然排序，返回最小元素 Object min(Collection c,Comparator comp)：根据指定排序，返回集合中的最小元素 void fill(List list,Object o)：使用o替换集合中所有元素 int frequency(Collection c,Object o)：返回集合中o出现的次数 int indexOfSubList(List list,List sublist)：返回子List在集合中第一次出现的位置，若没有则返回-1 int lastIndexOfSubList(List list,List sublist)：返回子List在集合中最后一次出现的位置，若没有则返回-1 boolean replaceAll(List list,Object old,Object new)：使用一个新元素替换所有指定旧元素 同步控制的线程安全Collections工具类提供了多个synchronizedXxx()类方法，该方法将指定集合包装成线程同步的集合。在Map集合中，线程不安全的有HashSet,HashMap,TreeMap,TreeSet,ArrayList,ArrayDeque,LinkedList等，现在可以用该方法包装成线程安全的。 1234Collection c = Collections.synchronizedCollection(new ArrayList());List a = Collections.synchronizedList(new ArrayList());Set s = Collections.synchronizedSet(new HashSet());Map m = Collections.synchronizedMap(new HashMap()); 将创建的对象传入synchronizedXxx()方法，会返回线程安全的List,Map,Set集合对象。 设置不可变集合Collections提供以下三个类方法来返回一个不可变集合： emptyXxx()：返回一个空的，不可变的集合对象，此处集合可以是List，Set,Map。 singletonXxx()：返回一个包含指定对象的不可变集合对象，可以是List,Map。 unmodifiableXxx()：返回集合对象的不可变Map,此处集合可以是List,Set,Map。 方法的参数为原有的集合对象，返回了一个不可变对象(原有对象的不可变版本)。","categories":[{"name":"java","slug":"java","permalink":"https://aachou.github.io/categories/java/"}],"tags":[{"name":"集合","slug":"集合","permalink":"https://aachou.github.io/tags/%E9%9B%86%E5%90%88/"},{"name":"工具类","slug":"工具类","permalink":"https://aachou.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"}],"author":"沧海一粟"},{"title":"Java集合(四)-Map集合","slug":"Java集合-四-Map集合","date":"2020-10-11T09:17:50.000Z","updated":"2023-08-09T10:15:27.000Z","comments":false,"path":"2020/1011/","permalink":"https://aachou.github.io/2020/1011/","excerpt":"Map集合Map的key不允许重复，即两个key通过equals方法比较总是返回false。如果把所以的key放在一起来看，它们就是一个Set集合，就是没有顺序，key之间不能重复。而实际上Map确实包含了一个KeySet()方法，用于返回Map集合的所有key组成的Set集合。另外key集与Set集合里的元素的储存形式也很像，Map子类和Set子类在名字上也很相似，比如HashMap与HashSet等接口和子类。Map和Set之间的关系非常密切，但如果把key-value中的value当作key的附庸，就可以当Set来看Map。","text":"Map集合Map的key不允许重复，即两个key通过equals方法比较总是返回false。如果把所以的key放在一起来看，它们就是一个Set集合，就是没有顺序，key之间不能重复。而实际上Map确实包含了一个KeySet()方法，用于返回Map集合的所有key组成的Set集合。另外key集与Set集合里的元素的储存形式也很像，Map子类和Set子类在名字上也很相似，比如HashMap与HashSet等接口和子类。Map和Set之间的关系非常密切，但如果把key-value中的value当作key的附庸，就可以当Set来看Map。 事实上，Map提供了一个Entry内部类来封装key-value对，而储存时只考虑key。从源码上看，Java先实现了Map，然后通过包装一个所有value都为null的Map就实现了Set集合。如果把所有value放在一起，它们又类似一个List集合，元素与元素之间通过索引来查找，只是Map不是通过整数索引查找，而是用一个对象作为索引。如果需要取出元素，则需要提供元素的key索引。 Map接口提供了大量的实现类，典型的如：HashMap，Hashtable，LinkedHashMap等，其中包括一个内部类Entry，该类封装了一个key-value对，类中包含了三个方法： Object getKey()：返回该Entry里包含的Key值 Object getValue()：返回该Entry里包含的value值 Object setValue(V value)：返回该Entry里包含的value值，并返回新设置的Value值 Map集合最典型的用法就是成对添加和删除key-value对，判断该Map中是否包含指定key，添加新的value会覆盖原有的value。HashMap重写了toString()方法，实际上所有的实现类都重写了该方法调用方法后，总是返回：&#123;key1=balue1,key2=value2...&#125;格式。 Java8改进HashMap和Hashtable实现类其实这种尴尬的关系不是第一次见了，它们的关系如同ArrayList和Vector的关系一样。Hashtable是一个古老的Map实现类，从它的名字就可以看出，没有遵循单词首字母大写的命名规范。它从JDK1.0就已经有了，那时还没有Map接口，所以它包含了两个现在很少用的方法，elements()类似value方法，和keys()方法。同时，Java8改进了HashMap的实现，让它在哈希冲突时依然保持良好的性能。 区别： Hashtable是一个线程安全的实现，而HashMap不是，然而性能比Hashtable好。 Hashtable不允许null作为key和value，但HashMap可以。 其实区别了也没太大意义，因为Hashtable这样古老的类现在用的并不多，如果想要获得线程安全的Map类，可以通过Collections工具类把HashMap转化成线程安全的。 内部元素储存为了成功在HashMap和Hashtable中储存获取对象，用作Key的对象必须实现hashCode()方法和equals()方法，道理和HashSet类似。与HashSet集合不能保证元素顺序一样，两个key相等的标准是通过equals方法返回true，hashCode值也相等。而判断两个value相等的标准更松一点，即equals返回true即可，这种标准在containValue()方法中可以体现。 同样的，当使用自定义类作为HashMap,Hashtable的key时，如果重写该类的equals()方法，hashCode()方法也应该重写，另一方面讲，HashMap与Hashtable对key的要求和HashSet对元素的要求完全相同。同样的问题，如果key是可变对象，则修改了key将导致无法准确访问被修改的key，而无法访问对应的value值。 LinkedHashMap实现类(HashMap子类)HashSet有一个LinkedHashSet子类，HashMap也有一个LinkedHashMap子类。同样，也是采用链表来维护Map的迭代顺序的，并且迭代顺序与插入顺序一致。只需在插入时保持应有的顺序即可，而避免对其排序所带来的成本。由于要维护顺序，所以性能上稍逊HashMap，然而像上次讲的那样，这也是优点，就是迭代起来比较方便。 12345LinkedHashMap weights = new LinkedHashMap();weights.put(&quot;小明&quot;,110);weights.put(&quot;菜鸡一号&quot;,130);weights.forEach((key,value)-&gt;System.out.println(key+&quot;-&gt;&quot;+value));//Java8新增forEach()方法遍历Map Properties类(Hashtable的子类)顾名思义，该类在处理属性文件时特别方便，Properties类可以把Map对象中的key-value写入属性文件，也可以从属性文件中加载键值对到Map对象中去。由于属性名和属性值只能是字符串，所以其中的key,value都是字符串类型，Properties相当于一个key,value都是String类型的Map。该类提供了如下三个方法来修改Properties里的key,value值，注意是“修改”，后面会介绍几个读写方法。 String getProperty(String key)：获取Properties中指定属性名对应的属性值，类似get方法。 String getProperty(String key,String defaultValue)：功能与上一个类似，但可以指定key不存在时的默认值。 Object setProperty(String key,String value)：设置属性值，类似put方法 还有两个读写属性方法： void load(InputStream in)：从属性文件(输入流表示)中加载key-value对，并把对加到Properties里。 void store(OutputStream out,String comments)：将ProPerties中的key-value对输出到指定属性文件中去。 12345Properties p = new Properties();p.setProperty(&quot;username&quot;,&quot;菜鸡二号&quot;);p.store(new FileOutputStream(&quot;a.ini&quot;),&quot;user&quot;);Properties p1 = new Properties();p1.load(new FileInputStream(&quot;a.ini&quot;)); 程序在当前路径下生成一个a.ini文件，内容如下： 1234#user#Thu Oct 9password=123456username=菜鸡一号 SortedMap接口与TreeMap实现类不难发现，该类与TreeSet和SortedMap的关系一样，TreeMap也是一个红黑树结构，即每个key-value对作为一个节点，而在储存它们时需要进行排序。所以它也有两种排序方式： 自然排序：key必须实现Comparable接口，且为同一类的对象，否则抛出ClassCastException异常。 定制排序：在创建TreeMap时，传入一个Comparator对象，该对象负责对TreeMap中的所有key进行排序，但是不要钱实现Comparable接口。 类似TreeSet判断元素相等的标准一样，两个key通过compareTo()方法返回0，即为相等。如果equals()与compareTo()方法返回结果不一致，TreeMap与Map接口就会冲突。同样，它也有相类似的方法访问key-value对。由于TreeMap本身是有序的，所以它增加了访问第一个、最后一个、前一个和后一个的key-value对方法，并提供了截取几个子TreeMap方法。 WeakHashMap实现类用法和HashMap类似，区别在于HashMap的key保留了对实际对象的强引用，这表示只要HashMap对象不被销毁，所有key所引用的对象就不会被垃圾回收。但WeakHashMap对象的key所引用的对象没有被其他强引用变量所引用，则引用的对象有可能被垃圾回收，而且WeakHashMap也可能自动删除这些key所对应的key-value。 每个key只持有对实际对象的弱引用，因此，在垃圾回收该key所引用的实际对象后，集合也会自动删除该键值对。 12345678910WeakHashMap w = new WeakHashMap();w.put(new String(&quot;语文&quot;),new String(&quot;及格&quot;));w.put(new String(&quot;数学&quot;),new String(&quot;优秀&quot;));w.put(&quot;java&quot;,new String(&quot;优秀&quot;));System.out.println(w);//&#123;语文=及格,java=优秀,数学=优秀&#125;Syste,.gc();System.runFinalization();System.out.println(w);&#123;java=中等&#125; 从上面看出，系统进行垃圾回收时，删除了原先的两个键值对，这是由于这两个key都是匿名字符串对象，WeakHashMap只保留了它们的弱引用，所以垃圾回收时将自动删除这两个键值对。如果想使用key来保留对象的弱引用，则不要让key所引用的对象有任何强引用！ IdentityHashMap实现类实现机制和HashMap类似，但在处理两个key相等时比较独特。在IdentityHashMap中，当且仅当两个key严格相等时，即key1 == key2，IdentityHashMap才认为两个key相等。而对于普通HashMap而言，只需要通过equals方法比较，且它们的hashCode值相等即可。 在提供的方法上，IdentityHashMap提供了与HashMap相类似的方法，也允许使用null作为key和value！同样，它也不能保证键值对之间的顺序，更不能保证它们的顺序以后不会变。 123456IdentityHashMap i = new IdentityHashMap();i.put(new String(&quot;菜鸡&quot;),88);i.put(new String(&quot;菜鸡&quot;),90);i.put(&quot;java&quot;,100);i.put(&quot;java&quot;,101);//字符串直接量System.out.println(i); 输出结果为： 1&#123;java=101,菜鸡=90,菜鸡=88&#125; 由于前两个是字符串对象，所以&#x3D;&#x3D;比较后返回false，后两个是字符串直接量，Java用常量池管理字符串直接量，则将会返回true，最后一次添加为最终结果。这种问题在之前就讲过，为啥直接量包装成对象&#x3D;&#x3D;比较会返回true，应该是在包装类那里提到过。 EnumMap实现类这是一个和枚举类一起实现的Map，其中所有的key都必须是单个枚举类的枚举值。在创建EnumMap时，必须隐式或显示的指定它的对应的枚举类。特点有： 在内部以数组的形式保存元素，十分高效 有顺序，根据key的自然排序维护键值对。可以通过keySet(),entrySet(),values()方法遍历集合看到！ 不允许将null作为key，但允许作为value。如果只是查询或删除不会抛出异常！ 需要注意的是，在创建EnumMap时，必须指定一个枚举值，从而将该EnumMap和指定枚举类关联起来。如果不理解可以参考一下EnumSet集合，类似的。 123456789enum Names&#123;Jason,Toray,Massa&#125;public class EnumTest&#123; public static void main(String[] args)&#123; EnumMap e = new EnumMap(Names.class); e.put(Names.Jason,&quot;就欧森&quot;); e.put(Names.Toray,&quot;陀螺仪&quot;); System.out.println(e); &#125;&#125; 输出为： 1&#123;Jason=就欧森,Toray=陀螺仪&#125; 各Map实现类性能分析在讲解Map集合类的过程中，经常性的提到对象之间的比较，value之间的比较及它们的标准；如果是有排序功能的集合，则还会提到实现Comparable接口，或者传入Comparator对象进行排序；而且还会提到是否能保存null值，或能不能把它作为key，value等。 提到性能，最主要还是集中在HashMap,Hashtable,TreeSet,TreeMap,LinkedHashSet,LinkedHashMap等Map集合类的分析·。然而在分析的时候并不是太难纠结，由于要维护了啥，所以性能略低；由于实现了啥，所以性能有所下降等。在使用TreeMap时有一个好处，key-value总是处于有序状态，无需专门排序，在被添入键值对后，就可以使用KeySet()方法取得key所组成的Set，然后就可以直接使用toArray()方法生成key的数组，接下来使用binarySearch()方法可以在以排序的数组中二分查找对象。EnumMap性能最好，但它只能使用同一个枚举类的枚举值作为key。 哈希表的存储哈希表里可以储存元素的位置称为桶bucket，通常一个桶存放一个元素，此时有最好的性能。哈希算法根据哈希值计算出桶的位置，继而从中取出元素。但发生哈希冲突的时候，一个桶会储存多个元素，这些元素会以链表的形式储存，查找时按顺序搜索，由于HashMap,Hashtable,HashSet都使用哈希算法来决定元素的存储，所以其哈希表包含如下属性： 容量capacity：哈希表中桶的数量 初始化容量initial capacity：创建哈希表时桶的数量。HashMap和HashSet都允许在构造器中指定初始化容量。 尺寸size：当前哈希表的元素数量 负载因子load factor：其等于size/capacity大小，若为0则表示空，0.5表示半满哈希表。 另外哈希表还有一个负载极限，它是一个0~1的数，决定了哈希表的最大填满程度。当负载因子到达负载极限时，哈希表会自动成倍增加容量，也就是桶的数量，将原有对象重新分配放入桶内(rehashing)。HashSet,HashMap,Hashtable允许在构造器指定一个负载极限，默认为0.75,这表明负载因子当达到0.75的时候，哈希表会重新分配。 那为啥是0.75呢？其实都是一种取舍后的办法，要时间还是要空间？哈希表是用来查询的，较高的负载极限可以降低内存开销，然而却增加查询数据时间开销；较低的负载极限可以降低时间开销，却增加的内存的开销。如果已经知道要保存大量数据，创建时指定较大的初始化容量就行了，从而可以避免rehashing。","categories":[{"name":"java","slug":"java","permalink":"https://aachou.github.io/categories/java/"}],"tags":[{"name":"集合","slug":"集合","permalink":"https://aachou.github.io/tags/%E9%9B%86%E5%90%88/"},{"name":"Map集合","slug":"Map集合","permalink":"https://aachou.github.io/tags/Map%E9%9B%86%E5%90%88/"}],"author":"沧海一粟"},{"title":"Java集合(三)-List和Queue集合","slug":"Java集合-三-List和Queue集合","date":"2020-10-09T13:25:27.000Z","updated":"2023-08-09T10:15:42.000Z","comments":false,"path":"2020/1009/","permalink":"https://aachou.github.io/2020/1009/","excerpt":"Java集合—List集合与Set集合不同，List集合是有序，可重复的，而且默认以添加顺序设置索引。List子接口是继承了Collection接口，则可以使用其中的方法。","text":"Java集合—List集合与Set集合不同，List集合是有序，可重复的，而且默认以添加顺序设置索引。List子接口是继承了Collection接口，则可以使用其中的方法。 特别的是List增加了根据索引插入、替换、删除集合元素的方法，此外，Java8为List接口添加了两个默认方法： void replaceAll()：根据指定规则重新设置List集合的所有元素 void sort(Comparator c)：根据参数对List集合的元素排序 12345678List books = new ArrayList();books.add(new String(&quot;ledon&quot;));books.add(new String(&quot;Android&quot;));books.sort((o1,o2)-&gt;((String)o1).length()-((String)o2).length());//字符串将由短到长排序System.out.println(books);books.replaceAll(e-&gt;((String)e).length());System.out.println(e);//[5,7] 值得注意的是：List判断两个对象相等，只要通过equals方法比较返回true即可，不像Set集合，还需要判断哈希值是否相等来避免重复。 删除元素时，List会调用对象的equals方法依次与集合元素比较，如果返回true，则会删除该元素。如果重写了equals方法，使它总是返回true，则List总会删除第一个元素。在使用set(index,object)方法时，index不能超过集合的长度，也不能改变长度。 List不仅有iterator()方法，还有listIterator()方法，该方法返回一个ListIterator对象，ListIterator接口继承了Iterator接口，提供了专门的方法操作List，增加了如下方法(类似Iterator的方法)： boolean hasPrevious()：返回该集合是否还有上一个元素 Object previous()：返回上一个元素 void add(Object o)：在指定位置插入一个元素 不难发现该接口还能向前迭代，不止能删除元素，并且还能通过add()方法，添加元素。 ArrayList和Vector它们两个封装了 一个动态的Object[ ]数组，允许再分配。ArrayList及Vector对象使用initialCapacity参数来设置数组的长度，当超出数组容量时，initialCapacity会自动增加，可使用ensureCapacity(int minCapacity)方法一次性增加initialCapacity。如果事先知道元素的个数，可指定初始大小；如果没有指定初始容量，默认为10。 ArrayList和Vector提供了两个方法重新分配Object[]数组： void ensureCapacity(int minCapacity)：将ArrayList和Vector集合的Object[]数组长度增加到大于或等于minCapacity值 void trimToSize()：调整ArrayList及Vector的数组长度为当前元素个数，减少占用空间 ArrayList和Vector的用法几乎完全相同，Vector也是实现了List接口，从JDK1.0就有了，很古老！此外，ArrayList是线程不安全的，原理一样；但Vector是线程安全的，即无需保证线程的同步性，因而Vector的性能比ArrayList低。但是还是用ArrayList更多，要想线程安全，也可以把ArrayList变成线程安全。 Stack类(Vector的子类)翻译过来就是“栈”，模拟进栈push，出栈pop等操作。作为集合的一种，它也是储存对象(Object)的，有如下方法： Object peek()：返回栈顶元素，但并不弹出该元素，元素还会在栈内 Object pop()：返回栈顶元素，并弹出栈 void push(Object item)：推元素进栈 Stack继承了Vector，所以它也非常古老，线程安全、性能较差。后面还会介绍一种“栈”结构——ArrayDeque，它不仅实现了List接口，还实现了Deque接口，如果需要栈结构，可以使用它而不是Stack。 固定长度的List有一种操作数组的工具类Arrays，该工具类提供了asList()方法，该方法把一个数组或指定个数的对象换成一个List集合，这个集合不是以上所介绍的集合类的实例，不是ArrayList的，不是Vector的，而是Arrays的内部类ArrayList的实例。Arrays.ArrayList是一个固定长度的List集合，不允许添加、删除操作，只能遍历访问，否则程序将出现UnsupportedOperationException异常。 Java集合-Queue集合在Queue接口中定义了如下的方法： void add(Object e)：添加元素到队尾 boolean offer(Object e)：将指定元素加入队列的尾部，成功返回true Object element()：获取队列头部的元素，但不是删除该元素 Object remove()：获取头部元素，并删除该元素 Object peek()：获取队列头部的元素，但不是删除，如果为空返回null Object poll()：获取并删除头部元素，为空，返回null Queue有一个PriorityQueue实现类，除此外还有一个Deque接口，代表双端队列，即两端可以添加删除元素。其实现类为ArrayDeque和LinkedList两个实现类。 PriorityQueue类PriorityQueue并不是一个标准的队列，其保存队列的顺序是重新排序了的(按元素的大小)，显然不符合队列的规则。如果调用poll方法，可以看到元素从小到大移出队列。另外需要注意的是，PriorityQueue不允许插入null元素！ 它的排序有两种，自然排序、定制排序，排序规则与TreeSet类似： 自然排序：自然排序时，元素必须实现了Comparable接口，而且是同一类的实例。 定制排序：创建队列时，传入一个Comparator对象，该对象负责排序，但是不要求元素实现Comparable接口 Deque接口与ArrayDequeDeque接口是Queue的子接口，允许对队列两端进行操作，同时，还可以当作“栈”来使用，因为它还有pop、push方法。典型的实现类是ArrayDeque，一个基于数组的双端队列，在创建Deque时，同样可以指定一个numElement元素个数参数，指定Object[ ]数组的长度；如果不指定，则默认长度为16。 ArrayList与ArrayDeque的实现原理差不多，底层采用一个动态的、可再分配的数组实现，初始化可指定初始长度等，当元素个数超出容量时，系统会重新分配一个Object[]数组储存元素。 LinkedList类LinkedList实现了List接口，是List集合，还实现了Deque接口，可以当双端队列使用，还能当”栈”使用。 但它的实现机制与ArrayList、ArrayDeque的不一样，它两是用数组实现，而LinkedList是以链表的形式来保存元素，随机访问性能较差，但插入、删除操作比较溜！ 线性表性能分析一般来说，数组由一块连续的内存来保存数据，所以数组随机访问性能好，类似的，以数组为底层实现的类，随机访问性能都比较好；而链表的插入、删除操作性能好。综合来讲，还是用ArrayList比较妥。 如果需要遍历：对于ArrayList，Vector集合，使用随机访问方法遍历即可；对于LinkedList集合，采用Iterator迭代器遍历比较好。 如果经常要执行插入、删除操作，可以使用LinkedList集合，而使用以数组为底层的线性表要重新分配内部数组大小，性能较差。 如果有多个线程同时访问，可以使用工具类包装成线程安全的集合。","categories":[{"name":"java","slug":"java","permalink":"https://aachou.github.io/categories/java/"}],"tags":[{"name":"List","slug":"List","permalink":"https://aachou.github.io/tags/List/"},{"name":"Queue","slug":"Queue","permalink":"https://aachou.github.io/tags/Queue/"}],"author":"沧海一粟"},{"title":"Java集合(二)-Set集合","slug":"Java集合-二-Set集合","date":"2020-10-03T14:26:07.000Z","updated":"2023-08-09T10:14:17.000Z","comments":false,"path":"2020/1003/","permalink":"https://aachou.github.io/2020/1003/","excerpt":"","text":"Set集合Set集合和Collection基本相同，没有提供额外的方法，主要是行为上的不同，Set不允许包含重复元素，否则add()方法会返回false。接下来将主要介绍四种Set类，HashSet，TreeSet，LinkedHashSet，EnumSet四种。 HashSet类HashSet使用hash算法来储存集合中的元素，具有很好的查找和存取性能，它的特点如下： 不能保证元素的顺序，可能变化 HashSet不是同步的，如果多个线程同时访问并修改一个HashSet，则必须保证其同步。 集合的元素可以是null 当向HashSet集合中存入一个元素时，HashSet会调用对象的hashCode()方法来得到该对象的hashCode值，然后根据该hashCode值决定该对象在HashSet中的位置。但是如果两个元素通过equals()方法返回true，而它们的hahCode()方法返回值不相等，HashSet将会把他们储存在不同的位置，依然可以添加成功。也就是说，HashSet集合判断元素相等的标准是通过equals方法比较相等，并且两个对象的hashCode值一样。 1234567891011121314151617181920212223242526272829Class A&#123; public boolean equals(Object obj)&#123; return true; &#125;&#125;Class B&#123; public int hashCode()&#123; return 1; &#125;&#125;Class C&#123; public int hashCode()&#123; return 2; &#125; public boolean equals(Object obj)&#123; return true; &#125;&#125;public Class HashSet&#123; public static void main(String[] args)&#123; HashSet books = new HashSet(); books.add(new A()); books.add(new A()); books.add(new B()); books.add(new B()); books.add(new C()); books.add(new C()); &#125;&#125;//添加两A,B,C对象 1[B@1 ,B@1 ,C@2 ,A@54d ,A@8773f2] 从上面看出，即使A对象equals方法返回true，依然被当作两个对象；即使两个B对象hashCode方法返回值一样，但HashSet集合储存了两个hash值一样的对象。如果equals返回true，但是会放在不同的地方，不太好。如果hash值一样，但equals返回的false也麻烦了，集合会尝试保存把对象保存在同一个位置，并采用链式结构来保存多个对象，这样会导致利用哈希值查找的时候，性能下降。 所以总结一句：如果需要把对象保存到HashSet集合中去，重写类的equals和hashCode方法，保证equals返回true时，hashCode返回值一样。 HashSet中每个能储存元素的位置通常称为桶(bucket)，如果有多个元素的哈希值相同，但它们通过equals方法返回false，就需要在一个桶内放多个元素，然而这样会导致性能下降。 重写hashCode方法步骤 把对象内的每个参与equals方法比较的实例变量计算处一个int类型的哈希值 实例变量类型 计算方式 实例变量类型 计算方式 boolean hashCode &#x3D; (f ? 0 : 1) float hashCode &#x3D; Float.floatToIntBits(f) 整型byte、char、short、int hashCode &#x3D; (int)f double long L &#x3D; Double.doubleToLongBits(f);hashCode &#x3D; (int)(L^(L&gt;&gt;&gt;32)); Long hashCode &#x3D; (int)(f^(f&gt;&gt;&gt;32)); 引用 hashCode &#x3D; f.hashCode(); 2.用第一步计算出的多个哈希值组合计算出一个哈希值返回，例如： 1return f1.hashCode() + (int)f2;//f1,f2为实例变量 为避免直接相加产生的偶然，可以为各实例变量的哈希值乘以任意质数后再相加。但还有一点需要了解的是，这样并不能完全保证之后就不会产生两个相同的对象，向HashSet中添加可变对象后，后面修改了可变对象的实例变量，可能导致它和集合中其他元素相同，甚至不能正确访问(储存在不同位置，hash值不一样)。 LinkedHashSetHashSet还有一个子类LinkedHashSet，同样也是根据元素的hashCode值来决定元素的储存位置，不同的是它使用链表维护元素的次序，这样可以以插入顺序保存元素。LinkedHashSet需要链表维护次序，所以性能略低于HashSet，但优势在于遍历集合内元素上。另外注意一点，它还是Set，所以依然不允许元素重复！ 12345LinkedHashSet names = new LinkedHashSet();names.add(&quot;James&quot;);names.add(&quot;Jodan&quot;);System.out.println(names);//James,Jodan TreeSet(SortedSet的实现类)既然是实现类，那SortedSet就是TreeSet的接口了，顾名思义，TreeSet可以让元素处于一定次序状态。与HashSet相比，TreeSet额外提供了如下方法： Comparator comparator()：如果TreeSet采用定制排序，则返回定制排序所使用的Comparator，如果采用自然排序，则返回null Object first()：返回第一个元素 Object last()：返回最后一个元素 Object lower(Object e)：返回处于指定元素(任意元素，不需要在集合中)之前的元素 Object higner(Object e)：返回处于指定元素之后(更大的元素)的元素 SortedSet subSet(Object e1,Object e2)：返回从e1到e2的子集合(不包含e1,e2) SortedSet headSet(Object max)：返回子集合，元素都小于max SortedSet tailSet(Object min)：返回子集合，元素大于等于min 综上，大概就是提供了访问第一个、最后一个、前一个、后一个元素的方法，并提供了三个截取子集合的方法。与此同时，TreeSet采用红黑树的数据结构来储存数据，默认情况下使用自然排序。它的排序规则有以下两种： 1.自然排序TreeSet调用集合元素的compareTo(Object obj)方法来比较元素之间的大小关系，然后将集合元素按升序排列，这种就是自然排序。Java提供了Comparable接口，该接口内定义了一个compareTo(Object o)方法，方法返回一个整数。实现接口就必须实现该方法。当一个对象之间进行比较时，例如：obj1.compareTo(obj2)，如果返回0，则表明这两个对象相等；如果返回一个正整数，则obj1大于obj2；如果返回一个负整数，则obj1小于obj2。 下面提供了实现Comparable接口的类，并提供了比较大小的标准。 BigDecimal、BigInteger以及所有数值类型对应的包装类：按数值大小比较 Character：按字符的Unicode进行比较 Boolean：true对应的包装类实例大于false对应的包装类实例 String：按字符串中字符的Unicode值比较 Date、Time：后面的时间、日期比前面的日期大 所以TreeSet会自动地给集合中地大小进行排序，但前提是对象实现了Comparable接口，否则将不可行。还有一点需要说明，大部分类在实现compareTo(Object o)方法时，都需要将被比较对象强制类型转换成相同类型，否则无法比较。然而当添加一个对象到集合中去时，集合会调用对象compareTo()方法与集合中的其他元素进行比较，比较要是同一类的对象。 如果向TreeSet添加对象是自定义对象，则可以向TreeSet中添加多种类型对象，但这并不表明这是最好的选择，也不推荐这样干，当取出对象时，元素之间会报ClassCastException异常。 当把一个对象加入集合中时，集合调用对象的compareTo方法与容器的其他对象比较，然后根据红黑树结构找到它的储存位置。如果两个对象通过compareTo(Object obj)方法比较相等，新对象将无法添加到集合中。总之，如果要不报错，TreeSet中只能添加同一种类型的对象。 对于TreeSet集合而言，判断两个对象相等的唯一标准是：两个对象通过compareTo(Object obj)方法比较相等，返回0，则相等。所以它的添加元素的规则和HashSet一样，假如通过equals方法比较相等，则它们记为同一对象，因此通过compareTo()方法返回0，只能存放一个对象，集合不会让第二个元素进去。同样，如果添加了可变对象，并且还修改了对象的实例变量，将导致集合中对象的顺序变化，然而TreeSet不会调整顺序(甚至会导致删除对象失败，TreeSet性能降低)。 2.定制排序实现定制排序则可以通过Comparator接口，该接口内包含一个int compare(T o1,T o2)方法，用于比较o1、o2的大小，如果返回正整数，则o1&gt;o2；若返回0，则o1&#x3D;o2；若返回负整数，则o1&lt;o2。但依然不可以添加不同类型的对象。 在实现定制排序之前，需要提供一个Comparator对象与TreeSet集合关联，由该对象对集合元素进行排序。 12345678910111213141516171819202122class M&#123; int age; public M(int age)&#123; this.age = age; &#125; public String toString()&#123; return &quot;M(age:&quot; + age +&quot; )&quot;; &#125;&#125;public class Test&#123; public static void main(String[] args)&#123;//Lambda表达式 TreeSet t = new TreeSet((o1,o2)-&gt;&#123;//o1,02这里没有具体类型 M m1 = (M)o1; M m2 = (M)o2; return m1.age&gt;m2.age ? -1:m1.age&lt;m2.age ? 1:0; &#125;); t.add(new M(5)); t.add(new M(-3)); t.add(new M(9)); System.out.println(t); &#125;//Lambda表达式实现了Comparator类型的对象&#125;//输出[M(age:9),M(age:5),M(age:-3)]降序排列 EnumSet类专门为枚举类设计的集合类，EnumSet中所有元素必须是指定枚举类型的枚举值。值得一提的是EnumSet集合也是有序的，但它以枚举值在类中的定义顺序来决定集合元素的顺序。EnumSet在内部以位向量的形式储存元素，因此占用内存非常小，运行效率很好，特别是在批量操作时。 EnumSet不允许加入null元素，如果试图插入将会抛出NullPointerException异常。而如果只是判断集合中是否有null元素或删除它，将不会抛出异常，删除的话会返回false，因为没有null元素。 EnumSet集合没有给出任何构造器来创建对象，但还是提供了一些方法去创建的对象的。如下： EnumSet allOf(Class elementType)：创建一个包含指定枚举类所有枚举值的集合 EnumSet complementOf(EnumSet s)：创建一个其元素类型与指定EnumSet里元素类型相同的EnumSet集合，新集合包含原集合不包含的、此枚举类剩下的枚举值 EnumSet copyOf(Collection c)：使用一个普通集合来创建EnumSet类 EnumSet copyOf(EnumSet e)：创建一个与指定EnumSet具有相同类型、相同元素的EnumSet集合 EnumSet noneOf(Class elementType)：创建一个元素类型为指定枚举类型的空EnumSet EnumSet range(E from ,E to)：创建一个包含从from枚举值到to枚举值范围内枚举值的EnumSet集合 EnumSet of(E first…E rest )：创建一个包含一个或多个枚举值的EnumSet集合(传入的枚举值必须属于同一个枚举类) 123456789101112131415enum Colors&#123;WHITE,YELLOW,RED,GREEN&#125;public class Test&#123; public static void main(String[] args)&#123; EnumSet e1 = EnumSet.allOf(Colors.class); EnumSet e2 = EnumSet.noneOf(Colors.class);//这里为[] e2.add(Colors.WHITE);//这里为[WHITE] EnumSet e3 = EnumSet.of(Colors.RED,Colors.GREEN); System.out.println(e3);//输出[RED,GREEN] EnumSet e4 = EnumSet.range(Colors.YELLOW,Colors.GREEN); System.out.println(e4); //[YELLOW,RED,GREEN] EnumSet e5 = EnumSet.complementOf(e4); //这里为[WHITE] &#125;&#125; 此外还可以复制另一个EnumSet集合中的元素来创建新集合，或者复制一个Collection集合元素来创建新的EnumSet集合。当复制Collection集合元素创建时，要求元素都来自同一个枚举类，否则抛出ClassCastException异常。 1234567Collection c = new HashSet();c.clear();c.add(Colors.RED);c.add(Colors.YELLOW);EnumSet e = EnumSet.copyOf(c);System.out.println(e);//[RED,YELLOW] 各Set实现类的性能分析HashSet总是比TreeSet的性能好，主要体现在添加、查询元素上，因为TreeSet采用了红黑树来维护集合的次序。而HashSet的子类LinkedHashSet对插入、查询操作比父类要稍慢些，这是由于采用了链表维护的缘故，造成了额外开销。但这并不影响LinkedHashSet发挥威力，然而这恰恰是它的优势，在遍历等批量操作上，LinkedHashSet更快。 EnumSet是所有Set类中性能最好的，缺点是只能保存一个枚举类的枚举值。总的说，Set的这三个实现类都是线程不安全的，即当有多个线程访问时，如果修改了Set集合，将不能同步，必须手动保证同步。方法是在创建Set集合时，通过Collections工具类的sychronizedXxx()方法来包装该集合(之后会提到)。","categories":[{"name":"java","slug":"java","permalink":"https://aachou.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://aachou.github.io/tags/java/"},{"name":"Set集合","slug":"Set集合","permalink":"https://aachou.github.io/tags/Set%E9%9B%86%E5%90%88/"}],"author":"沧海一粟"},{"title":"Java集合类-开篇","slug":"Java集合类-开篇","date":"2020-09-29T11:15:31.000Z","updated":"2023-08-09T10:16:50.000Z","comments":false,"path":"2020/0929/","permalink":"https://aachou.github.io/2020/0929/","excerpt":"集合介绍Java集合类是一种特别的工具类，可以储存对象，并实现了常用的数据结构，另外还能保存具有映射关系的关联数组。集合大致分为Set,List,Queue,Map四种，其中Set代表无序、不可重复，List代表有序、重复，Map则代表具有映射关系，Java5增加了Queue集合，代表一种队列集合实现。Java集合就像一种容器","text":"集合介绍Java集合类是一种特别的工具类，可以储存对象，并实现了常用的数据结构，另外还能保存具有映射关系的关联数组。集合大致分为Set,List,Queue,Map四种，其中Set代表无序、不可重复，List代表有序、重复，Map则代表具有映射关系，Java5增加了Queue集合，代表一种队列集合实现。Java集合就像一种容器，把多个对象放到容器中。Java5之前，J集合会丢失对象的数据类型，把所有对象都当成Object类型，从Java5开始增加了泛型，集合可以记住容器中对象的数据类型，从而能编写更简洁的代码。 所有的集合类都位于java.util包下，后来在java.util.concurrent包下提供了多线程集合类。集合类和数组不太一样，数组元素可以是基本数据类型，也可以是对象；而集合只能保存对象(实际保存的是对象的引用变量)。集合类主要由两个接口来实现，Collection和Map，两个根接口。 上图有Map接口的众多实现类，这些类在功能、用法上存在一定的差异，但它们都有一个功能特征，保存的每项数据是Key-value键值对。Map的Key是不可重复的，key用于标识集合集合里的每项数据，如果要查数据，根据Key来获取。添加一个对象到集合中，Set集合无法记住这个元素的顺序，系统无法识别，所以Set里的元素不能重复。 对于这四种集合，其中常用的有：HashSet、TreeSet、ArrayList、ArrayDeque、LinkedList、HashMap和TreeMap等实现类。 Collection和Iterator接口Collection接口是List,Set,Queue接口的父接口，如果接口没弄明白，可以看看之前的文章Java的异常、多态要点及抽象类和接口。Collection接口定义了如下方法： boolean add(Object o) 向集合里添加一个元素，如果添加成功则返回true boolean addAll(Collection c) 把集合内元素添加到指定集合，成功返回true void clear() 清除集合内所有元素，将集合长度变为0 boolean contains(Object o) 返回集合是否包含指定元素 boolean containsAll(Collection c) 返回集合是否包含集合c所有元素 boolean isEmpty() 返回集合是否为空，长度为0返回true Iterator iterator() 返回一个Iterator对象用于遍历 boolean remove(Object o) 删除指定元素o，如果有多个删除第一个 boolean retainAll(Collection c) 从集合中删除集合c里不包含的元素，相当于求和集合c的交集 int size() 返回集合里元素个数 Object[] toArray() 将一个集合转换成数组 boolean remove(Collection c) 从集合中删除集合c里包含的元素 具体可阅读API文档，里面有详细信息。编译时可能会输出一些警告，提醒没有使用泛型来限制集合内元素类型，不过之后会提到泛型编程。当使用System.out的println方法来输出集合对象时，将输出[e1,e2...]形式，这是因为所有Collextion实现类重写了toString方法，该方法可一次性输出集合中所有元素。如果想依次访问集合中的每一个元素，则需要使用某种遍历方法。 集合的遍历一、Lambda表达式遍历 Java8为Iterable接口新增了一个forEach方法，参数类型是一个函数式接口，而Iterable接口是Collection接口的父接口，所以Collection集合类也可以调用该方法。当调用Iterable的forEach(Consumer a)方法时，程序将集合元素传给Consumer的accept(T t)抽象方法，然后用Lambda表达式遍历。 1234Collection names = new HashSet();names.add(&quot;张三&quot;);names.add(&quot;李四&quot;);names.forEach(obj -&gt;System.out.println(&quot; &quot;+obj)); 二、Java8增强Iterator遍历集合 Iterator接口也是Java集合框架的成员，但它与Collection、Map不一样，它们是用来放对象的，而Iterator则用于遍历Collecton集合中的元素，Iterator对象也被称为迭代器。 Iterator接口定义了如下4种方法： boolean hasNext()：如果没有遍历完，则返回true Object next()：返回集合的下一个元素，注意是Object对象 void remove()：删除集合上一次next方法返回的元素 void forEachRemaining(Consumer a):Java8新增的方法，该方法可使用Lambda表达式遍历集合 1234567891011Collection names = new HashSet();names.add(&quot;张三&quot;);names.add(&quot;李四&quot;);Iterator it = names.iterator();while(it.hasNext())&#123; String name = (String)it.next(); System.out.println(name); if(name.equals(&quot;张三&quot;))&#123; it.remove();//names.remove(name);将报错 &#125;//迭代时不能改变集合元素的值&#125; Iterator仅用于遍历集合，本身不提供装载对象的能力。如果要创建一个Iterator对象，则必须要有一个被遍历的集合，没有集合那要Iterator何用。迭代器采用快速报错fail-fast机制，一旦检测到集合已被修改，抽象立即发出ConcurrentModificationException异常，而不是显示修改后的结果，这样可以避免在共享资源时而引发异常问题。 三、用foreach循环遍历集合 除了可以使用Iterator接口迭代访问Collection集合里元素之外，使用Java5提供的foreach循环迭代访问更简单。 1234567Collection names = new HashSet();names.add(&quot;张三&quot;);names.add(&quot;李四&quot;);for(Objection obj : names)&#123; String name = (String)obj; System.out.println(name);&#125; 与Iterator接口迭代集合元素类似，foreach循环中的迭代变量也不是集合元素本身，系统只是把值赋给变量，同样集合也不能改变。 使用Lambda表达式遍历IteratorJava8为Iterator新增forEachRemaining()方法，该方法所需参数同样也是函数式接口，原理类似，调用时将集合元素传给Consumer的accept(T t)方法。 12345Collection names = new HashSet();names.add(&quot;张三&quot;);names.add(&quot;李四&quot;);Iterator it = names.iterator();it.forEachRemaining(obj -&gt; System.out.println(&quot; &quot;+obj)); 本质上还是遍历集合names，所有上面的方法也可以归为遍历集合方法的一种，利用Iterator的forEachRemaining方法和Lambda表达式遍历，又比Iterator自己提供的方法遍历简洁了一点。","categories":[{"name":"java","slug":"java","permalink":"https://aachou.github.io/categories/java/"}],"tags":[{"name":"接口","slug":"接口","permalink":"https://aachou.github.io/tags/%E6%8E%A5%E5%8F%A3/"},{"name":"集合类","slug":"集合类","permalink":"https://aachou.github.io/tags/%E9%9B%86%E5%90%88%E7%B1%BB/"},{"name":"遍历集合","slug":"遍历集合","permalink":"https://aachou.github.io/tags/%E9%81%8D%E5%8E%86%E9%9B%86%E5%90%88/"}],"author":"沧海一粟"},{"title":"Java构造器和初始化块","slug":"Java构造器和初始化块","date":"2020-09-24T05:20:19.000Z","updated":"2023-08-09T10:14:25.000Z","comments":false,"path":"2020/0924/","permalink":"https://aachou.github.io/2020/0924/","excerpt":"Java构造器和初始化块构造器是一个特殊的方法，但定义构造器和普通方法没什么太大区别，该有的都有。不过为了区分还是看看不一样的地方。","text":"Java构造器和初始化块构造器是一个特殊的方法，但定义构造器和普通方法没什么太大区别，该有的都有。不过为了区分还是看看不一样的地方。 方法名：构造器方法名需要和类名一样 返回值：构造器不定义返回值，也不用返回void，但是它会返回一个对象(隐式的) 修饰符：一般设为public权限，可以被其他方法调用 不是静态的：构造器方法不用static修饰 在定义一个类时，没有写构造器，系统将默认提供一个无参构造器。构造器是创建一个对象的途径之一。上面的第四点很少有书提到，但是我们也很少见到用static修饰的构造器—静态构造器。这里先讲一个知识点：在static修饰的方法中如果使用this关键字，则关键字无法指向对象。而访问非静态成员是隐式访问，在没有重名下，省略了this关键字，所以静态成员是无法访问非静态成员。回到static修饰，构造器如果用静态的，则不能访问非静态成员，而构造器是用来初始化成员变量的，那怎么初始化，怎么创建对象？最后还要返回对象。其次，创建对象会比较麻烦，new类名加构造器是不可想象的！ 既然构造器不用类名加构造器访问，开始又没有实例对象，那如何访问呢？因此，Java提供关键字new来调用构造器，所以在构造器中关键字this表示构造器正在初始化的对象，当然大多数情况下可以省略，除了构造器中有一个重名的局部变量的情况下。 1234public MyConstructor()&#123; int son = 0; this.son = 6;//构造器会把所有对象的son属性初始化为6&#125; 构造器的作用主要作用还是为了初始化，默认初始化把所有数字基本类型实例变量设为0，布尔类型为false，引用类型为null，如果想改变一下，可以在构造器中定义。 1234public MyConstructor(String name,int age)&#123; this.name = name;//传入两参数 this.age = age;&#125; 需要注意的是构造器不是全权负责创建对象，在执行构造器之前，系统已为对象分配了内存，结束后构造器返回对象，让引用指向该对象。 构造器重载如果想保留无参构造器，可以提供多个构造器，形成构造器重载。重载后，构造器的参数列表是不一样的，这样能利用不同的构造器创建不同的对象。如果包含多个构造器，其中一个构造器代码包含另一个，如下。这种情况是可以有简洁的代码代替的，但构造器不能直接被调用，用new关键字又会创建一个对象，则使用this关键字很好解决，this调用另一个重载的构造器。此种方法仅限在构造器中使用 1234567891011121314151617public class dog&#123; public String name; public int age; public int weight; public dog()&#123;&#125; public dog(String name,int age)&#123; this.name = name; this.age = age; &#125; public dog(String name,int age,int weight)&#123; this(name,age);//调用另一个构造器的初始化代码 //其实还可以用以下代码代替,但是不建议 //this.name = name; //this.age = age; this.weight = weight; &#125;&#125; 调用父类构造器子类继承父类不会获得父类的构造器，但子类构造器可以调用父类构造器的初始化代码，类似上面的调用另一个重载构造器。在一个构造器中调用另一个构造器用this完成，在子类构造器中调用父类构造器则用super完成。super调用必须出现在子类构造器的第一行，因为Java设计子类执行构造器必须先调用父类构造器，所以它是第一行，然后，然后就没this啥事了，因为刚才讲了，再this调用又要执行父类构造器。this与super不能同时使用！ 子类继承了父类的属性和方法，所以在先初始化父类的属性和方法，这样子类才可以初始化自己特有的，因为java中不允许调用没有初始化的成员。 this就是调用本类的其他构造函数，在其他构造函数中也有默认的super()，或者自定义了带参的super，这样就初始化了父类的成员了，所以写了this的构造函数不能再写super了，因为实例化一个对象运行两次super是不安全的。this放在第一行，也是因为要先初始化父类和this代表的构造函数先，因为当前构造函数可能用到那些成员，所以那些成员得要先初始化 不管是否使用super调用父类构造器，子类总会调用父类构造器一次，有以下情况： 子类构造器使用super显式调用父类构造器 子类构造器使用this调用重载构造器，执行前重载构造器先会隐式调用父类构造器 子类构造器既无super调用，也没有this调用，则系统默认调用父类无参构造器 创建任何对象时，总是从该类所在继承树最顶层类的构造器开始执行，然后往下执行到本类构造器。如果父类构造器还调用了重载构造器，那就会依次执行多个构造器。 初始化块跟构造器作用差不多，初始化块也可以进行对象初始化，它比构造器先执行。它也是类的一种成员，修饰符只能用static修饰，被修饰称为静态初始化块，也可以不修饰。 1234567&#123; a = 6;&#125;int a = 9;public test()&#123; System.out.println(new MyInstance().a);&#125;//输出9，实例变量值为9 类和对象无法调用初始化块，初始化块只在创建对象时隐式执行，而且在构造器之前执行。此外，普通初始化块、声明实例变量指定默认值，都可认为是对象的初始化块，执行顺序和排列顺序一样。 当创建一个对象时，系统先为对象的所有实例变量分配内存，接着程序开始对实例变量初始化，初始化顺序是：先执行初始化块或声明实例变量时指定初始值，再执行构造器中的初始值。 初始化块和构造器与构造器不同，初始化块是一段固定的代码，不接收参数，因此初始化块对同一个类的所有对象的初始化处理是一样的。所以就这种特点，我们可以利用来初始化相同一段值。构造器中相同一段代码可以提炼出相同初始化块，简化了程序，提高了复用性和可维护性。 实际上在编译Java块后，初始化块会消失，初始化块的代码会被“还原”到构造器中，且位于构造器代码前面！ 与构造器类似，创建一个Java对象，不仅会执行该类的普通初始化块和构造器，而且系统会从Object类开始执行，往下执行父类，然后才到该类的初始化块和构造器。如果希望类加载后对整个类进行初始化操作，例如把类变量初始化一下，则需要用静态初始化块。 静态初始化块也叫类初始化块，属于类的静态成员，同样需要遵循静态成员不能访问非静态成员的规则。普通初始化块负责对对象执行初始化，类初始化块则负责对类进行初始化。类初始化时，系统执行静态初始化块。静态初始化块是类相关的，系统将在类初始化阶段执行静态初始化块，而不是创建对象时才执行，因此静态初始化块总是比普通初始化块先执行。静态初始化块不能对实例变量进行初始化处理。 与普通初始化块类似，系统执行类的静态初始化块不仅会执行本类的静态初始化块，还会从源头类Object类开始执行，道理一样。类初始化后，才能使用这个类，然后才能创建对象。一旦类初始化成功，该类在JVM中一直存在，所以创建实例时，无须对类进行初始化。创建实例时，都需要先执行顶层父类的初始化块、构造器，然后执行父类的初始化块、构造器，然后执行本类的初始化块和构造器。静态初始化块-&gt;普通初始化块-&gt;构造器 Java系统加载并初始化某个类时，总是保证该类的所有父类全部加载和初始化！静态初始化块和声明静态变量时所指定的初始值都是该类的初始化代码。JVM第一次主动调用某个类，系统会在类准备阶段为该类所有静态成员分配内存，初始化阶段负责初始化。 123456789public class Test&#123; static &#123; //(1) a = 6; &#125; static int a = 9;//(2) public static void main(String[] args)&#123; System.out.println(Test.a); &#125;//输出9，如果调换(1)(2)则为6&#125;","categories":[{"name":"java","slug":"java","permalink":"https://aachou.github.io/categories/java/"}],"tags":[{"name":"构造器重载","slug":"构造器重载","permalink":"https://aachou.github.io/tags/%E6%9E%84%E9%80%A0%E5%99%A8%E9%87%8D%E8%BD%BD/"},{"name":"初始化块","slug":"初始化块","permalink":"https://aachou.github.io/tags/%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9D%97/"},{"name":"静态初始化块","slug":"静态初始化块","permalink":"https://aachou.github.io/tags/%E9%9D%99%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9D%97/"}],"author":"沧海一粟"},{"title":"变量分类和运行机制及自动装拆箱","slug":"变量分类和运行机制及自动装拆箱","date":"2020-09-19T12:52:12.000Z","updated":"2023-08-09T10:17:30.000Z","comments":false,"path":"2020/0919/","permalink":"https://aachou.github.io/2020/0919/","excerpt":"成员变量和局部变量及运行机制两者的区别在于定义变量的位置不同，运行的机制也有差异。成员变量定义在类中，局部变量定义在定义在方法中。","text":"成员变量和局部变量及运行机制两者的区别在于定义变量的位置不同，运行的机制也有差异。成员变量定义在类中，局部变量定义在定义在方法中。 成员变量分为类变量和实例变量两种，局部变量分为形参(方法内)、方法局部变量和代码块内局部变量，比如循环内的。类变量的生命周期和类一样，从类准备阶段开始，到完全销毁这个类，作用域则与类的生存范围相同。而实例变量从实例被创建起开始存在，直到实例被销毁，作用域对应实例作用域。可以发现，成员变量之所以称为成员变量，是因为其与所在的整体共存亡的。 注意：类变量是属于类的，通过实例.类变量访问的依然是类变量，如果该实例修改了变量值，则其他实例访问时也将使用修改过的变量值。即访问了同一片内存区！ 与成员变量不同，局部变量除了形参外，都必须显式初始化；而上面的成员变量可以进行默认初始化，赋值规则与数组动态初始化时赋值规则相同。 当通过类或对象调用某个方法时，系统1会在调用该方法栈区内为所有形参分配内存，并将实参值赋值给对应形参，即完成形参初始化。 Java允许局部变量和成员变量同名，如果需要在方法内引用被覆盖的成员变量(局部变量和成员变量同名)，可以使用this关键字。 123456789101112131415public class Test&#123; public String name = &quot;猴子&quot;; public static int age = 500; public void outPut()&#123; String name = &quot;悟空&quot;; System.out.println(name);//&quot;悟空&quot; System.out.println(this.name);//&quot;猴子&quot; &#125; public static void main(String[] args)&#123; double age = 100000.0; System.out.println(age);//100000.0 System.out.println(Test.age);//500 new Test().outPut(); &#125;&#125; 成员、局部变量初始化及运行机制在类初始化或对象初始化时，系统会为成员变量分配内存空间，并指定默认初始值。需要关注的是，在创建一个对象时，不需要给类变量分配内存空间，只是为实例变量分配内存空间，因为类初始化时已经分配好了。在创建多个对象时，同样如此，也需要为实例变量分配内存空间，而且，实例变量是单个实例的，与类或其他实例无关。 局部变量定义后，必须经过显式初始化后才能使用，系统不会为局部变量执行初始化，就不会为变量分配内存空间，直到变量被初始化。与成员变量不同，局部变量不属于任何实例或类，因此它被保存在所在的方法栈中。如果变量是基本类型的变量，则会把值直接保存在对应内存中；但是变量是引用类型，则它存放的是地址，地址是所引用的对象或数组的地址。 局部变量的生命周期是和方法或代码块一致，但所在栈内存无需垃圾回收，因为局部变量只保存基本类型的值或引用，所以所占内存比较小。 包装类基本数据类型不具备对象特性：无成员变量，方法被调用。但有些时候显得不那么好，比如方法需要object类型的参数，并且需要提供实际值，像2，3，4，这就麻烦了。Java提供了包装类概念，并为8种基本数据类型定义了引用类型(基本数据类型的包装类)。 基本数据类型 包装类 byte Byte short Short int Integer long Long char Character float Float double Double boolean Boolean 上述除Character外，其他包装类可传入参数创建一个包装类对象， 由于基本数据类型和包装类对象之间转换麻烦，JDK1.5提供了自动装箱和拆箱功能，去解决该问题。 自动装箱：基本类型变量赋值给包装类(或者Object变量)；自动拆箱：包装类对象赋值给基本类型变量 123Integer a = 5;//基本类型赋值给Integer对象Object b = true;//把布尔类型赋值给Object对象int c = a;//Integer对象拆箱赋值给基本类型 虽然包装类是引用类型，但是实例是可以与数值比较的，比较时直接取出包装类的值进行比较。而包装类对象之间比较，只有指向同一对象时返回true。 12345System.out.println(new Integer(1) == new Integer(1));//falseInteger a = 6;Integer b = 6;System.out.println(a == b);//true,待会解释//注意，Integer数据范围在-128~127之间，若不在会重新创建实例 从上面来看，系统将整数装箱成实例，会放入一个cache数组(长度为256，Java就是这样设计的)中缓存起来，以后如需自动装箱则直接指向数组元素(若在-128~127之间)，即引用同一个实例对象。这样的缓存设计有利程序的运行性能，节省开销。 字符串与基本类型的转换字符串转基本类型有两种方式： 包装类的parseXxx(String s)方法(除了Character包装类外) 对应的构造器方法，Xxx(String s) 基本类型转字符串则使用String的多个重载valueOf方法。上述代码示例： 123456String str = &quot;123&quot;;int a = Integer.parseInt(str);//第一种方法int b = new Integer(str);//构造器创建对象，之后拆箱赋值给变量b//基本数据类型转字符串String str1 = String.valueOf(3.14159f);String str2 = String.valueOf(true); Java7、8增强包装类Java7开始为所有包装类提供静态的compare(v1,v2)方法，则可以通过该方法比较基本值的大小。比如： 123System.out.println(Boolean.compare(true,false));//1System.out.println(Boolean.compare(true,true));//0System.out.println(Boolean.compare(false,true));//-1 Java8再次增强，开始支持无符号算术运算。如为Integer、Long增强了静态的toUnsignedString(int&#x2F;long v)整型转化成无符号整数对应的字符串、toUnsignedString(int&#x2F;long v，int radix)转化成指定进制无符号整数对应的字符串。 无符号整数的二进制最高位不再当作符号位看，即最小值为0。例如-2，对应的无符号整数为252","categories":[{"name":"java","slug":"java","permalink":"https://aachou.github.io/categories/java/"}],"tags":[{"name":"变量分类","slug":"变量分类","permalink":"https://aachou.github.io/tags/%E5%8F%98%E9%87%8F%E5%88%86%E7%B1%BB/"},{"name":"自动装拆箱","slug":"自动装拆箱","permalink":"https://aachou.github.io/tags/%E8%87%AA%E5%8A%A8%E8%A3%85%E6%8B%86%E7%AE%B1/"}],"author":"沧海一粟"},{"title":"继承和组合、单例类及不可变类","slug":"继承和组合、单例类及不可变类","date":"2020-09-17T13:15:46.000Z","updated":"2023-08-09T10:15:55.000Z","comments":false,"path":"2020/0917/","permalink":"https://aachou.github.io/2020/0917/","excerpt":"继承和组合、单例类及不可变类继承 inheritance：继承是实现类复用的重要手段，所谓复用，就是可以多次使用，或者再次利用，不用继续重写成员变量和方法。但不代表没有缺点，最不好的地方：破坏封装。子类拓展父类时，若访问权限允许，则可直接访问父类的成员变量和方法，破坏了良好的封装性(Encapsulation) ，造成子类与父类的耦合。","text":"继承和组合、单例类及不可变类继承 inheritance：继承是实现类复用的重要手段，所谓复用，就是可以多次使用，或者再次利用，不用继续重写成员变量和方法。但不代表没有缺点，最不好的地方：破坏封装。子类拓展父类时，若访问权限允许，则可直接访问父类的成员变量和方法，破坏了良好的封装性(Encapsulation) ，造成子类与父类的耦合。 因而，设计父类时应注意以下几点： 尽量隐藏内部数据 不要让子类随意访问 不要在父类的构造器中调用将被子类重写的方法 组合 combination对于继承而言，子类可以获取父类的public方法，使用子类时，可以访问子类从父类继承的方法；组合则是把旧类对象作为成员变量组合进来。我们不需要看到被组合进来的对象的方法，所以通常用private修饰。在功能上，两者没什么区别。 1234567891011121314151617181920class animal&#123; private void beat()&#123; System.out.println(&quot;心跳！&quot;); &#125; public void breath()&#123; System.out.println(&quot;呼吸！&quot;); &#125;&#125;class bird&#123; private animal a; public bird(animal)&#123; this.a = a; &#125; public void breath()&#123; a.breath();//复用animal的方法 &#125; public void fly()&#123; System.out.println(&quot;芜湖起飞！&quot;); &#125;&#125; 注意： 使用组合关系实现复用，需要创建两个animal对象，是否意味着开销更大？ 当创建一个子类对象时，系统不仅需要为该子类定义实例变量分配内存空间，而且需要为它父类所定义的实例变量分配内存。采用继承的方式，假设父类定义了两个实例的变量，子类定义了3个变量。创建子类实例时需要为子类分配5块内存空间。当采用组合设计时，先创建父类实例，此时需要分配2快内存，再创建整体类实例，也需要分配3块内存，只是多了一个引用变量来引用所组合的对象。因此，组合和继承设计开销不会有太大差别。 单例类这种类不像其他类，某些时候允许其他类自由创建该类对象没有什么意义，所以要降低对它的访问权限，让这样的类只能创建一个实例。 方法是把该类的构造方法用private修饰起来，但又需要创建一个对象，所以需要提供一个public方法去用于创建该类的对象，但是不是通过对象来创建对象，而是用类本身去创建，因此方法要用static修饰。 除此之外，该类还必须缓存对象，记录已创建的对象。同时让该静态方法能访问到，保存对象的成员变量也需要static修饰。 12345678910111213class person&#123; //静态成员变量来保存对象 private static person OnlyPerson; //对构造器隐藏 private person()&#123;&#125; //公共方法 public static person getPerson()&#123; if(OnlyPerson==null)&#123; OnlyPerson = new person(); &#125; return OnlyPerson; &#125;&#125; 不可变类 immutable不可变类意思是创建该类的实例后，该实例的变量不可变。Java提供的8个包装类和String类都是不可变类！ 12Double d = new Double(5.6);String s = new String(&quot;abc&quot;); 上面创建了一个Double和String对象，并传入两个值，但程序无法继续修改该值，所以Double和String类没有修改值的方法。 如果要创建一个不可变类，需要遵守如下规则： 使用private和final修饰符来修饰该类成员 提供带参构造器，用于初始化成员 仅提供get方法 确保引用的对象不会被修改 重写hashCode()方法和equals()方法 与此对应的是可变类，比如JavaBean，提供了getter()和setter方法。 缓存实例的不可变类不可变类的实例状态不可改变，可以方便被多个对象共享，主要是为了减小开销。不同的缓存方式有着不同的性能，可以用数组、集合等来缓存。 以Java的java.lang.Integer类为例，new一个构造器，每次返回新的Integer对象；如果用valueOf()方法来创建Integer对象，则会缓存该对象。 123456789101112public class IntegerCacheTest&#123; public static void main()&#123; //new一个对象 Integer a1 = new Integer(6); //生成新对象，并缓存该对象 Inreger a2 = Integer.valueOf(6); Integer a3 = Integer.valueOf(6); System.out.println(a1 == a2);//false System.out.println(a2 == a3);//true //注意：缓存的数只能在-128~127之间 &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://aachou.github.io/categories/java/"}],"tags":[{"name":"继承","slug":"继承","permalink":"https://aachou.github.io/tags/%E7%BB%A7%E6%89%BF/"},{"name":"组合","slug":"组合","permalink":"https://aachou.github.io/tags/%E7%BB%84%E5%90%88/"},{"name":"单例类","slug":"单例类","permalink":"https://aachou.github.io/tags/%E5%8D%95%E4%BE%8B%E7%B1%BB/"},{"name":"不可变类","slug":"不可变类","permalink":"https://aachou.github.io/tags/%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%B1%BB/"}],"author":"沧海一粟"},{"title":"String与BigDecimal基础类","slug":"String与BigDecimal基础类","date":"2020-09-16T11:53:38.000Z","updated":"2023-08-09T10:21:38.000Z","comments":false,"path":"2020/0916/","permalink":"https://aachou.github.io/2020/0916/","excerpt":"","text":"String与BigDecimalString, StringBuffer and StringBuilderstring有11种构造方法 1. 可变性 String不可变 StringBuffer 和 StringBuilder 可变 在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 coder 来标识使用了哪种编码。 12345678public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; /** The value is used for character storage. */ private final byte[] value; /** The identifier of the encoding used to encode the bytes in &#123;@code value&#125;. */ private final byte coder;&#125; value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。 2. 线程安全 String 不可变，因此是线程安全的 StringBuilder 不是线程安全的 StringBuffer 是线程安全的，内部使用 synchronized 进行同步 String Pool字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。不仅如此，还可以使用 String 的 intern() 方法在运行过程将字符串添加到 String Pool 中。 当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。 下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同字符串，而 s3 和 s4 是通过 s1.intern() 方法取得同一个字符串引用。intern() 首先把 s1 引用的字符串放到 String Pool 中，然后返回这个字符串引用。因此 s3 和 s4 引用的是同一个字符串。 123456String s1 = new String(&quot;aaa&quot;);String s2 = new String(&quot;aaa&quot;);System.out.println(s1 == s2); // falseString s3 = s1.intern();String s4 = s1.intern();System.out.println(s3 == s4); // true 如果是采用 “bbb” 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。 123String s5 = &quot;bbb&quot;;String s6 = &quot;bbb&quot;;System.out.println(s5 == s6); // true 在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。 new String(“abc”)使用这种方式一共会创建两个字符串对象（前提是 String Pool 中还没有 “abc” 字符串对象）。 “abc” 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 “abc” 字符串字面量； 而使用 new 的方式会在堆中创建一个字符串对象。 创建一个测试类，其 main 方法中使用这种方式来创建字符串对象。 12345public class NewStringTest &#123; public static void main(String[] args) &#123; String s = new String(&quot;abc&quot;); &#125;&#125; 使用 javap -verbose 进行反编译，得到以下内容： 123456789101112131415161718192021// ...Constant pool:// ... #2 = Class #18 // java/lang/String #3 = String #19 // abc// ... #18 = Utf8 java/lang/String #19 = Utf8 abc// ... public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=3, locals=2, args_size=1 0: new #2 // class java/lang/String 3: dup 4: ldc #3 // String abc 6: invokespecial #4 // Method java/lang/String.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V 9: astore_1// ... 在 Constant Pool 中，#19 存储这字符串字面量 “abc”，#3 是 String Pool 的字符串对象，它指向 #19 这个字符串字面量。在 main 方法中，0: 行使用 new #2 在堆中创建一个字符串对象，并且使用 ldc #3 将 String Pool 中的字符串对象作为 String 构造函数的参数。 以下是 String 构造函数的源码，可以看到，在将一个字符串对象作为另一个字符串对象的构造函数参数时，并不会完全复制 value 数组内容，而是都会指向同一个 value 数组。 1234public String(String original) &#123; this.value = original.value; this.hash = original.hash;&#125; BigDecimalJava在java.math包中提供的API类BigDecimal，用来对超过16位有效位的数进行精确的运算。双精度浮点型变量double可以处理16位有效数。在实际应用中，需要对更大或者更小的数进行运算和处理。float和double只能用来做科学计算或者是工程计算，在商业计算中要用java.math.BigDecimal。BigDecimal所创建的是对象，我们不能使用传统的+、-、*、&#x2F;等算术运算符直接对其对象进行数学运算，而必须调用其相对应的方法。方法中的参数也必须是BigDecimal的对象。构造器是类的特殊方法，专门用来创建对象，特别是带有参数的对象。 BigDecimal一共有4个构造方法: BigDecimal(int) 创建一个具有参数所指定整数值的对象。 BigDecimal(double) 创建一个具有参数所指定双精度值的对象。（不建议采用） BigDecimal(long) 创建一个具有参数所指定长整数值的对象。 BigDecimal(String) 创建一个具有参数所指定以字符串表示的数值的对象 这里不建议采用第二种，原因： 1、参数类型为double的构造方法的结果有一定的不可预知性。有人可能认为在Java中写入 newBigDecimal(0.1)所创建的BigDecimal正好等于 0.1，但是它实际上等于0.1000000000000000055511151。这是因为0.1无法准确地表示为 double（或者说对于该情况，不能表示为任何有限长度的二进制小数）。这样，传入到构造方法的值不会正好等于 0.1（虽然表面上等于该值）。 2、另一方面，String 构造方法是完全可预知的：写入 newBigDecimal(“0.1”) 将创建一个 BigDecimal，它正好等于预期的 0.1。因此，比较而言，通常建议优先使用String构造方法 。 1BigDecimal a = new BigDecimal(&quot;2.3&quot;); 当double必须用作BigDecimal的源时，请使用Double.toString(double)转成String，然后使用String构造方法，或使用BigDecimal的静态方法valueOf，如下： 1BigDecimal a = new BigDecimal.valueOf(Double.toString(2.3)); 对于常用的加，减，乘，除，BigDecimal类提供了相应的成员方法 1234public BigDecimal add(BigDecimal value); //加法public BigDecimal subtract(BigDecimal value); //减法 public BigDecimal multiply(BigDecimal value); //乘法public BigDecimal divide(BigDecimal value); //除法 总结: 在需要精确的小数计算时再使用BigDecimal，BigDecimal的性能比double和float差，在处理庞大，复杂的运算时尤为明显。故一般精度的计算没必要使用BigDecimal。 尽量使用参数类型为String的构造函数。 BigDecimal都是不可变的（immutable）的， 在进行每一次四则运算时，都会产生一个新的对象 ，所以在做加减乘除运算时要记得要保存操作后的值。","categories":[{"name":"Java","slug":"Java","permalink":"https://aachou.github.io/categories/Java/"}],"tags":[{"name":"String","slug":"String","permalink":"https://aachou.github.io/tags/String/"},{"name":"BigDecimal","slug":"BigDecimal","permalink":"https://aachou.github.io/tags/BigDecimal/"}],"author":"沧海一粟"},{"title":"Java的异常、多态要点及抽象类和接口","slug":"Java的异常、多态要点及抽象类和接口","date":"2020-09-07T04:34:04.000Z","updated":"2023-08-09T10:14:44.000Z","comments":false,"path":"2020/0907/","permalink":"https://aachou.github.io/2020/0907/","excerpt":"一、java异常如下图，异常分为两类，错误和异常；异常分为运行异常和可查异常。这里主要掌握异常，因为平时会见的比较多。Exception类在java.lang包下，它是Throwable的子类，同样的Error类也是其子类。Error 用来指示运行时环境发生的错误，例如：JVM 内存溢出。一般地，程序不会从错误中恢复。异常类有两个主要的子类：IOException 类和 RuntimeException 类。","text":"一、java异常如下图，异常分为两类，错误和异常；异常分为运行异常和可查异常。这里主要掌握异常，因为平时会见的比较多。Exception类在java.lang包下，它是Throwable的子类，同样的Error类也是其子类。Error 用来指示运行时环境发生的错误，例如：JVM 内存溢出。一般地，程序不会从错误中恢复。异常类有两个主要的子类：IOException 类和 RuntimeException 类。 Java 根据各个类库也定义了一些其他的异常，有常用检查性和非检查性异常。 异常 描述 ArithmeticException 当出现异常的运算条件时，抛出此异常。例如，一个整数”除以零”时，抛出此类的一个实例。 ArrayIndexOutOfBoundsException 用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引。 ArrayStoreException 试图将错误类型的对象存储到一个对象数组时抛出的异常。 ClassCastException 当试图将对象强制转换为不是实例的子类时，抛出该异常。 IllegalArgumentException 抛出的异常表明向方法传递了一个不合法或不正确的参数。 IllegalMonitorStateException 抛出的异常表明某一线程已经试图等待对象的监视器，或者试图通知其他正在等待对象的监视器而本身没有指定监视器的线程。 IllegalStateException 在非法或不适当的时间调用方法时产生的信号。换句话说，即 Java 环境或 Java 应用程序没有处于请求操作所要求的适当状态下。 IllegalThreadStateException 线程没有处于请求操作所要求的适当状态时抛出的异常。 IndexOutOfBoundsException 指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。 NegativeArraySizeException 如果应用程序试图创建大小为负的数组，则抛出该异常。 NullPointerException 当应用程序试图在需要对象的地方使用 null 时，抛出该异常 NumberFormatException 当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。 SecurityException 由安全管理器抛出的异常，指示存在安全侵犯。 StringIndexOutOfBoundsException 此异常由 String 方法抛出，指示索引或者为负，或者超出字符串的大小。 UnsupportedOperationException 当不支持请求的操作时，抛出该异常。 下面的表中列出了在 java.lang 包中的检查性异常类。 异常 描述 ClassNotFoundException 应用程序试图加载类时，找不到相应的类，抛出该异常。 CloneNotSupportedException 当调用 Object 类中的 clone 方法克隆对象，但该对象的类无法实现 Cloneable 接口时，抛出该异常。 IllegalAccessException 拒绝访问一个类的时候，抛出该异常。 InstantiationException 当试图使用 Class 类中的 newInstance 方法创建一个类的实例，而指定的类对象因为是一个接口或是一个抽象类而无法实例化时，抛出该异常。 InterruptedException 一个线程被另一个线程中断，抛出该异常。 NoSuchFieldException 请求的变量不存在 NoSuchMethodException 请求的方法不存在 异常方法 提一个最常见的，public void printStackTrace()，打印toString()结果和栈层次到System.err，即错误输出流，有点类似错误追踪。 异常捕获 try&#x2F;catch 代码块放在异常可能发生的地方，try&#x2F;catch代码块中的代码称为保护代码，使用 try&#x2F;catch 的语法如下： 12345try&#123; // 程序代码&#125;catch(ExceptionName e1)&#123; //Catch 块&#125; 可以有多个catch语句，叫多重捕获。catch 语句包含要捕获异常类型的声明，当保护代码块中发生一个异常时，try 后面的 catch 块就会被检查。如果发生的异常包含在 catch 块中，异常会被传递到该 catch 块。 抛出异常 如果一个方法没有捕获到一个检查性异常，那么该方法必须使用 throws 关键字来声明。throws 关键字放在方法签名的尾部，也可以使用 throw 关键字抛出一个异常。需要注意的是，如果有必要抛出多个异常，则可以在后面继续添加用逗号隔开。 finally关键字 finally关键字用来创建在 try 代码块后面执行的代码块。无论是否发生异常，finally 代码块中的代码总会被执行。在finally代码块中，可以运行清理类型等收尾善后性质的语句。finally 代码块出现在 catch 代码块最后，语法如下： 123456789try&#123; // 程序代码 &#125;catch(异常类型1 异常的变量名1)&#123; // 程序代码 &#125;catch(异常类型2 异常的变量名2)&#123; // 程序代码 &#125;finally&#123; // 程序代码 &#125; 二、被搞糊涂的多态存在必要条件： 继承 重写 父类引用指向子类对象 比如： 1Parent p = new Child(); 注意(容易忘，容易搞糊涂)：当使用多态方式调用方法时，首先检查父类中是否有该方法，如果有，则去调用子类的同名方法，但不能调用子类独有的方法。多态的好处是可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。 多态的实现方式： 方式一：重写： 方式二：接口 方式三：抽象类和抽象方法 三、Abstract抽象类和接口抽象类：抽象类和其他普通类没什么区别，除了不能实例化外，其他功能都还好。由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。在Java中，抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。 声明抽象方法会造成以下结果： ​ 如果一个类包含抽象方法，那么该类必须是抽象类。 ​ 任何子类必须重写父类的抽象方法，或者声明自身为抽象类。 需要注意：抽象类不一定有抽象方法，而有抽象方法一定是抽象类； 构造方法，类方法(用static修饰的方法)不能声明为抽象方法；抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。 接口：interface接口并不是类，类描述对象的属性和方法，接口则包含类要实现的方法。除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。接口没有构造方法，同样无法被实例化。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。 接口与接口之间则是通过继承来关联，支持多继承！ 12345678910import java.lang.*;public interface NameOfInterface extends a,b,c&#123;//a,b,c接口 public void w(); public void v(); public void e(int period); public void o(int ot); //任何类型 final, static 字段 //抽象方法(隐式)&#125; 接口特性： 接口中每一个方法是隐式抽象的,指定为public abstract（只能是public abstract，其他修饰符都会报错） 接口中可以含有变量，但是会被隐式的指定为public static final 变量(并且只能是public） 接口中每一个方法也是隐式抽象的，声明时不需要abstract关键字，接口中的方法都是公有的public。 抽象类和接口的区别： 抽象类中的方法可以有方法体，但是接口中的方法不行(jdk1.8)。 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。 接口中不能含有静态代码块以及静态方法(用static修饰的方法)，而抽象类是可以有静态代码块和静态方法。 一个类只能继承一个抽象类，而一个类却可以实现多个接口。 注：JDK 1.8 以后，接口里可以有静态方法和方法体了 接口的实现：implements与抽象类不同，当类实现接口的时候，类要实现接口中所有的方法，否则，类必须声明为抽象的类。 12345public class Mydog implements Animal,dog&#123; public void eat()&#123; System.out.println(&quot;Mydog eats&quot;); &#125;&#125; 重写接口中声明的方法时，需要注意以下： 类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常。 类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。 如果实现接口的类是抽象类，那么就没必要实现该接口的方法。 在实现接口的时候，也要注意： 一个类可以同时实现多个接口 一个类只能继承一个类，但是能实现多个接口","categories":[{"name":"Java","slug":"Java","permalink":"https://aachou.github.io/categories/Java/"}],"tags":[{"name":"java异常","slug":"java异常","permalink":"https://aachou.github.io/tags/java%E5%BC%82%E5%B8%B8/"},{"name":"多态","slug":"多态","permalink":"https://aachou.github.io/tags/%E5%A4%9A%E6%80%81/"},{"name":"抽象","slug":"抽象","permalink":"https://aachou.github.io/tags/%E6%8A%BD%E8%B1%A1/"},{"name":"接口","slug":"接口","permalink":"https://aachou.github.io/tags/%E6%8E%A5%E5%8F%A3/"}],"author":"沧海一粟"},{"title":"Hexo-matery主题代码高亮和部署问题","slug":"Hexo-matery主题代码高亮和部署问题","date":"2020-08-22T02:33:06.000Z","updated":"2023-08-09T10:17:56.000Z","comments":true,"path":"2020/0822/","permalink":"https://aachou.github.io/2020/0822/","excerpt":"","text":"本篇的内容很简单，就是说说这个主题的两个问题。一个是代码高亮失效的问题，另一个是hexo deploy部署问题。 代码高亮失效如果大家用的是hexo-prism-plugin代码高亮插件，那就可能遇到这样的问题。该插件的作者在github issue上讨论过，几年前的事。 解决的办法是安装hexo-inject，进入到博客项目目录，命令行输入： 1npm i hexo-inject -s 同样在matery.css文件下查找body样式，如下： 123456body &#123; cursor: url(./cursor.ico),auto; background: linear-gradient(60deg, rgba(255, 165, 150, 0.5) 5%, rgba(0, 228, 255, 0.35) ); margin: 0; color: #7F95D1;&#125; 如果不想要图片去掉即可 hexo博客部署问题其实它是个github上传错误，上传项目到github报错：Permission to xxx/xxx.git denied to xxxxxxx.。出现这个问题是因为git权限问题，有两个或多个git账户,git退出后保留上次git 账户信息。 解决一：重新设置博客仓库账户为全局1git config --global user.name 博客本地用户名 解决二：输入github账户密码获取权限去提交1git push -u xxx master 公众号：菜鸡干Java","categories":[{"name":"网站运维","slug":"网站运维","permalink":"https://aachou.github.io/categories/%E7%BD%91%E7%AB%99%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"hexo-inject","slug":"hexo-inject","permalink":"https://aachou.github.io/tags/hexo-inject/"},{"name":"git","slug":"git","permalink":"https://aachou.github.io/tags/git/"}],"author":"沧海一粟"},{"title":"hexo-matery主题美化(四)","slug":"hexo-matery主题美化-四","date":"2020-08-19T00:05:52.000Z","updated":"2023-08-09T10:16:42.000Z","comments":false,"path":"2020/0819/","permalink":"https://aachou.github.io/2020/0819/","excerpt":"","text":"hexo-matery主题美化(四)目录： 前言 去掉banner的颜色动画 添加背景壁纸 修改滑动条 修改导航栏、页脚及文章卡片标签的颜色 修改目录样式 前言：这是最后一篇关于hexo-matery博客美化的文章了，大部分都是前端的东西，所以没啥好讲的，对我来说后端更侧重一点，这些天都没怎么写Java代码了。离前一篇博客美化文章已过去一个星期了，因为我回了趟老家，住了一个星期，心里感觉很复杂。我本身技术并不是很强，每天都要实实在在的学习知识，家里条件不好，以后的路真的难走！加油吧！ 一、去掉banner的颜色动画有的同学可能不喜欢banner的颜色遮罩，特别是在banner图片的颜色和动画颜色一样时，表现不出图片的美观。去掉后放一张高清小姐姐大图，博客访问量一下迅速爆炸！听我的准没错，那如何去掉这个烦人的彩色动画呢？跟着我：在theme主题目录下，找到matery.css文件,ctrl+F快捷键查找.bg-cover:after，注释掉即可。 1234/* .bg-cover:after &#123; -webkit-animation: rainbow 60s infinite; animation: rainbow 60s infinite;&#125; */ 二、添加背景壁纸同样在matery.css文件下查找body样式,修改如下： 1234567body &#123; /* background-color: #eaeaea; */ background: linear-gradient(60deg, rgba(255, 165, 150, 0.5) 5%, rgba(0, 228, 255, 0.35) ) 0% 0% / cover, url(&quot;https://x.png&quot;), url(&quot;https://x.jpg&quot;) 0px 0px; background-attachment: fixed; margin: 0; color: #7F95D1;&#125; 如果不想要图片，去掉即可，比如： 123456body &#123; cursor:url(/cursor.svg),auto; background: linear-gradient(60deg, rgba(255, 165, 150, 0.5) 5%, rgba(0, 228, 255, 0.35) ); margin: 0; color: #34495e;&#125; 三、修改滑动条（没试过，好像没用）说是说修改滑动条，但是不需要太麻烦，在matery.css中添加样式即可： 1234567891011121314/* 滚动条 */::-webkit-scrollbar-thumb &#123; background-color: #FF2A68; background-image: -webkit-linear-gradient(45deg,rgba(255,255,255,.4) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.4) 50%,rgba(255,255,255,.4) 75%,transparent 75%,transparent); border-radius: 3em;&#125;::-webkit-scrollbar-track &#123; background-color: #ffcacaff; border-radius: 3em;&#125;::-webkit-scrollbar &#123; width: 8px; height: 15px;&#125; 四、修改导航栏、页脚及文章卡片标签的颜色同样的操作，在matery.css中找到.bg-color,修改即可： 1234.bg-color &#123; background-image: linear-gradient(to right, #3f1b07 0%, #3f1b07 100%);/*咖啡色*/&#125; 五、修改目录样式（没试过）在themes\\Matery\\layout\\_partial\\post-detail-toc.ejs，在这里修改: 1234567.toc-widget &#123; width: 345px; padding-left: 20px; background-color: rgb(255, 255, 255,0.7); border-radius: 10px; box-shadow: 0 10px 35px 2px rgba(0, 0, 0, .15), 0 5px 15px rgba(0, 0, 0, .07), 0 2px 5px -5px rgba(0, 0, 0, .1) !important; &#125;","categories":[{"name":"网站运维","slug":"网站运维","permalink":"https://aachou.github.io/categories/%E7%BD%91%E7%AB%99%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"matery","slug":"matery","permalink":"https://aachou.github.io/tags/matery/"},{"name":"美化","slug":"美化","permalink":"https://aachou.github.io/tags/%E7%BE%8E%E5%8C%96/"}],"author":"沧海一粟"},{"title":"新sakura博客园皮肤配置,NewSakura","slug":"新sakura博客园皮肤配置-NewSakura","date":"2020-08-14T08:35:14.000Z","updated":"2023-08-09T10:15:49.000Z","comments":false,"path":"2020/0814/","permalink":"https://aachou.github.io/2020/0814/","excerpt":"","text":"CNblogs-Theme-NewSakura 基于Sakura美化方案改造的博客园样式：NewSakura 如使用了本样式，请给个Star。 项目结构1234567891011CNblogs-Theme-NewSakura|├─ CNblogs-Theme-NewSakura│ ├─ foot.html 页脚代码│ ├─ main.css 自定义css代码│ ├─ main.js 引用js│ └─ sidebar.html 侧边栏代码├─ README.md└─ img ├─ 效果1.JPG └─ 效果2.JPG 有js权限，期间将侧边栏、页脚和css代码粘贴进博客园设置内即可！代码文件内有相应注释，根据它修改即可。 功能简介依次分重点： 新增暗黑白昼模式，白天暗黑刺激 首页及随笔页头图随机切换 音乐播放器，使用Aplayer插件 看板娘，原先的主题已失效，现已修改 自动生成文章目录，基本功能 导航菜单子目录，照葫芦画瓢添加 图片灯箱、滚动进度条 文章打赏 鼠标点击粒子效果 其他网站链接，非必需 将首页底部不必要的滚动条去掉 修改了文章评论区的框框大小，原先的过大变形 暗黑白昼切换不影响评论区，暗黑字白，白昼字黑 修改了分类页面样式，为了在暗黑后看的清楚美观 注意：目前Sakura还不支持响应式，所以还需大家帮忙喽！ 主题预览 主题部署快速搭建出与本博客一样的样式， 请看下面这句说明，当然前提是得有js权限 部署和本博客一样的主题，请直接下载整个主题，对应的改下文件链接地址 ，把css、侧边栏、页脚代码粘贴的你的博客后台就行。为了个性化定制，如果你想个性化定制博客，请往下看基本部署。 基本部署 前提：已经开通js权限 设置皮肤选择自定义custom 引入样式把main.css中的代码粘贴到自定义css中，无需个性化操作 引入文件放在侧边栏html文件中，本人已为你添加。建议下载该文件并上传博客园，之后只需修改样式引入即可！ 1&lt;script src=&quot;https://blog-static.cnblogs.com/files/coderma/main.js&quot;&gt;&lt;/script&gt; 顶部菜单设置 将以下链接替换成自己随笔地址，以下代码在main.js中,建议打开该文件查看并修改 1$(&quot;#navList&quot;).append(&#x27;&lt;li&gt;&lt;a id=&quot;blog_nav_myyoulian&quot; class=&quot;menu&quot;href=&quot;https://www.cnblogs.com/coderma/p/1117239.html&quot;&gt;友链&lt;/a&gt;&lt;i&gt;&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;a id=&quot;blog_nav_myzanshang&quot; class=&quot;menu&quot; href=&quot;https://www.cnblogs.com/coderma/p/1133477.html&quot;&gt;赞赏&lt;/a&gt;&lt;i&gt;&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;a id=&quot;blog_nav_myguanyu&quot; class=&quot;menu&quot; href=&quot;&quot;&gt;关于&lt;/a&gt;&lt;/li&gt;&#x27;); 菜单icon设置 就是菜单前的小图标，感兴趣的可以去了解一下Font awesome 12345678910111213141516 //博客title//去掉rss替换成分类$(&#x27;#blog_nav_rss&#x27;).replaceWith(&#x27;&lt;a id=&quot;blog_nav_fenlei&quot; class=&quot;menu&quot; href=&quot;https://www.cnblogs.com/coderma/p/13458241.html&quot; target=&quot;_self&quot;&gt;分类&lt;/a&gt;&#x27;); //可替换以下链接$(&quot;#navList&quot;).append(&#x27;&lt;li&gt;&lt;a id=&quot;blog_nav_myyoulian&quot; class=&quot;menu&quot; href=&quot;https://www.cnblogs.com/coderma/p/13413494.html&quot; target=&quot;_self&quot;&gt;友链&lt;/a&gt;&lt;i&gt;&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;a id=&quot;blog_nav_myarchive&quot; class=&quot;menu&quot; href=&quot;https://www.cnblogs.com/coderma/p/13414527.html&quot; target=&quot;_self&quot;&gt;归档&lt;/a&gt;&lt;i&gt;&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;a id=&quot;blog_nav_myguanyu&quot; class=&quot;menu&quot; &gt;关于&lt;/a&gt;&lt;/li&gt;&#x27;);//添加标签图标$(&#x27;#blog_nav_sitehome&#x27;).prepend(&#x27;&lt;i class=&quot;fa fa-fort-awesome&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&#x27;); //博客园$(&#x27;#blog_nav_myhome&#x27;).prepend(&#x27;&lt;i class=&quot;fa fa-home&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&#x27;); //首页$(&#x27;#blog_nav_newpost&#x27;).prepend(&#x27;&lt;i class=&quot;fa fa-edit&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&#x27;); //新随笔$(&#x27;#blog_nav_contact&#x27;).prepend(&#x27;&lt;i class=&quot;fa fa-address-book-o&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&#x27;); //联系$(&#x27;#blog_nav_fenlei&#x27;).prepend(&#x27;&lt;i class=&quot;fa fa-filter&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&#x27;); //分类$(&#x27;#blog_nav_admin&#x27;).prepend(&#x27;&lt;i class=&quot;fa fa-cog&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&#x27;); //管理$(&#x27;#blog_nav_myyoulian&#x27;).prepend(&#x27;&lt;i class=&quot;fa fa-link&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&#x27;); //友链$(&#x27;#blog_nav_myarchive&#x27;).prepend(&#x27;&lt;i class=&quot;fa fa-archive&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&#x27;); //赞赏$(&#x27;#blog_nav_myguanyu&#x27;).prepend(&#x27;&lt;i class=&quot;fa fa-universal-access&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&#x27;);//关于//添加li内嵌ui 菜单子目录设置 菜单子目录，在关于菜单下添加了子目录,相应的样式可自行修改添加 12345 let guanyu = &#x27;&lt;ul class=&quot;sub-menu&quot;&gt;&#x27; + &#x27;&lt;li&gt;&lt;a href=&quot; &quot; target=&quot;_self&quot;&gt;&lt;i class=&quot;fa fa-user-o&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;博主&lt;/a&gt;&lt;/li&gt;&#x27; + //添加关于文章链接 &#x27;&lt;li&gt;&lt;a id=&quot;blog_nav_theme&quot; onclick=&quot;changeTheme();&quot; &gt;&lt;i class=&quot;iconfont icon-taohua&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; 主题&lt;/a&gt;&lt;/li&gt;&#x27; + //主题/暗黑白昼模式 &#x27;&lt;/ul&gt;&#x27;;$(&#x27;#blog_nav_myguanyu&#x27;).after(guanyu); 脚本设置 为了配置方便，我在侧边栏里设置了一些常用参数，可根据下表选择需要开启和配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 &lt;script type=&quot;text/javascript&quot;&gt; $.silence(&#123; profile: &#123; enable: true, avatar: &#x27;https://images.cnblogs.com/cnblogs_com/coderma/1820127/o_200803093536logo.png&#x27;, //头像，可修改 favicon: &#x27;&#x27;, notice: &#x27;个人博客地址：https://index.maliaoblog.cn/ 欢迎大家来踩&#x27; //通知，可修改 &#125;, catalog: &#123; enable: true, move: true, index: true, level1: &#x27;h2&#x27;, level2: &#x27;h3&#x27;, level3: &#x27;h4&#x27;, &#125;, signature: &#123; enable: true, home: &#x27;https://www.cnblogs.com/coderma/&#x27;, //主页链接，可修改 license: &#x27;CC BY 4.0&#x27;, link: &#x27;https://creativecommons.org/licenses/by/4.0&#x27; &#125;, sponsor: &#123; enable: true, paypal: null, wechat: &#x27;&#x27;, //赞助，可修改图片链接 alipay: &#x27;&#x27; &#125;, github: &#123; enable: false, color: &#x27;#fff&#x27;, fill: &#x27;#FF85B8&#x27;, link: &#x27;https://github.com/coderxm&#x27; //可修改 &#125;, topImg: &#123; homeTopImg: [ &quot;https://img2020.cnblogs.com/blog/2027366/202008/2027366-20200807133710823-1221571975.jpg&quot;, //主页顶部图片，可修改 ], notHomeTopImg: [ &quot;https://img2020.cnblogs.com/blog/2027366/202008/2027366-20200807132804040-1889645361.jpg&quot;, //可修改 ] &#125;, topInfo: &#123; title: &#x27;Hi,流浪舟&#x27;, //首页标题（可替换） text: &quot;No one choose this life for me But I don&#x27;t mind it&quot;, //首页横幅语句 github: &quot;https://github.com/coderxm/&quot;, //github(替换成相应链接) weibo: &quot;&quot;, telegram: &quot;&quot;, music: &quot;&quot;, twitter: &quot;&quot;, zhihu: &quot;&quot;, mail: &quot;&quot;, &#125; &#125;); &lt;/script&gt; 参数说明表： 模块 属性 说明 类型 默认值 profile（基础信息） enable 是否启用 Boolean true avatar 作者头像 String favicon 网站标题图标 String notice 公告 String 感谢使用该主题 authorName 作者姓名 String coderxm catalog（博文目录） enable 是否启用 Boolean false move 是否允许拖拽 Boolean true index 是否显示索引 Boolean true level1 一级标题 String h2 level2 二级标题 String h3 level3 三级标题 String h4 signature（博文签名） enable 是否启用 Boolean true home 作者主页 String https://www.cnblogs.com license 许可证名称 String CC BY 4.0 link 许可证链接 String https://creativecommons.org/licenses/by/4.0 sponsor（博文赞赏） enable 是否启用 Boolean false paypal PayPal 收款地址 String null alipay 支付宝收款二维码 String null wechat 微信收款二维码 String null github（GitHub Corners） enable 是否启用 Boolean false fill 背景填充色 String [Silence Theme Color] color 章鱼猫颜色 String #fff link Github 链接 String null topImg（头图） homeTopImg 首页头图 Array notHomeTopImg 文章和随笔页头图 Array topInfo(首页头图信息) titile 头部标题 String Hi, 流浪舟! text 横幅标题 String No one choose this life for me But I don’t mind it 配置完成后，记得点击「保存」按钮。 个性化定制新增暗黑白昼模式开始的时候是暗黑的，在关于下的子菜单栏内，点击主题可切换成白昼模式。 菜单新增分类、友链、博主、归档栏原理简单，只需先新建随笔即可，并替换链接，点击便可跳转到相应页面。关于分类，去掉了过去的RSS，换成博客园已有的分类，同样的方法，将所有分类链接收录到某一随笔中即可，随笔链接即是分类栏链接。博主一栏写你的信息，归档类似，我相信这样的问题难不倒有大智慧的你！ 首页及文章大图首页和随笔以及文章页的头图都是随机切换的，添加图片在侧边栏html配置中。这里类型为随笔的时候头部会显示标题、头像、作者、发布时间、阅读数，而类型为文章的时候只会显示标题，根据情况选择类型发布。请尽量选择像素1920*1080px的高清大图，这样的话首页图片会更适合。 随笔预览图 在写随笔或者文章的时候添加摘要图片和摘要文字，摘要文字一定要添加，如果不添加摘要图片会给一张默认图片。 回顶部钩子1234567891011121314//回到顶部特效 $(&#x27;body&#x27;).prepend(`&lt;a href=&quot;#&quot; class=&quot;cd-top faa-float animated cd-fade-out&quot; target=&quot;_self&quot;&gt;&lt;/a&gt;`); let $win = $(window); let oldScrollY = 0; $win.scroll(function () &#123; oldScrollY = this.scrollY; let height = window.innerHeight; let top = &#x27;-&#x27; + (900 - height + 80) + &#x27;px&#x27;; if (oldScrollY &gt; 0) &#123; $(&#x27;.cd-top&#x27;).css(&#x27;top&#x27;, top); &#125; else $(&#x27;.cd-top&#x27;).css(&#x27;top&#x27;, &#x27;-900px&#x27;); &#125; &#125;); 公告公告内容修改在侧边栏基础信息配置中，修改notice，代码中已有提示 看板娘我个人博客的看板娘是引用别人的，同一个，失效了会及时修复的！将以下代码添加到页脚，当然本人又已经为你添加好了，所以过程非常轻松！ 12&lt;script src=&quot;https://eqcn.ajz.miesnfu.com/wp-content/plugins/wp-3d-pony/live2dw/lib/L2Dwidget.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://common.cnblogs.com/scripts/jquery-2.2.0.min.js&quot;&gt;&lt;/script&gt; 音乐播放器相信看过我以前文章的同学对这个一定不会陌生，怎么获取id我也不在这里罗嗦了，可以去找我的文章，获取到id之后把下面的id替换掉就可以了！ 12345&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/aplayer@1.10.0/dist/APlayer.min.css&quot;&gt;&lt;script src=&quot;https://blog-static.cnblogs.com/files/zouwangblog/APlayer.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://unpkg.com/meting@1.2/dist/Meting.min.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;player&quot; class=&quot;aplayer aplayer-withlist aplayer-fixed&quot; data-id=&quot;7660234225&quot; data-server=&quot;tencent&quot; data-type=&quot;playlist&quot; data-order=&quot;random&quot; data-fixed=&quot;true&quot; data-listfolded=&quot;true&quot; data-theme=&quot;orangered&quot;&gt;&lt;/div&gt;&lt;!-- end --&gt; 博客logo左上角的logo，修改文字需要到main.js里找到以下代码，替换文字即可，如果不喜欢可以注掉,我也觉得没啥好看，main.js里我已经删了！ 123456var title = &#x27;&lt;div class=&quot;site-branding&quot;&gt;&#x27; + &#x27;&lt;span class=&quot;logolink moe-mashiro&quot;&gt;&#x27; + &#x27;&lt;ruby&gt;&lt;span class=&quot;sakuraso&quot;&gt;漂泊&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;的&lt;/span&gt;&lt;span class=&quot;shironeko&quot;&gt;流浪舟&lt;/span&gt;&#x27; + &#x27;&lt;rt class=&quot;chinese-font&quot;&gt;漂泊的流浪舟&lt;/rt&gt;&lt;/ruby&gt;&lt;/a&gt;&lt;/span&gt;&#x27; + &#x27;&lt;/div&gt;&#x27; $(&#x27;body&#x27;).prepend(title); 页面滚动进度条页面滚动的时候会在顶部出现一个橙色的进度条，修改颜色到页面css里，找到以下代码修改background 123456789.scrollCls &#123; position: fixed; top: 0; height: 3px; background: orange; transiton-property: width,background; transition-duration: 1s,1s; z-index: 99999;&#125; 首页个人信息 名称在侧边栏配置中修改topInfo里的title 座右铭（横幅标题）在侧边栏配置中修改topInfo里的text 其他网站链接(已注释，大都是推特等国外app，影响美观)在侧边栏配置中修改topInfo里对应的链接地址 写在最后最近在博客园和皮肤厮混，发现没几个满意的！这让我追求精致的心受到了打击，最开始用的是这个，后来换了，不过换之前改进了一些！最总发现移动端不行，所以干脆把项目弄到github上，让大家看看！我把这个美化分享了出去，以我目前的前端技术改造这么个样式也很费劲的，毕竟不是专业做前端的！这是我在博客园的一篇美化文章了，博客还是有很多改进的，希望采用这个样式的你能够多多支持，有什么问题都可以提交，我也会及时为大家解决! 项目地址GitHub地址 Gitee地址","categories":[{"name":"网站运维","slug":"网站运维","permalink":"https://aachou.github.io/categories/%E7%BD%91%E7%AB%99%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"sakura","slug":"sakura","permalink":"https://aachou.github.io/tags/sakura/"},{"name":"博客园","slug":"博客园","permalink":"https://aachou.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}],"author":"沧海一粟"},{"title":"hexo-matery主题美化(三)-音乐播放器","slug":"hexo-matery主题美化-三-音乐播放器","date":"2020-08-09T08:39:30.000Z","updated":"2023-08-09T10:21:28.000Z","comments":false,"path":"2020/0809/","permalink":"https://aachou.github.io/2020/0809/","excerpt":"","text":"hexo-matery主题美化(三)-音乐播放器配置音乐播放器要支持音乐播放，在主题的 _config.yml 配置文件中激活music配置即可： 123456789101112131415161718# Whether to display the musics.# 是否在首页显示音乐.music: enable: true title: 非吸底模式有效 show: 听听音乐 autoHide: true # hide automaticaly server: tencent #require music platform: netease, tencent, kugou, xiami, baidu type: playlist #require song, playlist, album, search, artist id: 7660234225 #require song id / playlist id / album id / search keyword fixed: true # 开启吸底模式 autoplay: false # 是否自动播放 theme: &#x27;blue&#x27; #歌词的颜色 loop: &#x27;all&#x27; # 音频循环播放, 可选值: &#x27;all&#x27;, &#x27;one&#x27;, &#x27;none&#x27; order: &#x27;random&#x27; # 音频循环顺序, 可选值: &#x27;list&#x27;, &#x27;random&#x27; preload: &#x27;auto&#x27; # 预加载，可选值: &#x27;none&#x27;, &#x27;metadata&#x27;, &#x27;auto&#x27; volume: 0.7 # 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效 listFolded: true # 列表默认折叠 server可选：netease（网易云音乐），tencent（QQ音乐），kugou（酷狗音乐），xiami（虾米音乐）， baidu（百度音乐）。 type可选：song（歌曲），playlist（歌单），album（专辑），search（搜索关键字），artist（歌手） id获取示例: 打开网易云音乐，选择喜欢的歌单，然后点击分享,生成插件外链 这就是歌单的id，文件里默认设置的歌单其实也还不错。如果以后继续添加歌曲，更新了歌单，我亲自试过，Aplayer插件也会更新，之前的16首现在加了三首有19首。看了一些人的文章，有的人说不会更新，不知道他有没有试过。对了，如果打开博客播放器插件加载不出来，可能是网速的原因，刷新一下就好，也有可能是没配置好，多看看文章就行。 参考资料：弗兰克的猫-hexo-matery主题配置 new落花-Aplayer插件","categories":[{"name":"网站运维","slug":"网站运维","permalink":"https://aachou.github.io/categories/%E7%BD%91%E7%AB%99%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"matery主题","slug":"matery主题","permalink":"https://aachou.github.io/tags/matery%E4%B8%BB%E9%A2%98/"},{"name":"音乐播放器","slug":"音乐播放器","permalink":"https://aachou.github.io/tags/%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/"}],"author":"沧海一粟"},{"title":"hexo-matery主题优化(二)","slug":"hexo-matery主题优化-二","date":"2020-08-06T04:11:00.000Z","updated":"2023-08-09T10:16:31.000Z","comments":false,"path":"2020/0806/","permalink":"https://aachou.github.io/2020/0806/","excerpt":"","text":"hexo-matery主题优化(二)目录： hexo搜索 hexo代码高亮 消除文章toc目录的那一竖杠杠 去掉友链下那不必要的一栏空白 最后 前段时间，我好像写过一篇文章讲hexo-matery主题的配置优化，隔了很久，自己都忘了，应该是第一次安装主题的时候。那现在有些一篇关于这样的文章帮助大家继续增强美化自己的博客，因为本人最近也在做这件事，搭博客已经3个月了，选了喜欢的主题，却还是有一点点不满意，虽然创建主题的都是大佬，但是也有瑕疵的地方。更头疼的是，到最后也没人来告诉我们怎么把我们的博客做的漂亮一点，还是要自己来亲手改改，直接弄成博客是自己亲生的一样！到时候也能吹吹！这次不介绍太多，怕一下弄不过来，主要就讲最近接触过的。 hexo搜索如果你已经做了这个搜索可以跳过，没有就一起干！过程非常可乐，呃，是非常简单！前提是使用的是hexo主题，配置了相应的环境。主题最开始弄下来是没有搜索插件的，需要下载，接下来你懂的，用npm包管理工具下载插件(如果不会用，可以搜索相应的文章看看，有需要会专门讲一下npm是何物，不会有同学还没安装好npm吧？不会吧！不会吧！)。进入到当前博客根目录下，在命令行里： 1npm i hexo-generator-search -s 就这样下好了！同时需要再当前根目录配置文件中添加配置： 1234#searchsearch: path: search.xml field: post hexo代码高亮还是不要用主题里的高亮了，enable就false掉，还是同样的“骚操作”，下一个代码高亮的插件，这里用hexo-prism-matery,相同的手法下载下来后，在根目录下的配置文件里添加： 12345prism_plugin: mode: &#x27;preprocess&#x27; # preprocess/realtime theme: &#x27;tomorrow&#x27; line_number: true #default false custom_css: # 消除文章toc目录的那一竖杠杠修改前是这样的： 如果你发现文章的toc目录有一条竖杠，不好看，那么就去掉。之前toc目录一直是这样的，我也不想要了。做博客开始的时候发现了，没太在意，终究是影响了美观。现在就要把目录弄得正常点。来到主题目录下，找到source目录，找到lib目录，里面也是一些css和js文件。其中找到tocbot文件夹，打开它的css文件，找到toc-link::before 1234567.toc-link::before&#123; background-color:#EEE;content:&#x27; &#x27;; display:inline-block;height:inherit;/*left:0;*/ margin-top:-1px; position:absolute; width:0px; /*之前是2px*/&#125; 里面可能很乱，就一两行代码，找到后将width值改成0就行了。另外解析的文章目录不完整可能是标题有些不支持： 1234567# 是否激活文章 TOC 功能，并配置TOC支持选中哪些标题类型，这是全局配置。# 可以在某篇文章的 Front-matter 中再加上`toc: false`，使该篇文章关闭TOC目录功能toc: enable: true heading: h2, h3, h4, h5, h6 #选中除h1以外的标题，之前没有h6 collapseDepth: 0 # 目录默认展开层级 showToggleBtn: true # 是否显示切换TOC目录展开收缩的按钮 去掉友链下那不必要的一栏空白修改前： 这个也简单，不必过于头疼！因为我已经改好了，直接卖就是了，白给不要钱！ 12345&lt;div class=&quot;card&quot;&gt; &lt;!--&lt;div class=&quot;card-content&quot;&gt; &lt;%- page.content %&gt; &lt;/div&gt;--&gt; &lt;/div&gt; 友链下的那栏不必要的空白着实凸显了它的不必要性，所以我们要去掉它。直接把它的代码给注释掉，找到layout文件夹下的friends.ejs文件。hexo引擎渲染该文件生成html文件，变成了友链页面，其中友链的那一片作为一个模块卡片，valine留言板及空白一栏也是，空白的就是什么也没有，很容易发现，注释即可。 最后以后还会继续更新站点，如果想看总体的效果就访问我的网站吧！最近的美化优化了很多，变化也很大！如果想深入了解就上公众号吧，小码之光，加群交流也行。后续会持续跟大家讲博客美化。","categories":[{"name":"网站运维","slug":"网站运维","permalink":"https://aachou.github.io/categories/%E7%BD%91%E7%AB%99%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"matery","slug":"matery","permalink":"https://aachou.github.io/tags/matery/"},{"name":"博客美化","slug":"博客美化","permalink":"https://aachou.github.io/tags/%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96/"}],"author":"沧海一粟"},{"title":"计算机网络-01网络模型","slug":"计算机网络-01网络模型","date":"2020-07-30T09:33:27.000Z","updated":"2023-08-09T10:16:02.000Z","comments":false,"path":"2020/0730/","permalink":"https://aachou.github.io/2020/0730/","excerpt":"","text":"计算机网络——01网络模型目录： 概念 分类 网络分层 TCP确认机制 连接与关闭 TCP&#x2F;UDP TCP&#x2F;ISO面向连接与无连接 总结 一、概念计算机网络是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统。 二、分类地理范围划分是一种大家都认可的通用网络划分标准。按这种标准可以把各种网络类型划分为局域网、城域网、广域网三种。最后讲一下互联网！ 局域网：（Local Area Network，LAN） 通常我们常见的“LAN”就是指局域网，这是我们最常见、应用最广的一种网络。所谓局域网，那就是在局部地区范围内的网络，它所覆盖的地区范围较小。局域网在计算机数量配置上没有太多的限制，少的可以只有两台，多的可达几百台。一般来说在企业局域网中，工作站的数量在几十到两百台次左右。在网络所涉及的地理距离上一般来说可以是几米至10公里以内。这种网络的特点就是：连接范围窄、用户数少、配置容易、连接速率高。目前局域网最快的速率要算现今的10G以太网了。IEEE的802标准委员会定义了多种主要的LAN网：以太网（Ethernet）、令牌环网（Token Ring）、光纤分布式接口网络（FDDI）、异步传输模式网（ATM）以及最新的无线局域网（WLAN）。 城域网：（Metropolitan Area Network，MAN） 这种网络一般来说是在一个城市，但不在同一地理小区范围内的计算机互联。这种网络的连接距离可以在10-100公里，它采用的是IEEE802.6标准。MAN与LAN相比扩展的距离更长，连接的计算机数量更多，在地理范围上可以说是LAN网络的延伸。在一个大型城市或都市地区，一个MAN网络通常连接着多个LAN网。如连接政府机构的LAN、医院的LAN、电信的LAN、公司企业的LAN等等。 广域网：(Wide Area Network，WAN） 这种网络也称为远程网，所覆盖的范围比城域网（MAN）更广，它一般是在不同城市之间的LAN或者MAN网络互联，地理范围可从几百公里到几千公里。因为距离较远，信息衰减比较严重，所以这种网络一般是要租用专线，通过IMP（接口信息处理）协议和线路连接起来，构成网状结构。这种城域网因为所连接的用户多，总出口带宽有限，所以用户的终端连接速率一般较低，通常为9.6Kbps-45Mbps 如：邮电部的CHINANET，CHINAPAC，和CHINADDN网。 互联网：（internet）指的是网络之间所串连成的最大网络，这些网络以一组通用的协议相连，形成逻辑上的大型国际网络，始于1969年美国的阿帕网。通常internet泛指互联网，而Internet则特指因特网(国际互联网)。因特网于1969年诞生于美国，最初名为“阿帕网”(ARPAnet）是一个军用研究系统 ，采用TCP&#x2F;IP协议，现在则已发展成为一个覆盖五大洲多个国家的开放型全球计算机网络系统。 三、网络分层为什么要分层？在计算机之间通信，主要是为了发送一些数据信息，一台计算机把数据发送出去，首先要让网络识别目的主机，能够找到它；明确目的主机是否连接网络；机子上的应用是否打开准备接收数据以及相应的异常处理。让我们去处理的话，会怎么解决这些问题呢？这里建立了两种模型： OSI七层模型：亦称OSI（Open System Interconnection）。参考模型是国际标准化组织（ISO）制定的一个用于计算机或通信系统间互联的标准体系，一般称为OSI参考模型或七层模型。 应用层:网络服务与最终用户的一个接口。 协议有：HTTP FTP SMTP SNMP DNS TELNET HTTPS POP3 DHCP 表示层:数据的表示、安全、压缩。 格式有，JPEG、ASCll，加密格式等 会话层:建立、管理、终止会话，对应主机进程，指本地主机与远程主机正在进行的会话 传输层:定义传输数据的协议端口号，以及流控和差错校验。 协议有：TCP UDP，数据包一旦离开网卡即进入网络传输层 网络层:网络层的主要工作是定义网络地址、区分网段、子网内MAC寻址、对于不同子网的数据包进行路由 协议有：ICMP（因特网控制报文协议） IP（IPV4 IPV6） ARP地址解析 Routing路由协议 数据链路层:建立逻辑连接、进行硬件地址寻址、差错校验等功能，将比特组合成字节进而组合成帧，用MAC地址访问介质，错误发现但不能纠正。 协议有：Ethernet PPP 物理层:建立、维护、断开物理连接，比特传输。 TCP&#x2F;IP模型：(Transmission Control Protocol &#x2F; Internet Protocol，传输控制协议&#x2F;网络互联协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF国际互联网工程任务组的RFC 793 定义。TCP&#x2F;IP模型合并了前三层为应用层，应用层定义了各种各样的协议来规范数据格式，常见的在HTTP的Header请求头中，分别定义了请求数据格式Accept和响应数据格式Content-Type，有了这个规范以后，当对方接收到请求以后就知道该用什么格式来解析，然后对请求进行处理。而链路层定义了主机的身份，即MAC地址，而网络层定义了IP地址，明确了主机所在的网段，有了这两个地址，数据包就从可以从一个主机发送到另一台主机。但实际上数据包是从一个主机的某个应用程序发出，然后由对方主机的应用程序接收。 因为数据链路层和物理层的内容相差不多，所以在TCP&#x2F;IP协议中它们被归并在网络接口层次里。只有四层体系结TCP&#x2F;IP协议，与有七层体系结构的OSI相比要简单了不少，也正是这样，TCP&#x2F;IP协议在实际的应用中效率更高，成本更低 。 ARP协议（网络层）： 即地址解析协议，是根据IP地址获取MAC地址的一个网络层协议。其工作原理如下：ARP首先会发起一个请求数据包，数据包的首部包含了目标主机的IP地址，然后这个数据包会在链路层进行再次包装，生成以太网数据包，最终由以太网广播给子网内的所有主机，每一台主机都会接收到这个数据包，并取出标头里的IP地址，然后和自己的IP地址进行比较，如果相同就返回自己的MAC地址，如果不同就丢弃该数据包。ARP接收返回消息，以此确定目标机的MAC地址；与此同时，ARP还会将返回的MAC地址与对应的IP地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。 路由协议： 首先通过IP协议来判断两台主机是否在同一个子网中，如果在同一个子网，就通过ARP协议查询对应的MAC地址，然后以广播的形式向该子网内的主机发送数据包；如果不在同一个子网，以太网会将该数据包转发给本子网的网关进行路由。网关是互联网上子网与子网之间的桥梁，所以网关会进行多次转发，最终将该数据包转发到目标IP所在的子网中，然后再通过ARP获取目标机MAC，最终也是通过广播形式将数据包发送给接收方。而完成这个路由协议的物理设备就是路由器，它会根据信道情况，选择并设定路由，以最佳路径来转发数据包。 四、TCP确认机制应用层向TCP层发送用于网间传输的、用8位字节表示的数据流，然后TCP把数据流分区成适当长度的报文段（通常受该计算机连接的网络的数据链路层的最大传输单元（MTU）的限制）。之后TCP把结果包传给IP层，由它来通过网络将包传送给接收端实体的TCP层。TCP为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的包发回一个相应的确认（ACK）；如果发送端实体在合理的往返时延（RTT）内未收到确认，那么对应的数据包就被假设为已丢失将会被进行重传。TCP用一个校验和函数来检验数据是否有错误；在发送和接收时都要计算校验和。 在数据正确性与合法性上，TCP用一个校验和函数来检验数据是否有错误，在发送和接收时都要计算校验和；同时可以使用MD5认证对数据进行加密。 在保证可靠性上，采用超时重传和捎带确认机制。 在流量控制上，采用滑动窗口协议，协议中规定，对于窗口内未经确认的分组需要重传。 在拥塞控制上，采用TCP拥塞控制算法（也称AIMD算法）。该算法主要包括四个主要部分： （1）慢启动 每当建立一个TCP连接时或一个TCP连接发生超时重传后，该连接便进入慢启动阶段。进入慢启动后，TCP实体将拥塞窗口的大小初始化为一个报文段，此后，每收到一个报文段的确认（ACK），拥塞窗口cwnd（congestion window）按指数增加。当cwnd值超过慢启动阐值或发生报文段丢失重传时，慢启动阶段结束。前者进入拥塞避免阶段，后者重新进入慢启动阶段。 （2）拥塞避免 在慢启阶段，当cwnd值超过慢启动阐值后，慢启动过程结束，TCP连接进入拥塞避免阶段。在拥塞避免阶段，每一次发送的cwnd个报文段被完全确认后，才将cwnd值加1。在此阶段，cwnd值线性增加。 （3）快速重传 快速重传是对超时重传的改进。当源端收到对同一个报文的三个重复确认时，就确定一个报文段已经丢失，因此立刻重传丢失的报文段，而不必等到重传定时器（RTO）超时。以此减少不必要的等待时间。 （4）快速恢复 快速恢复是对丢失恢复机制的改进。在快速重传之后，不经过慢启动过程而直接进入拥塞避免阶段。每当快速重传后，置sshtesrh&#x3D;cwnd&#x2F;2、ewnd&#x3D;ssthresh+3。此后，每收到一个重复确认，将cwnd值加1，直至收到对丢失报文段和其后若干报文段的累积确认后，置cwnd&#x3D;ssthesrh，进入拥塞避免阶段。 五、连接与关闭建立连接：TCP是因特网中的传输层协议，使用三次握手协议建立连接。当主动方发出SYN同步序列编号数据包连接请求后，等待对方回答 SYN+ACK，并最终对对方的 SYN 执行 ACK 确认。这种建立连接的方法可以防止产生错误的连接，TCP使用的流量控制协议是可变大小的滑动窗口协议。 TCP三次握手的过程如下： 客户端发送SYN（SEQ&#x3D;x序列号）报文给服务器端，进入SYN_SEND状态。 服务器端收到SYN报文，回应一个SYN （SEQ&#x3D;y）+ ACK（ACK&#x3D;x+1）报文，进入SYN_RECV状态。 客户端收到服务器端的SYN报文，回应一个ACK（ACK&#x3D;y+1）报文，进入已连接状态。 三次握手完成，TCP客户端和服务器端成功地建立连接，可以开始传输数据了。 连接终止:建立一个连接需要三次握手，而终止一个连接要经过四次挥手，这是由TCP的半关闭（half-close）造成的。如下图所示。 （1） 某个应用进程首先调用close，称该端执行“主动关闭”。该端的TCP于是发送一个FIN结束标志数据包，表示数据发送完毕。 （2） 接收到这个FIN的对端执行 “被动关闭”（passive close），这个FIN由TCP确认，发送ACK数据包。 注意：FIN的接收也作为一个文件结束符（end-of-file）传递给接收端应用进程，放在已排队等候该应用进程接收的任何其他数据之后，因此，FIN的接收意味着接收端应用进程在相应连接上再无额外数据可接收。 （3） 此时两者之间能够继续互相发送数据包，然而一段时间后，接收到这个文件结束符的应用进程将调用close关闭它的套接字，这导致它的TCP也发送一个FIN。 （4） 接收这个最终FIN的原发送端TCP（即执行主动关闭的那一端）ACK确认这个FIN。既然每个方向都需要一个FIN和一个ACK，因此通常需要4个分节。 注意：当一个进程无论自愿地（调用exit或从main函数返回）还是非自愿地（收到一个终止本进程的信号）终止时，所有打开的描述符都被关闭，这也导致仍然打开的任何TCP连接上也发出一个FIN。无论是客户还是服务器，任何一端都可以执行主动关闭。通常情况是，客户执行主动关闭，但是某些协议，例如，HTTP&#x2F;1.0却由服务器执行主动关闭。 六、TCP和UDP TCP 是面向连接的传输控制协议，而UDP 提供了无连接的数据报服务； TCP 具有确认机制，确保传输数据的正确性，很少出现丢失或乱序； UDP 在传输数据前不建立连接，不对数据报进行查改，无须等待对方的应答，会出现分组丢失、重复、乱序； UDP 具有较好的实时性，工作效率较 TCP 协议高； UDP 段结构比 TCP 的段结构简单，因此网络开销也小。 TCP 协议可以保证接收端毫无差错地接收到发送端发出的字节流，为应用程序提供可靠的通信服务。对可靠性要求高的通信系统往往使用 TCP 传输数据，比如 HTTP 运用 TCP 进行数据的传输。 七、TCP、ISO模型面向连接与无连接，面向连接可以分为三个阶段： 发出链接，建立连接 连接成功才开始传输 数据传输完毕，必须释放连接 无连接直接进行数据传输。TCP&#x2F;IP模型减少了会话层，表示层，可以变成经典5层网络模型，TCP&#x2F;IP协议能够迅速发展起来并成为事实上的标准，是它恰好适应了世界范围内数据通信的需要。它有以下特点： （1）协议标准是完全开放的，可以供用户免费使用不收费。（2）独立于网络硬件系统，可以运行在广域网，更适合于互联网。（3）网络地址IP统一分配，网络中每一设备和终端都具有一个唯一MAC物理地址。 对比：OSI层次间存在严格的调用关系，两个层通信必须通过下一层，不能越级，而TCP&#x2F;IP可以越过下一层，直接使用更低层次所提供的服务，因而减少了一些不必要的开销，提高了效率；TCP&#x2F;IP协议先出现，之后建立模型，而ISO&#x2F;OSI先建立模型，后有协议。 总结：讲了这么多，那么重点在哪呢？在目录三开始的网络分层到最后的TCP&#x2F;OSI模型对比，分层就记住TCP&#x2F;IP经典五层模型和各层的协议就行了，其实四层的更好记住，四层无非是应用的服务层、传输层(弄端口号的)、网络层(弄网络IP地址，获取MAC地址及路由寻找的)，接口层（偏向物理的，定义MAC地址，将比特组装成帧进行发送）。有个概念就行，另外TCP确认机制(拥塞控制机制)需要掌握，以及TCP连接和断开的握手机制，还有TCP\\UDP和TCP\\ISO模型对比都是重点，需要掌握。 模型对比，分层就记住TCP&#x2F;IP经典五层模型和各层的协议就行了，其实四层的更好记住，四层无非是应用的服务层、传输层(弄端口号的)、网络层(弄网络IP地址，获取MAC地址及路由寻找的)，接口层（偏向物理的，定义MAC地址，将比特组装成帧进行发送）。有个概念就行，另外TCP确认机制(拥塞控制机制)需要掌握，以及TCP连接和断开的握手机制，还有TCP\\UDP和TCP\\ISO模型对比都是重点，需要掌握。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://aachou.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://aachou.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"网络模型","slug":"网络模型","permalink":"https://aachou.github.io/tags/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/"},{"name":"TCP/IP","slug":"TCP-IP","permalink":"https://aachou.github.io/tags/TCP-IP/"}],"author":"沧海一粟"},{"title":"java中的内部类","slug":"java中的内部类","date":"2020-07-28T12:16:40.000Z","updated":"2023-08-09T10:21:23.000Z","comments":false,"path":"2020/0728/","permalink":"https://aachou.github.io/2020/0728/","excerpt":"java中的内部类一、内部类及访问特点1:内部类概述:把类定义在其他类的内部，这个类就被称为内部类。 理解：内部类不需要被其他外部类调用，所以内部类定义在外部类里边，连成一块","text":"java中的内部类一、内部类及访问特点1:内部类概述:把类定义在其他类的内部，这个类就被称为内部类。 理解：内部类不需要被其他外部类调用，所以内部类定义在外部类里边，连成一块2:内部类访问特点 a:内部类可以直接访问外部类的成员，包括私有。 b:外部类要访问内部类的成员，必须创建对象。 二、分类分类： 成员位置:在成员位置定义的类，被称为成员内部类（不在方法里），又分为静态和非静态 局部位置:在局部位置定义的类，被称为局部内部类（在方法里） 123456789class A&#123; class B &#123; //成员内部类 &#125; public void Show()&#123; class C&#123; //局部内部类 &#125; &#125;&#125; 三、成员内部类的修饰成员内部类： 可以被static修饰(外部类不行) 被四种访问权限修饰(public private default protected) 被abstract修饰，不能被实例化 私有成员内部类：对于成员内部类得私有使用，private，只能被当前类的方法访问，所以可以在外部类创建一个方法，创建内部类对象然后使用内部类方法。 四、静态和非静态成员内部类及使用静态和非静态有什么区别呢？非静态的成员内部类，如果使用比较缸的方式创建对象的话，也是new 类名()，确实会有误解，当然我们平时实例化的时候就是这么干的，不过这里不允许。 而静态成员内部类却依旧保持着原来的做法，像类访问成员一样，调用其构造器创建内部类对象，同样的如果采用非静态类的方法创建对象也不行，new ().new ()也会报错！所以各自只有唯一的方法来创建对象，以免混淆！ 12345678910111213141516171819202122232425262728293031323334353637public class LongTest &#123; public static void main(String[] args) &#123;//静态static内部类测试 Outer.Inner1 oi1 = new Outer.Inner1(); oi1.say(); //普通内部类测试：访问内部类成员需要创建对象 Outer.Inner2 oi2 = new Outer().new Inner2(); oi2.eat(); oi2.outereat(); &#125;&#125; //另一个外部类 class Outer&#123; int num = 10; public void eat() &#123; System.out.println(&quot;Outer吃饭啊_内部类调用外部内方法测试&quot;); &#125; //静态static内部类 static class Inner1&#123; public void say() &#123; System.out.println(&quot;说话啊_静态static内部类测试&quot;); &#125; &#125;//普通非静态成员内部类 class Inner2&#123; public void eat() &#123; System.out.println(&quot;Inner3吃饭啊_普通内部类测试&quot;); &#125; public void outereat() &#123; Outer.this.eat(); //内部类获取外部类成员，采用 外部类名.this.外部类成员 &#125; &#125; &#125; 非静态内部类获取外部类成员，采用 外部类名.this.外部类成员，外部类成员无论哪种修饰也能进行访问。但是静态的成员内部类就惨了点，它不能通过这种方法获取外部类成员。原因是Static在类加载时就已经存在了，但是对象是在创建时才在内存中生成，而this指代的是当前的对象。在静态类里使用this的话，那么this指向的是哪个对象呢？ 静态方法是存放在内存中的数据段里，this和super调用的是堆空间里的应用对象不能调用数据段区域里的数据，因此静态方法中不能用this和super关键字，否则会报错。那为什么要分静态和非静态呢？静态使用起来方便，符合原本的创建对象的逻辑：外部类.静态内部类； 五、局部内部类及使用定义在类的方法中的类，局部内部类在访问他所在的方法中的局部变量时必须用finnal修饰，因为方法结束后就弹栈了，变量也弹出去了，但是类还在堆里，还要用到变量，所以加个finnal将变量放到方法区常量池里（jdk1.8不需要加finnal了，默认添加finnal） 局部内部类：（在外部类的方法里创建内部类的对象，外部类方法才能调用内部类方法） 123456789101112131415161718public class Test &#123; public static void main(String[] args) &#123; Outer out = new Outer(); out.method(); &#125;&#125; //另一个类 class Outer&#123; public void method() &#123; //外部类方法 int num = 10; class Inner&#123; //内部类 public void print() &#123; System.out.println(num); &#125; &#125; //在外部类的方法里创建内部类的对象，外部类方法才能调用内部类方法 Inner i = new Inner(); i.print(); &#125;&#125; 匿名内部类：（特殊的局部内部类，也是局部内部类的一种，必须写在方法里，本质是一个继承了该类（一般是抽象类）或者实现了该接口的子类匿名对象） 1234567891011121314public class Test &#123; public static void main(String[] args) &#123; MyInterface1 myInterface1 = new MyInterface1()&#123; @Override public void show() &#123; System.out.println(&quot;你真秀！&quot;); &#125; &#125;; //注意这里的分号，new开始到这里是一个语句; myInterface1.show(); &#125;&#125; //接口interface MyInterface1&#123; void show();&#125; 注意这里虽然有一个名字myInterface1，但它是接口对象名，不是类名。其中你可以改写成： 123456new MyInterface1()&#123; @Override public void show() &#123; System.out.println(&quot;你真秀！&quot;); &#125; &#125;.show(); //注意这里的分号，new开始到这里是一个语句; 就啥名字也没有了！可能会有警告，不过没关系，照样跑！但如果你还学过lamda表达式的话就更好了： 1((MyInterface1) () -&gt; System.out.println(&quot;你真秀！&quot;)).show(); 分号就不容易漏了，一句话解决！你真秀！ 公众号：小码之光（文章全部首发）个人网站 流浪舟引导github coderxm","categories":[{"name":"java","slug":"java","permalink":"https://aachou.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://aachou.github.io/tags/java/"},{"name":"内部类","slug":"内部类","permalink":"https://aachou.github.io/tags/%E5%86%85%E9%83%A8%E7%B1%BB/"}],"author":"沧海一粟"},{"title":"基本数据结构介绍了解","slug":"基本数据结构介绍了解","date":"2020-07-25T03:43:44.000Z","updated":"2023-08-09T10:16:16.000Z","comments":false,"path":"2020/0725/","permalink":"https://aachou.github.io/2020/0725/","excerpt":"数据结构：反应数据之间的关系，物理或逻辑上的关系。 有两个角度看数据结构：逻辑结构和存储结构。逻辑结构是指数据之间的逻辑关系，有没有联系。而存储结构才是重点，数据怎么存？存成什么样？有顺序、链式、散列存储等，不过主要研究顺序和链式存储等方式，并对他们的运算进行了解。什么是顺序和链式？其实不难理解，就是容易忘(滑稽)！两者都要从逻辑和存储上看。","text":"数据结构：反应数据之间的关系，物理或逻辑上的关系。 有两个角度看数据结构：逻辑结构和存储结构。逻辑结构是指数据之间的逻辑关系，有没有联系。而存储结构才是重点，数据怎么存？存成什么样？有顺序、链式、散列存储等，不过主要研究顺序和链式存储等方式，并对他们的运算进行了解。什么是顺序和链式？其实不难理解，就是容易忘(滑稽)！两者都要从逻辑和存储上看。 顺序结构：逻辑上是连续的，即可以通过任意一节点元素找到该数据元素；存储上，就是物理地址是也是相邻的，连在一块。比如顺序表。 链式结构：逻辑上同理；但是物理存储地址却不是连在一块的。比如线性链表。 那不是还有线性和非线性结构吗？这个是什么角度呢？从数据的存储方式看，分为线性和非线性。线性结构或者叫线性表，指一个数据结构中的每个节点最多有一个前驱或后继(指向作用)，则为线性表，可以看作连续线状结构。非空的线性表有以下特征： 只有一个前节点，或头节点，无前件。 只有一个尾节点，无后件 其他节点只有一个前件和后件 那么常见的线性表有这么几个：数组、栈、队列、线性链表；而相应的非线性线性表有树、二叉树、图等等。 常见数据类型介绍：数组：这个好理解，连续的嘛！一维数组，可以通过下标找到你，而且定义一个数组，在内存上是相邻的一块，非常符合线性表的概念。 栈：特殊一点，操作都在一端进行，这端或这头叫栈顶top，相反，另一端则为栈底bottom。如果为空的话叫空栈，特点就是：FILO(first in ,last out) 先进后出，后进先出 插入删除操作都是在栈顶进行 不像线性表，插入删除操作不需要移动栈内其他元素 插入栈内为入栈或压栈，退出为出栈或退栈，读取就是将栈顶元素读取。 队列：一端插入，另一端退出删除。遵循FIFO，先进先出。那么哪里是头？哪里是尾呢？想象一下一列火车穿过隧道，火车头先进入隧道，然后尾部(Front)后进入。所以原理类似，在队尾(Rear)进行插入，在队头进行删除。 树：非线性的，是可以分支和划分层次的，由n(n&gt;&#x3D;0)个结点构成，树的结点应该满足以下条件： 只有一个没前驱的节点为根 其余结点可以构成子树 没有子结点的为叶子结点，其余为分支点或内点 一个结点的前件为父结点，后件为孩子结点，有子节点个数多少为度。结点中最大的度为树的度，最大的层数为树的深度。 二叉树：通常由一个结点和左右子树构成，每一个结点最多有两个子结点。 满二叉树：除最后一层外，每一层上的结点都有两个子节点，从第一层开始数到n层，第k层有2的n减一次方个结点，共2的n次方减一个结点。（国内是这么定义的，国外则不是，国外定义为一棵二叉树的结点要么是叶子结点，要么它有两个子结点） 国内：国外： 完全二叉树：一棵深度为k的有n个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为i（1≤i≤n）的结点与满二叉树中编号为i的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树。 也就是说，满二叉树一定是完全二叉树！ 完全二叉树的判定：C++代码实现(不是本人亲写)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std; template &lt;class T&gt;struct TreeNode&#123; T data; TreeNode&lt;T&gt; *left; TreeNode&lt;T&gt; *right; TreeNode(const T &amp;x) : data(x), left(NULL), right(NULL) &#123;&#125;&#125;;template &lt;class T&gt;bool IsComplete(TreeNode&lt;T&gt; *root)&#123; //1.树为空，返回错误 if (root == NULL) &#123; return false; &#125; //2.树不为空 queue&lt;TreeNode&lt;T&gt; *&gt; q; q.push(root); while (!q.empty())&#123; TreeNode&lt;T&gt; *top = q.front(); //2.1如果该节点两个孩子都有，则直接pop if (top-&gt;left &amp;&amp; top-&gt;right) &#123; q.pop(); q.push(top-&gt;left); q.push(top-&gt;right); &#125; //2.2如果该节点左孩子为空，右孩子不为空，则一定不是完全二叉树 if (top-&gt;left == NULL &amp;&amp; top-&gt;right &#123; return false; &#125; //2.3如果该节点左孩子不为空，右孩子为空或者该节点为叶子节点，则该节点之后的所有结点都是叶子节点 if ((top-&gt;left &amp;&amp; top-&gt;right == NULL) || (top-&gt;left == NULL &amp;&amp; top-&gt;right == NULL)) &#123; if (NULL != top-&gt;left &amp;&amp; NULL == top-&gt;right) &#123; q.push(top-&gt;left); &#125; q.pop(); //则该节点之后的所有结点都是叶子节点 while (!q.empty()) &#123; top = q.front(); if (top-&gt;left == NULL &amp;&amp; top-&gt;right == NULL) &#123; q.pop(); &#125; else &#123; return false; &#125; &#125; return true; &#125; &#125; return true;&#125; //满二叉树 // 1 // 2 3 // 4 5 6 7void test1()&#123; TreeNode&lt;int&gt; *node1 = new TreeNode&lt;int&gt;(1); TreeNode&lt;int&gt; *node2 = new TreeNode&lt;int&gt;(2); TreeNode&lt;int&gt; *node3 = new TreeNode&lt;int&gt;(3); TreeNode&lt;int&gt; *node4 = new TreeNode&lt;int&gt;(4); TreeNode&lt;int&gt; *node5 = new TreeNode&lt;int&gt;(5); TreeNode&lt;int&gt; *node6 = new TreeNode&lt;int&gt;(6); TreeNode&lt;int&gt; *node7 = new TreeNode&lt;int&gt;(7); node1-&gt;left = node2; node1-&gt;right = node3; node2-&gt;left = node4; node2-&gt;right = node5; node3-&gt;left = node6; node3-&gt;right = node7; cout &lt;&lt; IsComplete&lt;int&gt;(node1) &lt;&lt; endl;&#125; //二叉树为空void test2()&#123; cout &lt;&lt; IsComplete&lt;int&gt;(NULL) &lt;&lt; endl;&#125;//3.二叉树不为空，也不是满二叉树，遇到一个结点左孩子为空，右孩子不为空void test3()&#123; // 1 // 2 3 // 4 5 7 TreeNode&lt;int&gt; *node1 = new TreeNode&lt;int&gt;(1); TreeNode&lt;int&gt; *node2 = new TreeNode&lt;int&gt;(2); TreeNode&lt;int&gt; *node3 = new TreeNode&lt;int&gt;(3); TreeNode&lt;int&gt; *node4 = new TreeNode&lt;int&gt;(4); TreeNode&lt;int&gt; *node5 = new TreeNode&lt;int&gt;(5); TreeNode&lt;int&gt; *node7 = new TreeNode&lt;int&gt;(7); node1-&gt;left = node2; node1-&gt;right = node3; node2-&gt;left = node4; node2-&gt;right = node5; node3-&gt;right = node7; cout &lt;&lt; IsComplete&lt;int&gt;(node1) &lt;&lt; endl;&#125; //4.二叉树不为空，也不是满二叉树，遇到叶子节点,则该叶子节点之后的所有结点都为叶子节点void test4()&#123; // 1 // 2 3 // 4 5 TreeNode&lt;int&gt; *node1 = new TreeNode&lt;int&gt;(1); TreeNode&lt;int&gt; *node2 = new TreeNode&lt;int&gt;(2); TreeNode&lt;int&gt; *node3 = new TreeNode&lt;int&gt;(3); TreeNode&lt;int&gt; *node4 = new TreeNode&lt;int&gt;(4); TreeNode&lt;int&gt; *node5 = new TreeNode&lt;int&gt;(5); node1-&gt;left = node2; node1-&gt;right = node3; node2-&gt;left = node4; node2-&gt;right = node5; cout &lt;&lt; IsComplete&lt;int&gt;(node1) &lt;&lt; endl;&#125;//4.二叉树不为空，也不是满二叉树，遇到左孩子不为空，右孩子为空的结点，则该节点之后的所有结点都为叶子节点void test5()&#123; // 1 // 2 3 // 4 5 6 TreeNode&lt;int&gt; *node1 = new TreeNode&lt;int&gt;(1); TreeNode&lt;int&gt; *node2 = new TreeNode&lt;int&gt;(2); TreeNode&lt;int&gt; *node3 = new TreeNode&lt;int&gt;(3); TreeNode&lt;int&gt; *node4 = new TreeNode&lt;int&gt;(4); TreeNode&lt;int&gt; *node5 = new TreeNode&lt;int&gt;(5); TreeNode&lt;int&gt; *node6 = new TreeNode&lt;int&gt;(6); node1-&gt;left = node2; node1-&gt;right = node3; node2-&gt;left = node4; node2-&gt;right = node5; node3-&gt;left = node6; cout &lt;&lt; IsComplete&lt;int&gt;(node1) &lt;&lt; endl;&#125;int main()&#123; test1(); /*test2();*/ /*test3();*/ /*test4();*/ /*test5();*/ return 0;&#125; 源码连接：https://blog.csdn.net/gogogo_sky/article/details/76223384 二叉树通常用链式存储，每一个元素则可以有两个后件，分别可以指向左右子结点，其链式结构又叫二叉链表。 二叉树遍历：二叉树遍历要求不能重复访问结点，常用的有前序遍历、中序遍历、后序遍历。 前序遍历Data Left Right(DLR)：先访问根节点，然后遍历左子树，最后遍历右子树 中序遍历Left Data Right(LDR)：先遍历左子树，访问根节点，最后遍历右子树 后序遍历Left Right Data(LRD)：先遍历左子树，后遍历右子树，最后访问根节点 相应的文章请到博客园二叉树","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://aachou.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://aachou.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"栈","slug":"栈","permalink":"https://aachou.github.io/tags/%E6%A0%88/"},{"name":"队列","slug":"队列","permalink":"https://aachou.github.io/tags/%E9%98%9F%E5%88%97/"}],"author":"沧海一粟"},{"title":"opera、google、firefox浏览器的选择","slug":"opera、google、firefox浏览器的选择","date":"2020-07-19T10:09:51.000Z","updated":"2023-08-09T10:16:25.000Z","comments":false,"path":"2020/0719/","permalink":"https://aachou.github.io/2020/0719/","excerpt":"首先介绍：先介绍本人用的最多的浏览器：火狐 Mozilla Firefox，中文俗称“火狐”，是一个自由及开放源代码的浏览器，使用Gecko排版引擎，支持多种操作系统，如Windows、Mac OS及GNU&#x2F;Linux等。该浏览器提供了两种版本，普通版和ESR延长支持版，ESR版本是 Mozilla 专门为那些无法或不愿每隔几周就升级一次的企业打造。Firefox ESR 版的升级周期为 12 个月，而普通 Firefox 的升级周期为 4 周。由于该浏览器开放了源代码，因此还有一些第三方编译版供使用，如pcxFirefox、苍月浏览器、tete009等。","text":"首先介绍：先介绍本人用的最多的浏览器：火狐 Mozilla Firefox，中文俗称“火狐”，是一个自由及开放源代码的浏览器，使用Gecko排版引擎，支持多种操作系统，如Windows、Mac OS及GNU&#x2F;Linux等。该浏览器提供了两种版本，普通版和ESR延长支持版，ESR版本是 Mozilla 专门为那些无法或不愿每隔几周就升级一次的企业打造。Firefox ESR 版的升级周期为 12 个月，而普通 Firefox 的升级周期为 4 周。由于该浏览器开放了源代码，因此还有一些第三方编译版供使用，如pcxFirefox、苍月浏览器、tete009等。 简洁！使用火狐后，弹窗广告没了，乱七八糟的推送消失了，什么贪玩蓝月和黑网站链接都跟我拜拜了！使用起来还是非常舒适的，而且可以设置保护级别，拦截跟踪，加强反网络监视等等，尊重个人隐私，一些无证书认证的网址是有警告阻止页面的拦截的，很安全！当然不是说绝对的安全，有些墙缝里的黑角落还是有不好的网址的，首先体现在使用了百度搜索引擎之后，就有这个现象，不难看出某度引擎的强大之处。真是什么都能搜过来！ 接下来介绍google：一款在中国爆胎的搜索引擎和它的chrome浏览器为什么会爆胎呢？在google chrome里搜索几乎等于在网址栏里搜索，所以只是输入关键字是不能搜索的，除非换成其他搜索引擎，比如必应或某度。一般在里面搜索关键字后往往得到如下回应： 谷歌公司（Google Inc.）成立于1998年9月4日，由拉里·佩奇和谢尔盖·布林共同创建，被认为是全球最大的搜索引擎公司。 2010年3月23日，谷歌高级副总裁、首席法律官大卫·德拉蒙德公开发表声明，宣布谷歌关闭在中国大陆市场搜索服务，并将搜索服务由中国内地转至香港。随之，某度当之无愧完全成为第一大搜索引擎公司。 内核是谷歌自己开发的chrome V8引擎，双内核，不过是谷歌自己用c++研发的，打开网页确实快，但是耗CPU，某种程度上是依托硬件来加速页面的渲染。就chrome的应用文件占500多M，耗内存不是太明显，和火狐差不多。 不过耗CPU的问题，这里顺便就解决一下，在google的设置里下拉，找到高级，打开找到硬件加速关闭即可。 应该就老实了吧！记得别加载太多动态页面就行了，很耗CPU的。 其次是用的少的：opera浏览器Opera(奥普拉)浏览器，是一款挪威Opera Software ASA公司制作的支持多页面标签式浏览的网络浏览器，是跨平台浏览器可以在Windows、Mac和Linux三个操作系统平台上运行，创始人谭永文创始于1995年4月，中文名就这样。 Presto是由Opera Software开发的浏览器排版引擎，Opera 7.0及以上使用。有拦截、标签式浏览、快速拨号(快速拨号就是可以帮助用户将自己最常访问的多个网站，依次设入“拨号面板”中，而这些网站是以缩略图形式展现出来直观明了。然后，每次启动Opera时，便可以通过这个面板，快速打开相应的网站)等待一系列功能。VPN应该也行吧，没用过该功能！ 相比国内某361、222、23957乱七八槽的浏览器，奥普拉干净了不少！也算是老浏览器了，不过国内知名度并不高。有许多特性是opera首创的！同样的跨平台，同样有手机浏览器应用，支持主题更换(暗黑模式)，支持许多扩展功能。不过占内存比较大一点！多了几百M。不过2016年，挪威浏览器厂商 Opera发布公告，宣布了确定被 360 和昆仑万维收购。出价 105 亿挪威克朗（约合 81 亿人民币）收购的，所以，你懂的！ 浏览器与搜索引擎的搭配浏览器是浏览器，搜索引擎是搜索引擎，两个是不一样的，一般浏览器都会内置几种搜索引擎供选择，包括Google chrome。 如果不使用google搜索引擎，就享受不到它的快速，但是国内有没有服务。百度又是国内最大的搜索引擎，搜到的结果是一大堆没用的。比如下图： 还有右边的百度热搜，无尽广告等等！另外其他的国外引擎就不行了，要么是进不来国内，要么是搜索结果偏差！这里建议使用微软的必应Bing搜索，虽然没什么花里胡哨的东西，没有热搜榜，但绝对是搜得到匹配的东西！有搜索级别限制，在国内按照相关的规定已默认设置为严格搜索，不能更改了，即使有黑网站链接，但是会拦截过滤掉，也就是说这样的网址是打不开的，环境还是相当好的，墙裂推荐，匹配相关性杠杠的！ 作为一种在线搜索引擎，必应的主要目标是将互联网上相关性最强的搜索结果呈现给用户，从而让用户轻松访问互联网发布者发布的高质量内容。为此，必应会自动抓取互联网内容，为新页面和更新页面（或 URL）建立索引，以便在用户发起搜索或执行操作时显示一组相关的搜索结果。这些页面的内容可能会引用或含有各种在线资源和内容，包括网站、图像、视频、文档以及其他项目。搜索结果是使用计算机算法生成的，即由算法将您输入的搜索词与我们索引中的结果加以匹配，然后据此生成搜索结果。通常情况下，我们尝试尽量全面且有帮助地提供一批显示的搜索结果。我们会设计并不断改进我们的算法，确保提供最相关、最有用的结果。 作为一项以算法驱动的服务，必应不会控制编入索引的网站的运营或设计，也不会控制这些网站发布的内容。只要这些网站继续在网页上以及向爬网程序提供信息，通常就可以通过必应或其他搜索引擎获得这些信息。所以还等什么，用起来！","categories":[{"name":"碎碎念","slug":"碎碎念","permalink":"https://aachou.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"https://aachou.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"搜索引擎","slug":"搜索引擎","permalink":"https://aachou.github.io/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"}],"author":"沧海一粟"},{"title":"互质环与最小公倍数的几种求法","slug":"互质环与最小公倍数的几种求法","date":"2020-07-09T14:30:14.000Z","updated":"2023-08-09T10:21:06.000Z","comments":false,"path":"2020/0709/","permalink":"https://aachou.github.io/2020/0709/","excerpt":"互质环(序列)与最小公倍数的几种求法题目一：互质环现在我们要把1…n这n个数字首尾连接组成一个环，使得相邻元素互质的对数尽可能多，请输出最大对数.","text":"互质环(序列)与最小公倍数的几种求法题目一：互质环现在我们要把1…n这n个数字首尾连接组成一个环，使得相邻元素互质的对数尽可能多，请输出最大对数. 输入描述:1一行一个整数n(1≤ n≤ 1000)。 输出描述:1一行一个整数表示答案。 输入：14 输出：14 例：3 2 1 4 很显然，又是个把做题的的同学(小白)弄得晕头的题，实质上她还是个数学题，就看你数学学的好不好了，呵呵！既然相邻的两个数要互质(除了公因子1外没有其他公因数)，那从小到大顺序排序怎么样！好，试一下：1 2 3 4，也是两两互质，对数为4。是不是巧合呢？大家都知道相邻两数(整数)互质，那么怎么说明是确实是一定互质呢? 证明：转化一下，相邻两数：n-1, n(n&gt;1)，我们用反证法证明一下。 123预设结论：这两数不互质，即有除1以外的公因数k，n-1=x·k，n=y·k；那么有n-(n-1)=(y-x)k=1，k=1/(y-x)；y,x,k都是整数，k&gt;1,则1&gt;y-x，不符合！所以相邻两数互质！证明就完了。 所以结论就是输入几个数就输出几个数，就能构造互质环(互质对数最多的，两两互质)。 题目二：最小公倍数有人说求最小公倍数不很简单吗？我想说的是，你是用那种方法求得，而且算法复杂度小，效率高吗？现在我们就现场讨论一波！ 最小公倍数&#x3D;两整数的乘积÷最大公约数 。 所以该问题可以转化为求最大公约数。而最大公约数有这几种求法： 辗转相除法 :1.a%b得余数c 2.如果c &#x3D; 0,则b为最大公约数 3.如果c不等于0,则a &#x3D; b,b &#x3D; c继续执行步骤1。 12345678910111213141516171819#include&lt;iostream&gt;using namespace std;long long lcm(long long x, long long y)&#123; long long maxs = max(x,y); long long mins = min(x,y); long long t = maxs % mins; while(t != 0)&#123; maxs = mins; mins = t; t = maxs % mins; &#125; return x * y/mins;&#125;int main()&#123; long long x, y; //x,y很大 cin &gt;&gt; x &gt;&gt; y; cout&lt;&lt;lcm(x,y)&lt;&lt;endl; return 0;&#125; 最优算法，t最快接近最大公约数，因为是进行求模运算，所以比相减来得更快。T(n)应该是接近常数级，S(n)的话，由于lcm函数中进行了maxs,mins赋值，空间复杂度降低，和相减法差不多。 2 .相减法:两数之差与最大公约数成倍数关系。 12341.若a&gt;b，则a=a-b2.若a &lt; b，则b=b-a3. 若a=b，则a（或b）即为两数的最大公约数4. 若a≠b，则再回去执行1 1234567891011121314#include&lt;stdio.h&gt;int main ( ) /* 相减法求最大公约数 */&#123; int m, n, a, b, c; scanf (&quot;%d,%d&quot;, &amp;a, &amp;b); m=a; n=b; /* a, b不相等，大数减小数，直到相等为止。*/ while ( a!=b) &#123; if (a&gt;b) a=a-b; else b=b-a; &#125; printf(&quot;The largest common divisor:%d\\n&quot;, a); //最大公约数 printf(&quot;The least common multiple:%d\\n&quot;, m*n/a); //最小公倍数&#125; T(n)与第一种相比，当两个数比较大时，而且仅相差较小的数，循环需要a&#x3D;b相等才结束，所以T(n)这时会比较大。 3.枚举法： 已知1是一个公约数，但是1不是最大公约数，所以可以检测K&#x3D;2,3,4…..是否为x和y的公约数，直到k大于x或者y，将公约数存储在gcd的变量中,gcd初值设为1 12345int gcd = 1;for(int k = 2;k &lt;= x&amp;&amp;k &lt;= y;k++)&#123; if(x % k == 0&amp;&amp; y % k == 0) gcd = k;&#125; 当问题规模很大时，这个算法最不好，还是从小到大枚举，T(n)就很大了，k需要不断被自加1赋值，还要判断取模等等，循环次数过多。 今天的算法分享就完了，任务结束，别忘了点赞！hh！","categories":[{"name":"算法","slug":"算法","permalink":"https://aachou.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"互质","slug":"互质","permalink":"https://aachou.github.io/tags/%E4%BA%92%E8%B4%A8/"},{"name":"最小公倍数","slug":"最小公倍数","permalink":"https://aachou.github.io/tags/%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/"}],"author":"沧海一粟"},{"title":"年轻母牛的故事","slug":"年轻母牛的故事","date":"2020-07-08T14:29:13.000Z","updated":"2023-08-09T10:21:14.000Z","comments":false,"path":"2020/0708/","permalink":"https://aachou.github.io/2020/0708/","excerpt":"年轻母牛的故事题目是这样的：有一头母牛，它每年年初生一头小母牛。每头小母牛从第四个年头开始，每年年初也生一头小母牛。请编程实现在第n年的时候，共有多少头母牛？","text":"年轻母牛的故事题目是这样的：有一头母牛，它每年年初生一头小母牛。每头小母牛从第四个年头开始，每年年初也生一头小母牛。请编程实现在第n年的时候，共有多少头母牛？ 输入​ 输入数据由多个测试实例组成，每个测试实例占一行，包括一个整数n(0&lt;n&lt;55)，n的含义如题目中描述。 n&#x3D;0表示输入数据的结束，不做处理。 输出​ 对于每个测试实例，输出在第n年的时候母牛的数量。 每个输出占一行。 题目非常简洁，不知道是不是歪果仁想的题，我猜它的英文版是这样的： There is a cow, which gives birth to a heifer at the beginning of each year. Each heifer starts from the fourth year, and a heifer is also born at the beginning of each year. Please program how many cows are there in the nth year? 母牛特别能生，4年就发育成熟，就能生！问第几年有多少头母牛？哎呀，对于一个刚入门的新手来说，要想解决这个题，确实很费劲了(很烧脑)！只能感叹：这公牛的后宫不久就壮大了！牛批！而老手一眼看穿规律，就有了思路。那么老手是怎么看穿的呢？ 从数学角度看，这个母牛数目增长还是有一定的规律的，所以我们需要把每一年的母牛的数目清点一下，这个时候，数学基础就暴露出来了，第几年多少头牛都点不清，这还是小学问题，就是个点数题！注意题目描述！ 第一年：1头 第二年：2头 第三年：3头 第四年：4头 第五年：6头 第六年：9头 OK，我相信你数学非常好，很快就能发现规律。归结为一个数学题：设第n年的母牛头数为a[n]，则可以得出一个·递推公式： ​ a[n] &#x3D; a[n-1] + a[n-3]； 可以验证一波，没问题了就可以撸代码了，这里提供了java和c++版的代码题解，如果测试出现翻车概不负责！请注意！ Java版(我写的)： 1234567891011121314151617181920212223import java.util.Scanner;public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int[] a = new int[60]; a[0] = 0; a[1] = 1; a[2] = 2; a[3] = 3; a[4] = 4; for(int i=5;i&lt;=55;i++)&#123; a[i] = a[i-3] + a[i-1]; //递推填充数组 &#125; while (scanner.hasNextInt()) &#123; //等待输入 int num = scanner.nextInt(); if(num==0)&#123; //判断是否为0 break; &#125; System.out.println(a[num]); &#125; &#125;&#125; c++版： 123456789101112131415161718#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int main()&#123; int t , a[60]; a[1] = 1 ; a[2] = 2; a[3] = 3; a[4] = 4; for(int i = 5 ; i &lt; 60 ; i ++) &#123; a[i] = a[i-1] + a[i-3]; &#125; while(~scanf(&quot;%d&quot;,&amp;t) &amp;&amp; t) cout&lt;&lt;a[t]&lt;&lt;endl; return 0 ;&#125; hh,如果真有问题公众号交流，加群也行！以学习为首要！ 总结：对比两个代码版本，其实也没差多少，核心代码几乎相同，在算法上完全是一模一样！所以说算法在任何情况下都是通用的，每一种算法都可以解答一种题目，很有逻辑性。另外还涉及到数学的思想，有些特别简单，比如这个数学递推公式，这就结合数学来解算法题了！遇到这样的题目算是很有趣了，一般都有规律可循，只不过需要花点时间。OK，我是小码，一个会发光的准程序员！下期再见！","categories":[{"name":"算法","slug":"算法","permalink":"https://aachou.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://aachou.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"递推","slug":"递推","permalink":"https://aachou.github.io/tags/%E9%80%92%E6%8E%A8/"}],"author":"沧海一粟"},{"title":"算法的复杂度","slug":"算法的复杂度","date":"2020-07-05T01:39:57.000Z","updated":"2023-08-09T10:20:59.000Z","comments":false,"path":"2020/0705/","permalink":"https://aachou.github.io/2020/0705/","excerpt":"算法的复杂度 前言：本人并非所谓的大佬，蒟蒻一枚，写文章的目的主要就是这么几个。一个是为了总结昨天学习的知识，巩固于心；二是将所学的整理起来，也方便以后备用查阅；第三个是可以给其他的有需要的人看，也可以一起学习进步，有必要还可以提建议！总之比没写强吧！缸巴咧！","text":"算法的复杂度 前言：本人并非所谓的大佬，蒟蒻一枚，写文章的目的主要就是这么几个。一个是为了总结昨天学习的知识，巩固于心；二是将所学的整理起来，也方便以后备用查阅；第三个是可以给其他的有需要的人看，也可以一起学习进步，有必要还可以提建议！总之比没写强吧！缸巴咧！ 评判一个程序的好坏通常有几个标准，按照程序的运行效率和代码的可读性以及代码的美观性几个方面看，而最主要的方面不过效率和可读性。可读性没什么好说了，作为团队中的那一个蒟蒻，当然没啥高深的算法描述了。最后就看效率了，效率上可分为运行时间和所需空间大小两个方面入手，数据结构上可专业的称为算法的时间复杂度和空间复杂度。接下来就进入重点了，如何评测一个程序的时间和空间复杂度？ 时间复杂度这里又引入一个专业词：时间开销T，通俗点讲就是所花的时间；问题规模n，可以看作是代码基本语句的执行数量(可以被重复执行)。很显然，时间开销和问题规模n有关，记作T(n)。 12(1) T(n) = 3n + 3 -&gt; o(f(n)) = n ，[f(n)的高阶无穷小，即n趋于无穷是等于它](2) T(n) = n^3 + n +9990 -&gt; o(f(n)) = n^3 [同理趋于无穷接近] 上述式子，省略了常数，那意味着当问题规模很大时，只需要计算一些循环的基本语句的执行次数就行了。 加法当(1)与(2)式相加时，效果还是一样，求出其高阶无穷小，简单方法就是去掉低阶项，保留高阶项。 乘法既然都相乘了，就不好意思去掉其中任意一个了，所以吧两个高阶无穷小相乘即可。 例123456789void test(int k[],int n)&#123; //n为数组长度 printf(&quot;I am Tiga\\n&quot;); for(int i=0;i&lt;n;i++)&#123; if(k[i]==n)&#123; printf(&quot;I am light %d\\n&quot;,n); break; &#125; &#125;&#125; 就源码分析来看，入口的参数有两个，一个数组k[ ]，一个整数n。而这个函数的作用在于判断数组k[ ]中是否有整数n,如果有则输出并结束。然而它的时间复杂度不是唯一确定的，需要分情况。最好情况是，数组第一个就是n，那很快就结束了，执行基本语句量为常数，记为T(n) &#x3D; o(1);最坏情况是，需要找到最后一个n，根据上面的结论可得出，T(n) &#x3D; o(n)，进而可以求平均时间复杂度。 空间复杂度空间复杂度就相对理解起来更容易些，因为空间复杂度很少受问题规模的影响。 123456void test(int n)&#123; int k = 3; if(k==n)&#123; printf(&quot;Yes,Thanks!\\n&quot;); &#125;&#125; 上述代码几乎可以算出所需内存空间大小，如果int整形为4个字节，那么总共需要8个字节，则可以表达为S(n) &#x3D;o(1)，即常数级大小，那么这样典型的不受问题规模影响的空间复杂度情况就称作算法原地工作。如果受问题规模影响也能举出例子： 12345void test(int n)&#123; int k[n]; k[0] = 1; printf(&quot;Yes,Thanks %d!\\n&quot;,k[0]);&#125; 这个例子就简单又生动了，问题规模影响了空间复杂度，使它不唯一，则可以表示为S(n)&#x3D; o(n)。 总结：算法复杂度这两个方面就写完了，其实也并不复杂，复杂的还在后面。至少了解了一下算法好坏的判断标准，有助于以后写出更好的程序：执行时间少，占用空间小，效率高，美观，可读性好的程序！ 一起学习，一起成长，欢迎关注本人公众号小码之光，一个会发光的准程序员！ github","categories":[{"name":"算法","slug":"算法","permalink":"https://aachou.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法复杂度","slug":"算法复杂度","permalink":"https://aachou.github.io/tags/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6/"}],"author":"沧海一粟"},{"title":"halo开源博客","slug":"halo开源博客","date":"2020-07-02T02:38:18.000Z","updated":"2023-08-09T10:16:10.000Z","comments":false,"path":"2020/0702/","permalink":"https://aachou.github.io/2020/0702/","excerpt":"Halo开源博客项目配置简介Halo [ˈheɪloʊ]，意为光环。Halo 是一款现代化的个人独立博客系统，给习惯写博客的同学多一个选择。当然，你也可以当成拼音读(哈喽)。","text":"Halo开源博客项目配置简介Halo [ˈheɪloʊ]，意为光环。Halo 是一款现代化的个人独立博客系统，给习惯写博客的同学多一个选择。当然，你也可以当成拼音读(哈喽)。 声明 本项目旨在创造一个好的产品以供人们使用（虽然现在并不是太好），并非一个所谓提供学习的项目。所以，不提供任何学习代码的帮助。也请不要在讨论群，issues，论坛发起任何有关代码学习的问题。当然，如果你是要参与代码贡献，我们非常欢迎。 另外，写给想自己拉代码编译运行的同学： 目前我们的开发分支即 master，肯定会有很多小问题，不要运行不起来就跑过来吐槽什么代码开源不完整之类的，多找找自己的原因。同时建议下载最新 release 版本的代码，或者在 master 分支执行 git checkout v1.3.2。 PS：实在不想写这个声明（影响 README 的美观），但是就目前来看，写在 README 上是有必要的，因为大部分遇到问题的人都不会去仔细阅读文档。 快速开始下载最新的 Halo 安装包 其他地址：https://halo.run/archives/download.html 1curl -L https://github.com/halo-dev/halo/releases/download/v1.3.2/halo-1.3.2.jar --output halo-latest.jar 或者 1wget https://github.com/halo-dev/halo/releases/download/v1.3.2/halo-1.3.2.jar -O halo-latest.jar 启动 Halo1java -jar halo-latest.jar 详细部署文档请移步：https://halo.run/archives/install-quick-start.html 博客示例请移步： https://halo.run/p/user-wall.html。 周边 后台管理（halo-admin）：https://github.com/halo-dev/halo-admin 独立评论模块（halo-comment）：https://github.com/halo-dev/halo-comment 管理 APP（已停止维护）：https://github.com/halo-dev/halo-app 主题仓库：https://halo.run/p/themes.html 资源下载：https://dl.halo.run WeHalo 小程序：https://github.com/aquanlerou/WeHalo 启动项目前配置 项目为gradle项目，项目依赖文档配置在build.gradle,开始前确保能自动导入依赖，导入需要花费一些时间。之后可以进行具体的配置，如数据库的配置，找到文件application.yaml文件。 将h2数据库的enabled和web-allow-others改为true 差不多就可以启动整个项目了，怎么启动呢？之前已经有经验了吧，介绍了一个eladmin后台管理系统的项目，难度或者复杂度比这个大一点，其中就讲了具体的项目的启动配置。找到项目中唯一能运行的源代码文件，一般在源代码文档src&#x2F;main&#x2F;java里面，找到它，命名一般是AppRun或ApplicationRun或者Application的Java文件，打开能看到有main()函数的，就是项目启动文件。IDEA会自动找到可运行的启动文件，并打开绿色小三角按钮，点击小三角启动它！可以看到左下角项目在编译运行。启动后没有乱码和红色报错，说明配置对了。 如果出现乱码的情况，说明编译的时候没有配置好，而编码需要的是UTF-8，找到项目的依赖配置文件build.gradle,添加如下配置。 123tasks.withType(JavaCompile) &#123; options.encoding = &#x27;UTF-8&#x27;&#125; 如果出现红色报错，说明有其他配置问题，很大原因是导入依赖不成功，受到了网速影响，需要重新导入模块。还有问题请加群交流，这里不做详细的解释！ 预览图这个halo博客后台支持markdown语法的编辑，对写博客非常友好！ 总结对比其他博客框架，halo博客是一个动态的博客系统，有前端，有后台，可以自己买个服务器搭一搭。而其他的开源博客，有一部分是没有后台的，修改上传文章主要在线下完成，所以维护起来十分费劲。如果可以的话还可以动手改halo的样式，halo也有其他主题样式供选择。OK，以上就是简单的玩一玩开源项目，具体大家可自行研究，有问题或探讨可以关注我公众号！","categories":[{"name":"项目","slug":"项目","permalink":"https://aachou.github.io/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"开源","slug":"开源","permalink":"https://aachou.github.io/tags/%E5%BC%80%E6%BA%90/"},{"name":"博客","slug":"博客","permalink":"https://aachou.github.io/tags/%E5%8D%9A%E5%AE%A2/"}],"author":"沧海一粟"},{"title":"IDEA报错稀有问题","slug":"IDEA报错稀有问题","date":"2020-06-26T10:36:18.000Z","updated":"2023-08-09T10:18:12.000Z","comments":false,"path":"2020/0626/","permalink":"https://aachou.github.io/2020/0626/","excerpt":"IDEA报错稀有语法问题","text":"IDEA报错稀有语法问题 Error: java: Compilation failed: internal java compiler error;Error: java需要”;” 这种报错不知道大家见过没有，可能一般人不会出现这种编译错误。实际上它的错误是红色的那个”Erroe:java:需要”;” “,但是仔细检查正在编辑的代码，一点语法错误都没有，IDEA也没说哪里出问题了。于是又陷入了长久以来的僵局——百度！ 百度的结果结果说是jdk版本没配置好，我信了，又屁颠屁颠的改版本，原来是jdk8呀，现在也是。步骤如下： 百度结果的特点就是，搜出来一大堆相类似的东西，而你要的却是另外一个东西所以我放弃百度的搜索，改用经典的eclipse进行编辑，在导入文件夹时，没运行就发现了语法错误，然而eclipse给我报错是这样的： 很清楚的给我错的地方！但是反过来看，IDEA自称最智能的编辑器，有时候还是像智障编辑器，eclipse虽然皮肤不好看，但是依旧经典。ok，我回到IDEA智障编辑器里了，这里的问题应该就不难弄懂了，还是过不去的语法问题，出错在另一个文件里。 改回来之后就行了，就能运行程序了。 总结IDEA报错有时让人摸不着头脑，还告诉你错在何处，接着错上加错，虚度光阴，罪恶之极！总结下来的原因就是，像IDEA编辑文件都是以项目文件进行编辑的，如果一个文件出语法错误，另一个文件(整个项目源码文件)都会受牵连，就会编译不过去。尽管这样，IDEA还是不告诉哪里有语法错误，建议在实际项目用eclipse进行编辑。管他香不香，用的舒服就好！","categories":[{"name":"问题","slug":"问题","permalink":"https://aachou.github.io/categories/%E9%97%AE%E9%A2%98/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://aachou.github.io/tags/IDEA/"},{"name":"语法","slug":"语法","permalink":"https://aachou.github.io/tags/%E8%AF%AD%E6%B3%95/"}],"author":"沧海一粟"},{"title":"带你跑一个开源项目","slug":"带你跑一个开源项目","date":"2020-05-31T02:34:07.000Z","updated":"2023-08-09T10:22:36.000Z","comments":true,"path":"2020/0531/","permalink":"https://aachou.github.io/2020/0531/","excerpt":"带你跑ELADMIN后台管理系统开源项目前言：最近开始稍微接触了点框架，本来是想学点开源项目什么的，但学起来耗得时间长，所以公众号和博客的文章都慢慢的停更了许久。之前的java多线程和反射都还没弄透，更别说java源码和JVM了，学习这件事真的需要坚持、耐心和不断总结 。github上满是开源项目，建议找一个适合的项目练练，看看它用到的技术，一个个吃透了，以后用到相同的技术就越发熟练，看代码如同行云流水，毫不费劲。今天就推荐一个十分火爆的开源项目el-admin后台管理系统，结合前端Vue使用 ，是一个不错的开胃菜。","text":"带你跑ELADMIN后台管理系统开源项目前言：最近开始稍微接触了点框架，本来是想学点开源项目什么的，但学起来耗得时间长，所以公众号和博客的文章都慢慢的停更了许久。之前的java多线程和反射都还没弄透，更别说java源码和JVM了，学习这件事真的需要坚持、耐心和不断总结 。github上满是开源项目，建议找一个适合的项目练练，看看它用到的技术，一个个吃透了，以后用到相同的技术就越发熟练，看代码如同行云流水，毫不费劲。今天就推荐一个十分火爆的开源项目el-admin后台管理系统，结合前端Vue使用 ，是一个不错的开胃菜。 项目简介：一个基于 Spring Boot 2.1.0 、 Spring Boot Jpa、 JWT、Spring Security、Redis、Vue的前后端分离的后台管理系统 开发文档： https://docs.auauz.net/体验地址： https://auauz.net/ 账号密码： admin/123456 (默认密码都是123456) 后端源码 前端源码 github https://github.com/elunez/eladmin https://github.com/elunez/eladmin-web 码云 https://gitee.com/elunez/eladmin https://gitee.com/elunez/eladmin-web 这是用流行框架spring boot和vue实现的前后端分离的后台管理系统，不要被前后端分离吓到了，只是前后端的代码放在不同的地方而已，没有什么特别重要的技术难点。 准备环境上面已经给出了项目的源码，把前后端的源码下下来就行了，之后要准备什么呢？当然是准备跑项目的环境了，可以分为前端和后端的运行环境。在项目里，是需要后端的，所以先配置后端环境。那我们如何知道应该配好怎样的环境呢？看github项目的介绍，README文档里面也有介绍，以后可以直接看README就行了。既然是个Java项目，当然应该有Java的环境啦，这个可以直接用IDEA代替，社区版的也行，项目的文件就用IDEA打开就是了。 Redis数据库安装配置如果没有，可在公众号内回复redis获取。下载好后，应首先配置它的环境变量。分别打开redis-servr.exe和redis-cli.exe，如下： mysql配置项目里的eladmin.sql文件为MySQL启动脚本，了解后，并不是双击运行。前提应该有mysql和数据库管理器吧，没有mysql可以在公众号内的软件工具哪里找，应该有，记得配置环境变量。另外管理工具就别用SQL Server了，sqlyog也不错，官网有社区版的，就下的慢，推荐链接：https://pan.baidu.com/s/1PcVVkucLRf-49lHDPl6syA 提取码：w27i 。先建一个项目数据库。 接着用记事本或其他打开项目sql脚本，全选粘贴在询问一栏，并再次全选右键执行查询或摁F9。 结果没报错即可，都不要关闭这些。 后台spring如果没有还有spring这个框架，不用太担心，这样大部分是框架依赖，所以交给IDEA去干就行了，前提是别把网断了，需要下依赖包。如何让IDEA自动下呢？在文件那点击setting设置，在Build,Execute那的Maven选项。 自动导入Maven项目 上图把编译器生成的字节码类型改为和jdk相同版本，我这里用jdk11编译，不然会报“不支持java 5版本，请使用6及以上版本”。更具体的操作可以自己搜索解决，比较简单。同样在项目的配置文件pom.xml里，需要添加相应的依赖属性。 &#x2F;&#x2F;添加下面几个，如果没有就加上去 &lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;&#x2F;project.reporting.outputEncoding&gt; &lt;java.version&gt;11&lt;&#x2F;java.version&gt; &lt;maven.compiler.source&gt;11&lt;&#x2F;maven.compiler.source&gt; &lt;maven.compiler.target&gt;11&lt;&#x2F;maven.compiler.target&gt; 这时候还不能自动下载依赖包，可以手动刷新或者说重新导入项目，右键项目文件，在maven选项那点reimport就行了。 耐心等待后，就可以启动后台了，在eladmin-system下找到Apprun的Java文件，运行它。结果如下，没报错就行！ 前端配置前端配置比较容易出错，报错了直接在命令行输出一大堆信息，关键是解决起来非常麻烦。配置前端呢主要是为了能让大家在本地就能看到效果，只有后端的项目，再好，没前端相辅相成，项目跑的也没意思！同样的套路，同样的逼数！首先咱们找到前端的文件夹，发现里面是没有前端的依赖的，这个不足为奇。那咱们就需要配置依赖了。主要是node.js , node.js 是一个基于 Chrome V8 引擎的 JavaScirpt 运行环境，可以用于服务端编程。我们把它下载后需要配置它的环境变量，目的是为了用他的包管理工具npm(nodejs package management)，那有什么用呢? 1231 允许用户从NPM服务器下载别人编写的第三方包到本地使用2 允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用3 允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用 在这之前，把文件夹里的package.json包修改一下，找到script那里，添加如下： 123456&quot;scripts&quot;: &#123; //如果没有以下，则添加 &quot;dev&quot;: &quot;vue-cli-service serve&quot;, &quot;start&quot;: &quot;node index.js&quot;, &quot;server&quot;: &quot;nodemon index.js --ignore client&quot;, &quot;build&quot;: &quot;vue-cli-service build&quot;, &#125;, 我们下翻，还能看到前端的依赖dependencies和环境需要的版本，node在8.9及以上，npm在3.0.0及以上。 1234&quot;engines&quot;: &#123; &quot;node&quot;: &quot;&gt;=8.9&quot;, &quot;npm&quot;: &quot;&gt;= 3.0.0&quot; &#125;, 之后说白了，npm就是帮我们把前端需要的依赖给下了，方便生成前端页面。具体的nodejs的下载安装配置，可以搜索相关文章，这里就不多讲了。命令行‘npm -v’查看npm版本，能看到输出，说明配置成功。 npm config set registry https://registry.npm.taobao.org-g &#x2F;&#x2F;设置淘宝镜像，加快下载依赖 cd进入前端文件夹内，输入”npm install”，开始下载依赖，之后文件夹内会多出node_modules文件夹，命令行中不出现报错就行，报错的话可能有几个原因。 网络原因，下载中断了，或下载较慢 package依赖包没配置好，应先配置好 版本低，检查一下 如果不是以上原因，可能是某一个具体因素导致的，就需要仔细查看命令行报错了，很可能是某个依赖没有下好，可以直接进入文件夹查看，如果没有则真的没下好，可以：npmuninstall xxx;再npm install xxx，重新来一遍。 然后一切顺利，”npm run build: prod”；”npm run dev”；前端就跑起来了！结果如下： 当然我们不只是纯粹为了演示项目，像里面的配置啊什么的，技术还需要我们一步一步吃透。要学会解决问题，学习路上总有风雨，只要努力专研，还是会有所收获的！如果有更多问题就关注公众号吧！加群了解更多！这次就分享到这了。","categories":[{"name":"项目","slug":"项目","permalink":"https://aachou.github.io/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"eladmin","slug":"eladmin","permalink":"https://aachou.github.io/tags/eladmin/"},{"name":"项目","slug":"项目","permalink":"https://aachou.github.io/tags/%E9%A1%B9%E7%9B%AE/"}],"author":"沧海一粟"},{"title":"相比c++,java在基础语法上的改变","slug":"相比c-java在基础语法上的改变","date":"2020-05-28T02:23:55.000Z","updated":"2023-08-09T10:17:23.000Z","comments":true,"path":"2020/0528/","permalink":"https://aachou.github.io/2020/0528/","excerpt":"此篇给Java初学者的一点参考，算是入门吧，对有c&#x2F;c++基础的同学来说，更是帮助他们尽快理解Java更深层次(面向对象，集合，泛型，多线程与并发)的强力剂，如有缺漏敬请补正！","text":"此篇给Java初学者的一点参考，算是入门吧，对有c&#x2F;c++基础的同学来说，更是帮助他们尽快理解Java更深层次(面向对象，集合，泛型，多线程与并发)的强力剂，如有缺漏敬请补正！ 文章目录： 运行机制 基本数据与特殊类型 字符集与数值表达 文档注释 连字符+与输出 switch语句 foreach循环 数组类型 01 Java运行机制在运行机制上，Java不同于任何一门语言，Java编写好的源代码文件并不是经过编译后就能立马执行的。不像c&#x2F;c++一样，编译后就是.exe了，双击就可以运行，但是Java有它巧妙的地方。先说明一下，任何的编程语言的源码都需要经过编译变成二进制代码，才能被执行，无论c&#x2F;c++还是Java。在Windows上把c&#x2F;c++源码经过gCC&#x2F;g++编译后能运行，但在Linux或其他平台，要有相应的源码编译器为源码进行编译，也就是说，想要在其他平台上运行，得把c&#x2F;c++源码在编译一遍才能运行。看起来也还行的样子，不就是在编译一次嘛！有多大麻烦呢？对程序员来说不算是什么难事，但对用户来说就是难事，或者说，用起来就是个麻烦事。谁还会辛辛苦苦又编译一次源码，然后让它在机子上跑，万一出问题还得重来！ 起初Java就是为解决这个问题而设计出来的，最早是被sun公司用于嵌入式的设备开发，理念是“write once,run anywhere!”，设计出来后并不很火，那时候c++本身就可以跨平台，所以也没Java什么事儿了。但是之后发现真的可以做到 “ run anywhere ” , 并且由于网页端互联网浪潮的掀起，Java在web上大显身手，这才有了今天的Java，然而sun公司在09年被Oracle收购，之后江湖上再也没了sun公司的身影。那Java又是怎么解决跨平台的问题呢? 先要了解Java文件，源码文件以.java为后缀，经过编译后不直接生成可执行文件，而是生成.class字节码文件(16进制)，这个文件不是让平台的操作系统读的，是让JVM (java virtual machine)java虚拟机读的，平台上的虚拟机识别后会相应生成能让机子跑起来的二进制文件，就能执行了。其中的原理比较复杂，就不过多陈述啦！ 那有人就不快乐啦：就这？ 当然不是，继续讲。想简单跑一个”hello 妹纸！”需要咋做啊？ 首先上[Oracle的官网]，下载jdk1.8版本，就是常说的Java8。jdk(java development kits大概就这样)，顾名思义：Java开发包，有SE(standard environment) , EE (enterprise environment),ME(micro environment),即标准版，企业版，微型版。我们要学的是SE，到了工作岗位，可能就要EE了，ME现在基本少的接触，就不用学了，毕竟jdk都14了！里面大致分为javac编译器，运行器java.exe，JRE(java runtime environment) java 运行环境，java基础类库，和其他支持。其中JRE里面有JVM(负责解释字节码)，和其他环境支持。如果在windows上编译”coder小 码.java “源文件，就变成”coder小码.class”,想要在另一台装linux的机子上运行，只需要在这台机子上装JRE就行了，JVM解释”coder小码.class”文件后执行它就行了。 02 基本与特殊数据类型Java相较于原始的c语言，多出了两个基本数据类型，byte字节(1个字节)，和boolean布尔(true&#x2F;false)基本类型,总共8种；其他为引用(reference)类型，多出了String字符串类型，Array数组类型，null类型(唯一值null)，等等。原来的char字符类型变成了两个字节，可以支持中文字符，一个char,一个汉字。 保留字(目前未使用但以后会使用):const ; goto也是关键字。 直接量：true,false,null.虽然不是关键字，但依然不能用来做标识符。 标识符：增加了$标识开头(中英字母，下划线)，同样不能数字打头，其后才能接任意字符，中日英皆可。 03 字符集与数值表达上面大家可能就有点疑问了，咋就这么越来越开放了！中日字符都来了！没错，Java换了字符支持，使用unicode字符集，几乎支持所有字符，改变了以往编程语言只支持英文标识符的情况，现在读取一个char就相当于读取了一个汉字了。unicode就是这么杠！ 数值表达：Java在整数上又动手动脚的，增加了对二进制整数的表达，比如。 1int binary = 0b10000001; 上面为一个负数，需要换算成原码为-128。另外为防止程序员出意外看走眼，还可以写成： 1int binary = 0b1000_0001; 用下划线可以分隔整型和浮点型。 04 文档注释注释除了以前常用的单多行注释，Java还增加了文档注释。Java为开发者提供了大量的基础类，同时也提供了API帮助文档，介绍各个API、方法、包、类的使用方法，原型。如果编写很大的Java程序，可以利用javadoc工具将源码的文档注释提取出来变成API文档，例： 1234567/**两个**Description*&lt;h1&gt;javadoc&lt;/h1&gt;*Copyright 2009*@author coder小码*@version 1.0*/ 可以在类，方法，public\\protected变量前加注释。进入目录，终端输入： 1javadoc -d D://coder/ -windowtitle API文档 -author -version *.java 上面的命令用于生成Java文档，-d 存放目录 ，-windowtitle 窗口标题，-author -version,加上作者和版本信息，从当前目录下所有Java源文件中提取注释。之后就生成了和官方一样专业的API文档了！ 05 连字符‘+’与输出和c++一样，Java也有连字符，可以将字符串拼接到一起，但同时又能做算术运算，这就涉及到了运算符的重载和基本数据类型的装拆箱了。 1234String coder = &quot;小码&quot;+&quot;coder&quot;;String coder2 = &quot;coder小码&quot;+321；System.out.println(coder);System.out.println(coder2); 输出为：“小码coder”,“coder小码321”。 将+看作是一个方法，既可以把数字作为参数，又可以把字符做参数，而方法名却没有变，算是隐式的重载一个“+”方法。 输入输出：Java里主要有3种输出方式，或者说方法吧！上面的算一种：println(变量),即直接输出变量值，还带换行！第二种：printf(“%s”,string),这种再熟悉不过了，需要搭配格式符输出；第三种：print(变量)，同样直接输出值，只不过不带换行！以上都在lang包的System类下的out方法，返回PrintStream输出流类下的println()方法。 06 switch语句Java7增强了switch语句,原来从switch(expression)，表达式只能是byte , short , int , char四种，后来增加了枚举类型enum和String类型，但是不能为true&#x2F;false布尔型 。相比c&#x2F;c++的switch语句，多了byte,char(可以是单个中文字符)。需要注意的是：可以是String类型，而不是StringBuffer或StringBuilder字符串类型，即使都是字符串类型。 1234567891011121314String coder = &quot;coder小码&quot;;switch (coder)&#123; case &quot;点赞&quot;: System.out.println(coder); break; case &quot;收藏&quot;: System.out.println(coder); break; case &quot;coder小码&quot;: System.out.println(coder); break; default: System.out.println(coder);&#125; 07 foreach循环foreach循环是从Java5之后开始加入的，python语法里也有foreach循环，使用它进行遍历操作非常方便。那方便在哪呢？ 无需获得要遍历对象的长度，即不需要知道数组或集合多大 无需根据索引(下标)访问数组或集合(collection)的元素 foreach语法如下： 1234for(元素类型 循环变量: 数组或集合)&#123; //要执行的代码块 System.out.println(循环变量);&#125; 从上面看出，foreach的循环将数组或集合中的元素临时赋值给了循环变量，后逐个输出，并没有改变数组的元素，即foreach虽好，但不能改变数组或集合的内容 或值。如果在循环内给循环变量进行赋值，同样不能改变其内容，反而将想要获得的数组的元素修改替换了。 08 数组类型在Java里数组类型有很大变化，以前在c&#x2F;c++里，数组名就相当于一个指针，指向数组内存首地址。在Java中不是没有指针，只是指针这种概念被弱化了，很少提到，反而多出了引用这种类型，而数组就属于引用类型。 数组的定义有两种方式：12int[] coder;或int coder[]; 很明显，在引入引用的概念并支持unicode字符集后，选择第一种方式才符合Java的语法，不是说第二种就错了，而是第二种可读性太差，很容易看成是定义了一个int类型的以“coder[]”为变量名的数据，而第一种方式，int[]本身就是一种引用类型，而coder就是一个妥妥的引用变量。 数组的初始化的3种方式：123第一种：coder = new int[] &#123;3,2,1&#125;;第二种：coder = new int[3];第三种：int[] coder = &#123;3,2,1&#125;; 经典又常用的三种初始化方式，先说前两种吧。前两种都是在已经定义了数组的情况下进行初始化的，我们将第一种称做静态初始化，即初始化的时候就把元素值填了进去，这个时候数组就定了，长度不再改变。而第二种则可以称动态初始化，只是初始化他的长度，并没有赋值。第三种是第一种的简化，即把数组定义和静态初始化两步合一步。以上就是数组的诞生过程，可能有小伙伴会发牢骚：弄一个数组都这么麻烦，还没c&#x2F;c++效率高呢！的确，c&#x2F;c++是效率高，但上面之所以要带一个关键字new，其实是为了给数组分配一个内存并初始化赋值，尽管定义了一个数组变量，但只是引用变量而已，没有真正的存数据的内存，起到的也只是一个指向内存的作用，真正有内存是new一个给它。","categories":[{"name":"java","slug":"java","permalink":"https://aachou.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://aachou.github.io/tags/java/"}],"author":"沧海一粟"},{"title":"SQL server连接本地数据库的两个问题","slug":"SQL-server连接本地数据库的两个问题","date":"2020-05-22T21:46:14.000Z","updated":"2023-08-09T10:19:34.000Z","comments":true,"path":"2020/0523/","permalink":"https://aachou.github.io/2020/0523/","excerpt":"SQL Server连接本地数据库时的异常 最近想学点SQL server,几个月前下过，可中间电脑换过机名，重装过系统(电脑不是键盘一下没反应就是鼠标没反应)，充分暴露出windows的不稳定。这告诉我们：要早点和windows离婚吧，换一个漂亮又好用点的linux系统(关键是免费开源)，如果有钱可以跟风mac。哈哈！所以呢，系统里的环境变量全部没了，除了操作系统本身的变量外。经验告诉我们：换系统就是换血，把C盘的除系统外的渣渣都清除了，还好是其他盘的东西还在，不过又得手动配置她们的变量了。","text":"SQL Server连接本地数据库时的异常 最近想学点SQL server,几个月前下过，可中间电脑换过机名，重装过系统(电脑不是键盘一下没反应就是鼠标没反应)，充分暴露出windows的不稳定。这告诉我们：要早点和windows离婚吧，换一个漂亮又好用点的linux系统(关键是免费开源)，如果有钱可以跟风mac。哈哈！所以呢，系统里的环境变量全部没了，除了操作系统本身的变量外。经验告诉我们：换系统就是换血，把C盘的除系统外的渣渣都清除了，还好是其他盘的东西还在，不过又得手动配置她们的变量了。 01 SQL SERVER初探初入SQL SERVER的可能不知道有两种版本分类的SQL SERVER，那现在就普及一下。第一种是MSSQL SERVER,全称是Microsoft SQL Sever，开发版，目前的大型网站一般使用Oracle或者MSSQL，JSP.PHP.ASP都可以。一般是企业级的商务网站使用的。全功能SQL数据库服务器，从2017版开始，横跨任何平台，完全免费。第二种是Express ，商业免费，有对应的限制一般都用这个。是SQL SERVER的简洁版，可以这样说。 但开始我也不懂啊，也没人叫我怎么玩哈，所以最近发现SQL不见了，就急忙下个SQL server2019最新版的玩一下。不行的是下载了6个多G，连带管理工具一起下(都是开热点的流量啊！啊啊！)，N久后，才下完！然后安装！！！N久。 起初是发现从前的2017版的没有了，主要是SSMS没有，SSMS是SQL SERVER Management Studio,SQL SERVER管理工具，用来管理数据库的，而我们下的是SQL SERVER的一个下载工具罢了。没SSMS还是玩不起来。 02 第一个问题：配置管理器无法连接到 WMI 提供程序 这个问题我记住你了，化成灰我都认得你！！ 弄了我一整晚，网上都查遍了，每个有效的方法。现在给大家清楚讲一遍，按上面的说，WMI,（Windows Management Instrumentation 即windows 管理规范）是一项核心的 Windows 管理技术；用户可以使用 WMI 管理本地和远程计算机。简单点，就是管本地和远程计算机的一个东西。有点内味了！！也就是说要这个服务来帮助SQL配置管理器管理计算机的，那怎么管呢？ 有两种解决方法：要么是没权限，弄权限；要么是服务器真的不能访问了，解决服务器。很明显，连自己的本地的机子，还说无法访问，那就是没权限啦。查查了半天，说要弄一个NETWORK SERVICE的权限，也弄了没反应，估计还不够吧！之后又有其他办法，说进如：”C:\\Program Files (x86)\\Microsoft SQL Server”里面，我的是这样的，里面是90‘100’120‘的数字文件夹(跟系统打交道的)，不是真正的SQL SERVER文件夹(有界面的那个)。 其中有一个shared文件夹里有150\\Shared\\sqlmgmproviderxpsp2up.mof这个文件。 我的是150&#x2F;，可能不一样。之后在命令行输入： mofcomp “C:\\Program Files(x86)\\MicrosoftSQLServer\\150\\Shared\\sqlmgmproviderxpsp2up.mof” 结果：将本地数据放到SQL储存库中了，就表示能访问到。那mof是个什么东西呢！ 反正就是微软瞎造的东西，跟配置有关。不管了！可以正常打开配置管理器，但是里面项目为空，啥也看不到呀！正常是这样的： 但是右边什么也没有，而且，SSMS还是连不上本地的数据库实例。 第二个问题：系统找不到指定的文件GUI是这样的：本来是输入个本机名字就行了，可就是死活连不上。SSMS: 想玩我？没门！这个时候，还是用的2017的SQL配置管理器，2019的SQLEXPRESS，连2019的配置管理器都没有，当然弄不了了。那之前的努力都白搭，花了我N久弄完！ 其实挺简单的，一步解决上面两个问题，还能使用最新的2019SQL SERVER。对啦，就是重新安装，不用开浏览器上什么官网，直接follow me。哈哈！ 找到SQL SERBER的安装目录，就是那个有安装的SQL server2019： D盘文件夹： sqlserver文件夹里是这样的： 之后一路默认安装： 安装期间会同时实例化本地的数据库，以windows管理员的身份管理，完成后就能看到开始菜单里有2019配置管理器了： sercice服务里也会有SQL服务，之前是没有的，即使解决了第一个问题后。估计这就是第二个问题没解决的原因吧！没SQL server服务，就没得玩喽！ 所以最后献上玩美结果： 哈哈，如果要用Network service权限解决的话请参考另一篇最后祝大家玩的愉快！！ 最后附上：小码csdn博客园微信公众号：小码之光","categories":[{"name":"SQL","slug":"SQL","permalink":"https://aachou.github.io/categories/SQL/"}],"tags":[{"name":"SQLserver","slug":"SQLserver","permalink":"https://aachou.github.io/tags/SQLserver/"}],"author":"沧海一粟"},{"title":"moneykeeper","slug":"小码moneykeeper","date":"2020-05-13T23:07:24.000Z","updated":"2023-08-09T10:42:38.000Z","comments":true,"path":"2020/0514/","permalink":"https://aachou.github.io/2020/0514/","excerpt":"纯c小项目，资金管理工具moneykeeper最近闷得慌，又在学java(自学，想走这条路，哎，一个人找到所爱的真的很难,说不定哪天真的挂了，就来不及了)，慢慢地觉得特别吃力了，主要是学习环境不好，住在一个‘破房子’里，人口又多，真的是烦，而且还不是自个家（没家）。有意识地数了数钱口袋，发现是真的穷死光，","text":"纯c小项目，资金管理工具moneykeeper最近闷得慌，又在学java(自学，想走这条路，哎，一个人找到所爱的真的很难,说不定哪天真的挂了，就来不及了)，慢慢地觉得特别吃力了，主要是学习环境不好，住在一个‘破房子’里，人口又多，真的是烦，而且还不是自个家（没家）。有意识地数了数钱口袋，发现是真的穷死光，哎！！！郁闷啊啊啊！感觉连自个亲人都被抛弃地感觉！(**除了自己，谁都别信！**因为别指望他们能帮你买房买车，理解你的世界！) 总想做点什么，于是敲了敲几行代码，做了个小钱钱管理工具，以后方便看看钱兜(哎！)，自己觉得挺简单实用地就分享给大家了，源码也给哈！下载地址 :理财moneykeeper 项目代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;windows.h&gt;#include&lt;conio.h&gt;// 户名结构体 typedef struct&#123; char hum[100];// char money[10];&#125;hums;// 构造函数void outdata(void); void empty(char *sf);void putdata(hums *hm);void qorw(hums *hm);int strint(char *s);int main(void)&#123; hums zhanghu[11]; //定义户名结构体数组 char get[4]; char command[4]; FILE *fpr; fpr = fopen(&quot;E:\\\\wokfilc\\\\moneykeeper\\\\data.txt&quot;,&quot;r&quot;); fgets(get,5,fpr); fclose(fpr); if(get==&#x27;\\0&#x27;||get==&quot; &quot;)&#123; printf(&quot;无账户信息!&quot;); qorw(zhanghu); &#125;else&#123; outdata(); printf(&quot;请继续写入wd或退出quit：\\n&quot;); scanf(&quot;%s&quot;,command); if(strcmp(command,&quot;quit&quot;)==0)&#123; exit(0); &#125;else if(strcmp(command,&quot;wd&quot;)==0)&#123; putdata(zhanghu); outdata(); qorw(zhanghu); &#125;else&#123; printf(&quot;输入错误，请重新输入：\\n&quot;); qorw(zhanghu); &#125; &#125; return 0;&#125; //输出信息 void outdata()&#123; FILE *fpr; fpr = fopen(&quot;E:\\\\wokfilc\\\\moneykeeper\\\\data.txt&quot;,&quot;r&quot;); int sum=0; char DataStr[100]; printf(&quot;*****$$*****\\n正在输出账户信息：\\n&quot;); while(feof(fpr)==0)&#123; fseek(fpr,0L,SEEK_CUR); //? fgets(DataStr,100,fpr); if(DataStr!=&#x27;\\0&#x27;&amp;&amp;DataStr!=&quot; &quot;)&#123; printf(&quot;%s \\n&quot;,DataStr); &#125; sum = sum+strint(DataStr); empty(DataStr); &#125; fclose(fpr); printf(&quot;您的总资金合计为：%d元\\n&quot;,sum);&#125;//empty初始化清空数组 void empty(char *sf)&#123; int sfsize = 0; sfsize = sizeof(sf); for(int n=0;n&lt;sfsize;n++)&#123; sf[n] = &#x27;\\0&#x27;; &#125;&#125; //写入数据 void putdata(hums *hm)&#123; FILE *fpw; fpw = fopen(&quot;E:\\\\wokfilc\\\\moneykeeper\\\\data.txt&quot;,&quot;w+&quot;); int i = 0; char input[100]; printf(&quot;(回车)请写入账户数据：\\n&quot;); do&#123; int len = 0; empty(input); printf(&quot;请写入第%d个账户数据:\\n&quot;,i+1); scanf(&quot;%s&quot;,input); len = strlen(input); strcpy(hm[i].hum,input); strcat(hm[i].hum,&quot;\\n&quot;); fputs(hm[i].hum,fpw); i = i+1; &#125;while( (strcmp(input,&quot;end&quot;))!=0&amp;&amp;(i&lt;11) ); fclose(fpw); //写入完毕后关闭文件 &#125;//字符串中提取数字 int strint(char *s)&#123; int slen=0; int Money=0; int ml = 0; char money[10]; slen = strlen(s); for(int n=0;n&lt;slen;n++)&#123; if(s[n]&gt;=48&amp;&amp;s[n]&lt;=57)&#123; money[ml]=s[n]; ml++; &#125; &#125; Money = atoi(money); return Money;&#125;//选择（退出或重新写入）函数void qorw(hums *hm)&#123; char getput[10]; printf(&quot;请选择(重新)输入wrdo或退出quit：\\n&quot;); scanf(&quot;%s&quot;,getput); while(strcmp(getput,&quot;quit&quot;)!=0)&#123; if(strcmp(getput,&quot;quit&quot;)==0)&#123; return; &#125;else if(strcmp(getput,&quot;wrdo&quot;)==0)&#123; putdata(hm); qorw(hm); return; &#125;else&#123; printf(&quot;重新输入,&quot;); qorw(hm); return; &#125; &#125;&#125; 源码讲解就不用了吧！相信坚定走这路的人学过c，能看懂吧！主要是也让大家有个真实的现实观，好好管管小钱钱，别胡乱挥霍，以后说不定有大用处！至少能给你一个真正的家(一个固定的住处)！好啦！拜拜，学习去喽！","categories":[{"name":"c/c++","slug":"c-c","permalink":"https://aachou.github.io/categories/c-c/"}],"tags":[{"name":"moneykeeper","slug":"moneykeeper","permalink":"https://aachou.github.io/tags/moneykeeper/"}],"author":"沧海一粟"},{"title":"疫情之下c又崛起！","slug":"疫情之下c又崛起！","date":"2020-05-09T23:26:56.000Z","updated":"2023-08-09T10:20:39.000Z","comments":true,"path":"2020/0510/","permalink":"https://aachou.github.io/2020/0510/","excerpt":"已经5月份了，国内的疫情也渐渐的好转，人们也把目光放在了经济发展和工作上，拿着漫长的疫情期间，编程界有什么波动呢？ 据tiobe官网5月份最新数据显示，C语言在疫情结束后悄悄地登上排行第一位，这是继2015java霸着冠军宝座以来，c语言重新闪耀它的魅力。来看看数据：","text":"已经5月份了，国内的疫情也渐渐的好转，人们也把目光放在了经济发展和工作上，拿着漫长的疫情期间，编程界有什么波动呢？ 据tiobe官网5月份最新数据显示，C语言在疫情结束后悄悄地登上排行第一位，这是继2015java霸着冠军宝座以来，c语言重新闪耀它的魅力。来看看数据： 从上面看出，c已经超过java1%，相差并不大，也就是说，java仍有其可用之处，短期内并不会被时代抛弃。同时也不意味着c能继续禅位。其中可以看到，以大数据、嵌入式为方向的语言如python、R有了明显的排名提升，这说明，在未来大数据、云计算及嵌入式的科技发展将占据一定的主导地位，并且将应用到人工智能领域，推动人工智能的进一步发展。 再来看看官网的解读： Java和C在4月已经非常接近，但是本月C再次超越Java。C上一次成为第一名是在2015年。我们只能猜测C为什么再次成为第一名。原因之一可能是冠状病毒。这听起来很愚蠢，但是某些编程语言确实可以从这种情况中受益。例子是数据科学领域的Python和R，因为每个人都在寻找该病毒的解毒剂。但是嵌入式软件语言（例如C和C ++）也越来越流行，因为它们被用于医疗设备的软件中。另一方面，值得一提的是，Rust实际上已经接近前20名（一个月内从第27位上升到第21位）。Paul Jansen(保罗·詹森) TIOBE Software首席执行官 TIOBE编程社区索引是编程语言受欢迎程度的指标。索引每月更新一次。评级基于全球熟练的工程师，课程和第三方供应商的数量。诸如Google，Bing，Yahoo！，Wikipedia，Amazon，YouTube和Baidu等流行的搜索引擎用于计算评分。 重要的是要注意，TIOBE索引与最佳编程语言或大多数代码行所用的语言无关。该索引可用于检查您的编程技能是否仍然是最新的，或用于在开始构建新软件系统时就应采用哪种编程语言做出战略决策。TIOBE索引的定义可以在这里找到。 看来官网已经为我们解释的非常好了，只不过有些话很罗嗦。我就不再跟着啰嗦一遍了，总之，c从疫情中发挥了很大的作用，这足以让看不上c的人开开眼。c还是很有作为的！只不过之前没发现而已。大家又在使用或学习哪种语言呢？ 最后：博客CSDN：coder小码公众号‘小码之光’：","categories":[{"name":"c/c++","slug":"c-c","permalink":"https://aachou.github.io/categories/c-c/"}],"tags":[{"name":"c","slug":"c","permalink":"https://aachou.github.io/tags/c/"},{"name":"疫情","slug":"疫情","permalink":"https://aachou.github.io/tags/%E7%96%AB%E6%83%85/"}],"author":"沧海一粟"},{"title":"java equals()函数与‘=='","slug":"java-equals-函数与‘=='","date":"2020-05-08T23:26:20.000Z","updated":"2023-08-09T10:18:03.000Z","comments":true,"path":"2020/0509/","permalink":"https://aachou.github.io/2020/0509/","excerpt":"java equals()函数与‘&#x3D;&#x3D;’ 谈到java的字符串比较函数equals(),就不得不说它真真的用途啦！虽然只是java里面一个简单的知识点，还是有必要扯扯它，因为有许多学习java的小伙伴在比较字符串上纠结与equals()和‘&#x3D;&#x3D;’的选择。","text":"java equals()函数与‘&#x3D;&#x3D;’ 谈到java的字符串比较函数equals(),就不得不说它真真的用途啦！虽然只是java里面一个简单的知识点，还是有必要扯扯它，因为有许多学习java的小伙伴在比较字符串上纠结与equals()和‘&#x3D;&#x3D;’的选择。 equals()函数函数原型： public boolean equals(Object anObject) 函数用来比较字符串内容的相等，可以是字符串的变量String a &#x3D; “coder小码”,字符串对象String a &#x3D; new String(“coder小码”)之间或和同类型的字符串比较，只要是String就行。返回值是布尔值，true \\ false,与类型是String或String对象没有关系，只要字符串内容一致，就返回true,否则false。 字符对象比较 字符对象与字符String比较 字符String之间比较 ‘&#x3D;&#x3D;’关系运算符的运用在编写代码的过程中我们经常用到‘&#x3D;&#x3D;’ 运算符，那 它实质比较的是什么呢？其实也不很高深莫测，实质上是在比较引用指向的内存地址的，只要指向的内存地址相同，即可判断为true。 说到这里可能会有疑惑了，难道还比内存不成？咋回事啊？咱们先看看几个小例子： 对象间的比较 字符间的比较 字符与字符对象的比较 整型间比较 总结以上代码例子可以说明equals()只是用来比较字符串内容的，不涉及字符串值的地址，而‘&#x3D;&#x3D;’用法就广泛一点，还能用来比较整形(不止整形和字符)，但实质上是比较是不是来自同一个地址，是就返回true，否则false。好啦，以上就是今天的内容，欢迎在下面留言哦！每一点都是知识的积累，希望学习躺赢，学习愉快！","categories":[{"name":"java","slug":"java","permalink":"https://aachou.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://aachou.github.io/tags/java/"},{"name":"equals","slug":"equals","permalink":"https://aachou.github.io/tags/equals/"}],"author":"沧海一粟"},{"title":"IDEA启动加速与java编译","slug":"IDEA启动加速与java编译","date":"2020-05-06T01:17:56.000Z","updated":"2023-08-09T10:18:20.000Z","comments":true,"path":"2020/0506/","permalink":"https://aachou.github.io/2020/0506/","excerpt":"","text":"IIDEA启动加速与java编译01 启动加速忽然有一天IDEA说：你打开它“有点慢”，然后说：consider reducing the num of folder under antivirus protection. 这很有效！ 可能用IDEA的伙伴都会遇到这样的问题，这只是一个提示。那他说这很有效，到底个怎么有效呢？consider reducing the num of folder under antivirus protection 意思翻译过来 就是：考虑在病毒防护中排除启动器打开的文件。那具体咋弄？先看看官方解释： 再翻译一下： 某些防病毒软件可能会干扰IDE的构建过程，从而导致构建的运行速度大大降低。 在IDE中运行构建时，会在计算机上创建许多类文件。如果您的防病毒软件启用了实时扫描，则防病毒软件可以在每次创建文件时强制停止构建过程，而防病毒软件会扫描该文件。 如果您使用的是Windows Defender，则IDE会自动检查您是否启用了实时扫描，以及是否将扫描配置为处理IDE写入大量文件的目录。 IDE提供了一种可能性，可以从自动扫描中排除那些目录（此功能在2019.2+ IDE版本中可用）。 如果您希望手动执行必要的配置，则可以按照以下步骤进行： 点击开始按钮 输入“ Windows安全性” 点击“病毒和威胁防护” 点击“病毒和威胁防护设置”下的“管理设置” 如果需要，请向下滚动，然后单击“添加或删除排除项” 对于通知中显示的每个文件夹，请按+按钮，从菜单中选择“文件夹”，然后选择该文件夹。 官方都非常详细地解释了一番，打开IDEA慢的原因受到电脑自带的杀毒软件的影响，使IDEA不能构建文件。 02 java编译有些刚玩IDEA的小伙伴在创建java文件后不知如何编译，大家都知道点击RUN编译运行就可以了，但那是编译带运行输出结果，如果是没有主函数main()呢，只是想编译呢？ 接下来我们介绍三种编译方式： Compile、Make和Build的区别 针对开发工具，一般都有Compile、Make和Build三个菜单项，完成的功能的都差不多，但是又有区别。编译，是将源代码转换为可执行代码的过程。编译需要指定源文件和编译输出的文件路径（输出目录）。Java的编译会将java编译为class 文件，将非java的文件（一般成为资源文件、比如图片、xml、txt、poperties等文件）原封不动的复制到编译输出目录，并保持源文件夹的目 录层次关系。 在Java的集成开发环境中，比如Eclipse、IDEA中，有常常有三种与编译相关的选项Compile、Make、Build三个选项。这三个选项最基本的功能都是完成编译过程。但又有很大的区别： 1、Compile：只编译选定的目标，不管之前是否已经编译过。 2、Make：编译选定的目标，但是Make只编译上次编译变化过的文件，减少重复劳动，节省时间。（具体怎么检查未变化，这个就不用考虑了，IDE自己内部会搞定这些的） 3、Build：是对整个工程进行彻底的重新编译，而不管是否已经编译过。Build过程往往会生成发布包，这个具体要看对IDE的配置了，Build在实际中应用很少，因为开发时候基本上不用，发布生产时候一般都用ANT等工具来发布。Build因为要全部编译，还要执行打包等额外工 作，因此时间较长。 以后编译不用迷迷糊糊的去编译啦！对于IEAD的启动Tips，有些人可能会厌烦，但作为一款风靡全球的智能开发软件，还是对新入门的小鸟有很大帮助的，用习惯了，就想说：“真香！”","categories":[{"name":"IDE","slug":"IDE","permalink":"https://aachou.github.io/categories/IDE/"}],"tags":[{"name":"idea","slug":"idea","permalink":"https://aachou.github.io/tags/idea/"},{"name":"java","slug":"java","permalink":"https://aachou.github.io/tags/java/"}],"author":"沧海一粟"},{"title":"消息轰炸","slug":"消息轰炸","date":"2020-05-03T23:38:33.000Z","updated":"2023-08-09T10:19:41.000Z","comments":true,"path":"2020/0504/","permalink":"https://aachou.github.io/2020/0504/","excerpt":"消息轰炸器(c语言版) C语言学着学着都感觉没啥用，但是事情没有你想的那样枯燥！C还是很有作为的，比如简单的QQ消息轰炸，原理其实很简单！如有需要或了解可关注下面的公众号菜鸡干Java，回复消息轰炸即可获得源码和轰炸器及使用说明。","text":"消息轰炸器(c语言版) C语言学着学着都感觉没啥用，但是事情没有你想的那样枯燥！C还是很有作为的，比如简单的QQ消息轰炸，原理其实很简单！如有需要或了解可关注下面的公众号菜鸡干Java，回复消息轰炸即可获得源码和轰炸器及使用说明。 话不多说，既然是个成品，就爽快地拿出来： 12345678910111213141516#include&lt;stdio.h&gt;#include&lt;windows.h&gt;int main()&#123; int i; char name[100]; printf(&quot;目标：&quot;); scanf_s(&quot;%s&quot;,&amp;name,40); printf(&quot;次数：&quot;); scanf_s(&quot;%d&quot;,&amp;i); HWND H = FindWindow(0,name); //寻找对话框 while(i--&gt;0)&#123; SendMessage(H,WM_PASTE,0,0); //粘贴 SendMessage(H,WM_KEYDOWN,VK_RETURN,0);//回车 &#125;&#125; 原理介绍： &lt;windows.h&gt;这个头文件大家很少接触到，里面是一些有关操作系统地接口函数，实际上它是windows的一部分。 scanf_s()函数的用法和scanf()类似，只不过要两个参数，函数原型为 1int scanf_s( const char *format ，[argument]); 这个函数原型不是太精确，大概来说是这样的，&amp;name为输入需要的储存地址（数组首地址），第二个40为输入大小的限制（40字节）。这个函数是微软之后加上去的，相比scanf()，有输入限制，更安全。 HWND H是定义了一个句柄，本质上是一个指针，指向窗口。FindWindow()函数用来寻找窗口，所以输入给name数组的为窗口标题。第一个参数是个位常量字符串指针，可以不用管。 sendmessage()函数很明显用来发消息，发消息第一步肯定是先把消息粘贴，然后enter键发送啦！第一个参数为句柄，第二个为发消息的类型，比如粘贴或按键，后面的参数为具体按键操作。应该能理解。 i–&gt;0 的意思就是，先判断i是否大于0（大于0，表达式的值为1，否则为0，这个结果将用于while的条件），然后将 i 的值减1。while语句，权如果括号内的值为0，则跳出while循环， 只要括号内的值不为0，则继续循环。 这个大家都学过也能理解。 ok，以上代码就不难弄懂了，好啦，感兴趣的话，可以关注我的公众号进一步了解，希望大家学习c更快乐学习躺赢哦！！哈哈！ 最后：个人博客：https://www.maliaoblog.cn公众号：小码之光","categories":[{"name":"c/c++","slug":"c-c","permalink":"https://aachou.github.io/categories/c-c/"}],"tags":[{"name":"c","slug":"c","permalink":"https://aachou.github.io/tags/c/"}],"author":"沧海一粟"},{"title":"c++高级编程","slug":"c-高级编程","date":"2020-05-01T00:26:55.000Z","updated":"2023-08-09T10:17:07.000Z","comments":true,"path":"2020/0501/","permalink":"https://aachou.github.io/2020/0501/","excerpt":"c++高级编程介绍学c++确实是件痛苦的事，这水平得一步步抬上去，实话说学校教的也不好，就更痛苦了，还要学这学那，对技术没半点提升","text":"c++高级编程介绍学c++确实是件痛苦的事，这水平得一步步抬上去，实话说学校教的也不好，就更痛苦了，还要学这学那，对技术没半点提升。最近就在学这个，没得方向，只好自己归纳了。嘤！嘤！ 目录 预处理 模板 命名空间 文件和流 动态内存分配 异常处理 信号处理 多线程 web编程 01 预处理预处理指令预处理器是一些指令，指示编译器在实际编译之前所需完成的预处理。所有的预处理器指令都是以井号（#）开头，和C语言一样，也不是c++语句。C++ 还支持很多预处理指令，比如 #include、#define、#if、#else、#line 等。 define 预处理 #define 预处理指令用于创建符号常量。该符号常量通常称为宏，指令的一般形式是： 1#define 宏 替代文本 这里的宏可以当成常量，书本上一般都大写。但不是非得大写，可以小写，只是在以后的学习上有一个好习惯。其他的宏就不一一介绍了。 预定义宏 #运算符 和 ## 预处理运算符在 C++ 和 ANSI&#x2F;ISO C 中都是可用的。# 运算符会把替换文本令牌转换为用引号引起来的字符串。 条件编译 有几个指令可以用来有选择地对部分程序源代码进行编译。这个过程被称为条件编译。条件预处理器的结构与 if 选择结构很像。 02 模板模板是c++一个很重要的概念，模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。 上面是c++自己说的，讲的这么高尚，都把自己讲糊涂了！简单去讲，模板可以理解为一种基本模样，可以用来创建函数或者类，或者别的，只是还不到变量的类型。需要注意的是模板可不是类，也就是没有特定的类型啦！ 函数模板 图中的T是无特定类型，整个用法有点像函数重载一样，至少重载需要定义不同的同名函数，参数输入也要不一样，有了模板，代码量就减少了，套模板就是。当输入的是整型时，则T为整形进行运算，其余类似。关于刚才的重载和inline内联可参考上次的文章：c++面向对象吗？不懂看这个 类模板 在这里，type 是占位符类型名称，可以在类被实例化的时候进行指定。可以使用一个逗号分隔的列表来定义多个泛型数据类型。 以上就是几个常见的模板，如果真要一个类型去归纳的话，c++给了一个高大上的名字：泛型，一个宽泛的类型。。。。 03 命名空间在c++中，一个名为 xyz() 的函数，在另一个可用的库中也存在一个相同的函数 xyz()。这样，编译器就无法判断您所使用的是哪一个 xyz() 函数。因此，引入了命名空间这个概念，它可作为附加信息来区分不同库中相同名称的函数、类、变量等。使用了命名空间即定义了上下文。本质上，命名空间就是定义了一个范围。特定命名： 然而，以上命名空间的函数前，都加了空间名，我们可以用using指令省去，即using namespace 空间名 就可以省去了，例： using namespace std; cout &lt;&lt; ‘小码之光’ &lt;&lt;endl; 而不是std::cout&#x2F;endl 嵌套命名 04 文件和流C++ 中另一个标准库 fstream，它定义了三个新的数据类型：以上三个理解：ofstream:out-file-stream写文件;ifstream:in-file-stream读文件;fstream:file-stream读写; 在从文件读取信息或者向文件写入信息之前，必须先打开文件。ofstream 和 fstream 对象都可以用来打开文件进行写操作，即需要先创建文件对象，如果只需要打开文件进行读操作，则使用 ifstream 对象。和c里的文件读取一样，c++也有打开模式。不过有点不同。 下面是 open() 函数的标准语法，open() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。 void open（文件名, ios::打开模式); 当 C++ 程序终止时，它会自动关闭刷新所有流，释放所有分配的内存，并关闭所有打开的文件。但程序员应该养成一个好习惯，在程序终止前关闭所有打开的文件。 close() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。 05 动态内存关键字new\\delete堆是程序中未使用的内存，在程序运行时可用于动态分配内存。使用new 运算符为给定类型的变量在运行时分配堆内的内存，这会返回所分配的空间地址。如果您不再需要动态分配的内存空间，可以使用 delete 运算符，删除之前由 new 运算符分配的内存。 数组对象 06 异常处理异常是程序在执行期间产生的问题。C++ 异常是指在程序运行时发生的特殊情况，比如尝试除以零的操作。 异常提供了一种转移程序控制权的方式。C++ 异常处理涉及到三个关键字：try、catch、throw。·································································································· throw: 当问题出现时，程序会抛出一个异常。这是通过使用 throw 关键字来完成的。 catch: 在您想要处理问题的地方，通过异常处理程序捕获异常。catch 关键字用于捕 获异常。 try: try 块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个 catch 块。···································································································· C++ 提供了一系列标准的异常，定义在 中，我们可以在程序中使用这些标准的异常。它们是以父子类层次结构组织起来的，如下所示：自定义异常 07 信号处理信号是由操作系统传给进程的中断，会提早终止一个程序。不是我们一般意义上的信号。这些信号是定义在 C++ 头文件csignal 。 C++ 信号处理库csignal提供了 signal 函数，用来捕获突发事件。signal函数 raise函数 08 多线程在高级语言编程里，总是会听到多线程，一些大厂面试也会提到多线程，那多线程有多厉害多神秘呢？ 这里又要扯上专业课了，多线程是多任务处理的一种特殊形式，多任务处理允许让电脑同时运行两个或两个以上的程序。一般情况下，两种类型的多任务处理：基于进程和基于线程。 基于进程的多任务处理是程序的并发执行。 基于线程的多任务处理是同一程序的片段的并发执行。 多线程程序包含可以同时运行的两个或多个部分。这样的程序中的每个部分称为一个线程，每个线程定义了一个单独的执行路径。通俗的说就是，计算机干活时候，将以一个进程为单位，处理一个要执行的程序，比如要打开的QQ，但不能一股脑把它干了，还有别的程序要运行呢。所以进程在内存上是间隔的，运行一个程序，计算机把很大的可执行文件分成若干部分去执行，每一部分以线程(都这么叫)的形式执行，这样就有了多线程处理。 创建线程： #include &lt;pthread.h&gt; pthread_create (thread, attr, start_routine, arg) ； 终止线程 使用下面的程序，我们可以用它来终止一个 POSIX 线程： #include &lt;pthread.h&gt;pthread_exit (status) ； 在这里，pthread_exit 用于显式地退出一个线程。通常情况下，pthread_exit() 函数是在线程完成工作后无需继续存在时被调用。如果 main() 是在它所创建的线程之前结束，并通过 pthread_exit() 退出，那么其他线程将继续执行。否则，它们将在 main() 结束时自动被终止 线程连接与分离 ·············································································································· 09 web编程 除了线程难以外，web编程学起来也很费劲，对初学者一点也不友好。所以在这里就不做过多累赘了。要学的太多了！就简单介绍一下公共网关接口（CGI），公共网关接口（CGI）是一套标准，定义了信息是如何在 Web 服务器和客户端脚本之间进行交换的，是一种用于外部网关程序与信息服务器（如 HTTP 服务器）对接的接口标准。如果要深入学习就寻找相关的书籍资料吧！(进公众号也行，问小码要哦，尽量帮你弄到， 写作不易，客官赏一个！) 更多尽在微信公众号:菜鸡干Java 推荐： 《Essential C++ 中文版》 《C++ Primer Plus 第6版中文版》 《C++ Primer中文版（第5版）》","categories":[{"name":"c/c++","slug":"c-c","permalink":"https://aachou.github.io/categories/c-c/"}],"tags":[{"name":"c++","slug":"c","permalink":"https://aachou.github.io/tags/c/"}],"author":"沧海一粟"},{"title":"c++对象？看看这个","slug":"c-对象","date":"2020-04-28T13:39:25.000Z","updated":"2023-08-09T10:20:32.000Z","comments":true,"path":"2020/0428/","permalink":"https://aachou.github.io/2020/0428/","excerpt":"深入理解c++面向对象几大特性 类 继承 重载 多态 数据抽象 数据封装 抽象类及实例化","text":"深入理解c++面向对象几大特性 类 继承 重载 多态 数据抽象 数据封装 抽象类及实例化 01 类类是 C++ 的核心特性，通常被称为用户定义的类型。也就是说，它和其他基本类型一样(浅显的这么说)，都是type。类定义是以关键字 class 开头，后跟类的名称。由类可以生成对象，这里，对象可以理解为变量，一种特殊类型的变量，相当于c语言中的struct结构体类型变量。 02 类成员函数类的成员函数是指那些把定义和原型写在类定义内部的函数，就像类定义中的其他变量一样。也可以在类的外部使用范围解析运算符 :: 定义该函数 需要强调一点，在 :: 运算符之前必须使用类名，调用成员函数是在对象上使用点运算符（.）。 03 类访问修饰符访问限制是通过在类主体内部对各个区域标记 public、private、protected 来指定的。关键字 public、private、protected 称为访问修饰符。 公有成员在程序中类的外部是可访问的(public)，即可以通过(对象.成员)或内部的public调用函数访问。 私有成员(private)则不同，那只能通过类内部的调用函数访问或修改，这时的内部public函数相当于链接类内外的桥梁，而不能用(对象.成员)去访问了，即便是继承了的子类(派生类)也不能这样调用私有成员。除了protected。 保护成员(protected)像私有成员一样，不能直接访问，需要使用内部函数，但区别就体现在继承的子类上，子类则可以直接通过(对象.成员)调用成员。 04 析构与构造函数类的构造函数是一种特殊的函数，在创建一个新的对象时调用。类的析构函数也是一种特殊的函数，在删除所创建的对象时调用。构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。类的析构函数是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行。 析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。 下面的实例有助于更好地理解析构函数的概念： 拷贝构造函数：拷贝构造函数，是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。 05 友元函数类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。友元可以是一个函数，该函数被称为友元函数；友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元。如果要声明函数为一个类的友元，需要在类定义中该函数原型前使用关键字 friend。 注意：友元函数不是类成员函数，但有很厉害的通行证，能访问所以成员，同时也不能被子类继承，要访问不能用(对象.函数)。 06 内联函数 通过内联函数，编译器试图在调用函数的地方扩展函数体中的代码。内联函数是通常与类一起使用。如果一个函数是内联的，那么在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。如果想把一个函数定义为内联函数，则需要在函数名前面放置关键字 inline，在调用函数之前需要对函数进行定义。如果已定义的函数多于一行，编译器会忽略 inline 限定符。引入内联函数的目的是为了解决程序中函数调用的效率问题，这么说吧，程序在编译器编译的时候，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体进行替换，而对于其他的函数，都是在运行时候才被替代。这其实就是个空间代价换时间的i节省。所以内联函数一般都是1-5行的小函数。在使用内联函数时要留神： 1.在内联函数内不允许使用循环语句和开关语句； 2.内联函数的定义必须出现在内联函数第一次调用之前； 07 this指针每一个对象都能通过 this 指针来访问自己的地址。this 指针是所有成员函数的隐含参数。因此，在成员函数内部，它可以用来指向调用对象。 this 指针是所有成员函数的隐含参数，即this已经事先定义好了，不用再声明了。友元函数没有 this 指针，因为友元不是类的成员。只有成员函数才有 this 指针。用法与c中结构体类似，指向对象。 08 指向类的指针指向类的指针方式如同指向结构的指针。实际上，类可以看成是一个带有函数的结构。访问指向类的指针的成员，需要使用成员访问运算符 -&gt;，就像访问指向结构的指针一样。与所有的指针一样，必须在使用指针之前，对指针进行初始化。 09 静态成员使用 static 关键字来把类成员定义为静态的。当我们声明类的成员为静态时，这意味着无论创建多少个类的对象，静态成员都只有一个副本。静态成员在类的所有对象中是共享的。如果不存在其他的初始化语句，在创建第一个对象时，所有的静态数据都会被初始化为零。我们不能把静态成员的初始化放置在类的定义中，但是可以在类的外部通过使用范围解析运算符 :: 来重新声明静态变量从而对它进行初始化。 10 继承创建一个类时，不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为基类，新建的类称为派生类。 如：class 继承类: 访问修饰符 基类； 11 多继承多继承即一个子类可以有多个父类，它继承了多个父类的特性。 C++ 类可以从多个类继承成员，语法如下： class &lt;派生类名&gt;:&lt;继承方式1&gt;&lt;基类名1&gt;,&lt;继承方式2&gt;&lt;基类名2&gt;,…{&lt;派生类类体&gt;}; 12 函数重载在同一个作用域内，可以声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同。不能仅通过返回类型的不同来重载函数。 13 运算符重载重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。成员运算符重载： Box operator+(const Box&amp;); 声明加法运算符用于把两个 Box 对象相加，返回最终的 Box 对象。大多数的重载运算符可被定义为普通的非成员函数或者被定义为类成员函数。如果我们定义上面的函数为类的非成员函数，那么我们需要为每次操作传递两个参数，那这样子类也不能继承，如下所示： Box operator+(const Box&amp;, const Box&amp;); 重载决策：上面的print()函数用了3次，仔细看都是不一样类型的参数，接下来在主函数main里调用了3次，所以内部有一个重载决策机制判断输入的参数类型该定义哪一个函数后调用。 14 多态就是多种形态。当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。C++ 多态意味着调用成员函数(即使成员函数名相同)时，会根据调用函数的对象的类型(意味着在基类上产生了不同的派生类)来执行不同的函数。 15 数据抽象与封装数据抽象是指，只向外界提供关键信息，并隐藏其后台的实现细节，即只表现必要的信息而不呈现细节。数据抽象是一种依赖于接口和实现分离的编程（设计）技术。C++ 类为数据抽象提供了可能。它们向外界提供了大量用于操作对象数据的公共方法，也就是说，外界实际上并不清楚类的内部实现。使用类来定义我们自己的抽象数据类型（ADT），可以使用类 iostream 的 cout 对象来输出数据到标准输出，而不需要知道如何实现。说简单点就是要用到接口之类的，从而来方便调用操作数据。 数据封装是一种把数据和操作数据的函数捆绑在一起的机制，数据抽象是一种仅向用户暴露接口而把具体的实现细节隐藏起来的机制。C++ 通过创建类来支持封装和数据隐藏（public、protected、private）。 16 抽象类C++ 接口是使用抽象类来实现的，如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。纯虚函数是通过在声明中使用 “&#x3D; 0” 来指定的，如下所示：class Box{ public: &#x2F;&#x2F; 纯虚函数 virtual double getVolume() &#x3D; 0; private: double length; &#x2F;&#x2F; 长度 double breadth; &#x2F;&#x2F; 宽度 double height; &#x2F;&#x2F; 高度}; 设计抽象类（通常称为 ABC）的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。如果试图实例化一个抽象类的对象，会导致编译错误。 因此，如果一个 ABC 的子类需要被实例化，则必须实现每个虚函数，这也意味着 C++ 支持使用 ABC 声明接口。如果没有在派生类中重写纯虚函数，就尝试实例化该类的对象，会导致编译错误。可用于实例化对象的类被称为具体类。 说白了，这术语本质上就是个接口，以供调用。这些人说的这么高大上，最后把大家都弄晕了。好了以上就是给大家一个柳暗花明，希望有帮助在学习c++的路上！ 最后附上：小码csdn 微信公众号：小码之光","categories":[{"name":"c/c++","slug":"c-c","permalink":"https://aachou.github.io/categories/c-c/"}],"tags":[{"name":"c++","slug":"c","permalink":"https://aachou.github.io/tags/c/"},{"name":"面向对象","slug":"面向对象","permalink":"https://aachou.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}],"author":"沧海一粟"},{"title":"还要翻Qiang？试试这个","slug":"还要翻墙？试试这个","date":"2020-04-27T00:17:52.000Z","updated":"2023-08-09T10:20:03.000Z","comments":true,"path":"2020/0427/","permalink":"https://aachou.github.io/2020/0427/","excerpt":"想看看国外的风光吗？疫情期间就像挂在家的咸鱼一样，快发酵了！点开浏览器","text":"想看看国外的风光吗？疫情期间就像挂在家的咸鱼一样，快发酵了！点开浏览器，可是只能在国内的网站上静静地划过，没有一点新鲜事。可是想上外网又被墙，怎么办？ 哈哈!客官别着急，我这就给您上‘菜’。咱们开了浏览器，最好是火狐的，在设置里的附加组件中的扩展里搜索谷歌上网助手Ghelper(在插件商店里也行) 接下来很简单，添加这个插件就行了，添加如下 on开启上网策略，在这之前需要配置隐私设置。找到该插件，点击管理，允许在隐私窗口运行即可。 12345客官：太好了！！！！！小码：先别太过于兴奋，咱们先试试看，到底能不能上像youtube这样的外网。客官：那好，快试试！ 行啦！！（可能需要验证邮件）没问题！不过是走日本的线路，所以才有日语，可以换换别的，就有别的语言选择。 123客官：嗯，不错！开动！小码：莫急，咱再试试！ 进入face看看，来到了奥巴马的主页。。。。 又进入了 1​客官：你tm又个P啊！开动！开动！ 小码：好的好的，喜欢的话就关注我哦！哈哈！blog：小码blog 微信公众号：小码之光","categories":[{"name":"碎碎念","slug":"碎碎念","permalink":"https://aachou.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}],"tags":[{"name":"ghelper","slug":"ghelper","permalink":"https://aachou.github.io/tags/ghelper/"}],"author":"沧海一粟"},{"title":"virtualbox虚拟机安装","slug":"virtualbox虚拟机安装","date":"2020-04-25T04:43:02.000Z","updated":"2023-08-09T10:16:57.000Z","comments":true,"path":"2020/0425/","permalink":"https://aachou.github.io/2020/0425/","excerpt":"用虚拟机virtualbox安装ubantu桌面系统 下载ubantu镜像 下载安装虚拟机 新建一个虚拟电脑Linux01 安装ubantu镜像 （网络设置）","text":"用虚拟机virtualbox安装ubantu桌面系统 下载ubantu镜像 下载安装虚拟机 新建一个虚拟电脑Linux01 安装ubantu镜像 （网络设置） 01 下载ubantu镜像要想在虚拟机里玩ubantu，就要先准备好该系统的iso镜像文件，那么我们就直接到了官网去了 可是我们点击下载后速度又慢了，比github还慢，原因就不说了。所以当然有更快的方法啦！不一定非要去国外的官网下载，国内的各大高校和巨头都有镜像站提供免费的镜像下载，这里就给大家推荐一番。 阿里云开发者社区镜像站第一个就是ubantu,这里可以下server或desktop都可以，反正又快又免费！哈哈 浙大镜像站 为什么选择浙江大学的镜像站呢？国内有很多这样的镜像站啊。。。。当然是快啦，相比较其他大学的站点，算是比较好了。 我是在阿里云下的，起初弄不清server和desktop版，就先下了server版，结果就是疑惑了半天，也没出现漂亮的界面。 02 安装oracle virtualbox虚拟机这个就有点难下了，我没在镜像站里找，在网盘下的。(VMware需要许可证)这里大家可以搜一搜，分享VM 提取码：vz1h 下载好安装包后，打开就行了 03 新建虚拟电脑Linux01点击新建，选择要安装的系统，之后就是一路默认。 内存最好配置在2G以上 04 安装ubantu镜像虽然已经有一个虚拟电脑了(其实就是占用宿主机的磁盘空间)，这个时候只有硬件上的支持，还没有系统文件的调用。所以咋们进入启动Vbox界面的设置项 红色箭头那点击进入，再点击注册项，即可从宿主机文件里选择下载好的ubantu镜像文件 ok,配置好后，再启动虚拟电脑，就进入ubantu系统安装界面了，而不是命令行。 1接下来就是安装了 这里可以选择试用或者安装ubantu，安装后启动就直接进入虚拟电脑工作界面了。 界面还是很漂亮的，不过virtualbox是小型机，界面不能全屏，如果可能还是选VMware虚拟机吧，试过，感觉就是香！哈哈！ 05 网络设置 这里就不过多讲了，建好后可以配置网络，有自己的cdn节点。推荐程序羊","categories":[{"name":"linux","slug":"linux","permalink":"https://aachou.github.io/categories/linux/"}],"tags":[{"name":"ubantu","slug":"ubantu","permalink":"https://aachou.github.io/tags/ubantu/"},{"name":"virtualbox虚拟机","slug":"virtualbox虚拟机","permalink":"https://aachou.github.io/tags/virtualbox%E8%99%9A%E6%8B%9F%E6%9C%BA/"}],"author":"沧海一粟"},{"title":"gitpage CDN加速配置与深入","slug":"gitpage-CDN加速深入","date":"2020-04-21T04:09:58.000Z","updated":"2023-08-09T10:20:27.000Z","comments":true,"path":"2020/0421/","permalink":"https://aachou.github.io/2020/0421/","excerpt":"","text":"github page cdn加速服务深入了解 CDN介绍 CDN提供商 github page cdn加速服务配置 CDN加速服务深入 CDN介绍CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术….. 上面是百度的介绍，啰嗦了一大堆，说白了就是让坐在电脑前的用户就近的获取需要的网络资源，而不用跑去访问遥远的服务器了。既然这么好，那就用呗！国内外都有一些这样的CDN服务提供商，但是大家都知道，访问外面的网络很费劲的。国内的一些CDN提供商也有不少，服务也不错，就给大家推荐一下。 CDN提供商阿里云CDN&#x2F;DCDN全站加速阿里云的CDN加速服务应该算是不错了，支持国内外和全球加速，这里选择全站加速会比较好一点。 腾讯云CDN巨头们总是这么滴强。。。腾讯云内同样提供比较哟西的CDN加速服务，提供商不一样，可能CDN操作的流程会略有不同。 又拍云CDN又拍云服务提供商也还行吧，反正试了下没啥效果，这里最好在域名提供商哪里选择CDN服务。 Github page cdn配置在没有CDN的时候是这样的火红的大火鸡，非常差的访问去访问github节点。之后我选择阿里云的CDN去加速访问，在这之前可能要准备一个域名来操作啦。 现在我们进入阿里云的CDN，在域名管理处添加要加速的域名，如’www.maliaoblog.cn&#39;,这时候会提示没有备案，不用管，继续操作。在源站信息配置上，有三种选择，分别是OSS，域名，IP，如果你还填要加速的域名的话，显然会有重定向的麻烦，所以这里的源站在阿里云帮助文档里就讲了，源站就是github page服务器的域名或IP地址，这里还没有涉及到回源host的设置，大家尽管放心操作。之后在端口处选择443端口（以https协议访问，需要添加Https证书，如SSL的），加速区域选不包含中国大陆的，即海外节点加速，最后点击下一步。 到这里基本上就完成了，返回的时候刷新一下，能看到CNAME地址！需要在域名解析到这个CNAME地址。 只有解析到这个CNAME地址后，过几分钟，阿里云才能进行CDN加速服务。之后以这个加速域名去测速，速度就会提升了。注意，是以这个加速了的域名访问，那访问的就是阿里云帮我们提供的CDN节点，那当然会更快啦。 CDN加速服务深入其实也没有多大的深入，就是在弄明白一个问题：github page还需要自定义域名吗？我们加没加速对博客站点的访问？ ping了一下，没加速对github.io的访问github.io为美国的节点，直接访问当然没多快呀，如果ping加速域名的话，会访问阿里美国的CDN的节点，如果要回源的话，访问的请求会从节点发送出去。这就等于加速了从电脑前的客户所在地到节点该段的速度，走的是访问CDN节点的路线。 接着我再以加速域名测速，肯定是红色少了 访问请求最终还是要得到最后的服务器的回应，也就是给我们网页资源。为此我又进行了测试。 路由测试 DNS测试如果加速域名DNS解析到github.io的话，github.io又有节点，那整个访问就快了。真的是这样的吗？还要不要.io自定义域名呢？page通过产生的github.io就可以访问到博客，自定义域名只是放到另一个展示(published)的地方(site)，那既然我们需要买域名去覆盖，那就要解析一个到github.io的CNAME的记录了。这么多，浏览器可能产生重定向的问题，以至于要不断刷新页面。但可以用一下，至少不要跑老远去DNS解析，输入域名，浏览器就老老实实交出页面啦。小码CSDN博客","categories":[{"name":"网站运维","slug":"网站运维","permalink":"https://aachou.github.io/categories/%E7%BD%91%E7%AB%99%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"gitpage","slug":"gitpage","permalink":"https://aachou.github.io/tags/gitpage/"}],"author":"沧海一粟"},{"title":"连接远程服务器出现乱码","slug":"连接远程服务器出现乱码","date":"2020-04-19T14:27:06.000Z","updated":"2023-08-09T10:20:20.000Z","comments":true,"path":"2020/0419/","permalink":"https://aachou.github.io/2020/0419/","excerpt":"连接远程服务器后出现命令行乱码真是巧了，最近遇到的事儿净跟编码有关，好像中了毒一样。话不多说，看乱码。","text":"连接远程服务器后出现命令行乱码真是巧了，最近遇到的事儿净跟编码有关，好像中了毒一样。话不多说，看乱码。大家已经看到了，连上服务器后的写个文件的目录命令，就只拉出了四个字，呃，不对，还有一个零蛋。好，这种乱码现象其实已经多见少怪了，然而还是有原因的，不然我怎么会写个博客记录一下。值得注意的就是在命令行出现乱码的情况很少，还是敲了命令之后，何况有的小伙伴还不熟悉linux系统的操作，更不知道怎么办了。慌了手脚，求救网页标签都打开了好几个，还是不知道咋弄，于是小伙伴只好四下求救大佬。今天我就带大家一块干了。。 so 到了面对编码的时候了 大家还记得上次讲过的编码格式问题吧，这次就不是转成Ansy格式了，要在secureCRT把编码格式转成utf-8格式，为什么呢？因为默认的secureCRT命令行不是utf-8,也不是中文字符集，所以就要改一改。如果小伙伴用的是中文破解版的，点击菜单栏中选择里会话选项，英文为option,界面如下，在外观(appearance)那里的字符编码选择那选择utf-8 字体选择自己喜欢的，但是要中文字符集gb2312 OK啦，解决问题啦，就有如下对比 这样就顺顺利利地干了它了，哈哈，心里是不是很爽啊。如果大家对界面背景不满意同样可以调节，比如背景为黑色，命令前景为白色或黑客绿(瞎装逼色)，看图 如果小伙伴还弄不明白，那只能献上本人亲自为大家制作的动图了（不信你看不懂） 好啦，以上就是小码码的学习心得，希望对大家有帮助，喜欢的话就点赞，留言哦，哈哈。附小码码官方博客","categories":[{"name":"linux","slug":"linux","permalink":"https://aachou.github.io/categories/linux/"}],"tags":[{"name":"问题","slug":"问题","permalink":"https://aachou.github.io/tags/%E9%97%AE%E9%A2%98/"},{"name":"linux","slug":"linux","permalink":"https://aachou.github.io/tags/linux/"}],"author":"沧海一粟"},{"title":"matery主题优化问题","slug":"matery主题优化问题","date":"2020-04-09T12:32:23.000Z","updated":"2023-08-09T10:20:11.000Z","comments":true,"path":"2020/0409/","permalink":"https://aachou.github.io/2020/0409/","excerpt":"matery主题优化时解析出bug matery是个好的主题这个我就不详细地说了，但是优化也难 越好的主题、越丰富的主题，插件越多，配置越多，就容易出错 最要命的是这种静态网页的部署还要用最原始的方法进行，先在命令行生成静态文件，然后发送给要命的github 总之bug数不胜数，大部分出错的原因基本都一致，无非就是在yml文件里乱弄出的bug 但是我优化主题时碰上了难得的bug，就分享给大家，省的大家走弯路","text":"matery主题优化时解析出bug matery是个好的主题这个我就不详细地说了，但是优化也难 越好的主题、越丰富的主题，插件越多，配置越多，就容易出错 最要命的是这种静态网页的部署还要用最原始的方法进行，先在命令行生成静态文件，然后发送给要命的github 总之bug数不胜数，大部分出错的原因基本都一致，无非就是在yml文件里乱弄出的bug 但是我优化主题时碰上了难得的bug，就分享给大家，省的大家走弯路 page.*.ForEach is not a function后接一大片路径这里的*就是图中的categorioes,我叫他page bug。就光看那么多行根本摸不着头脑，想着是肯定是配置出了问题，于是就打开配置文件查看。其实这个问题很少见，一般都不是config配置文件的问题。弄了半天，谁也没想到是页面文件categorioes里的index.md文件有问题。我的配置如下：一般都很少进入里面配置什么的，但是为了优化主题，让它更好看，就进入里面瞎搞乱改，网上也没什么指导如何优化配置的好文章，所以自然会遇到稀奇bug。上面的配置就出错了，出在categorioes的属性的配置，用这个主题，categories文件(需要事先new一个才有)好像不准添加属性，换成小写c也不行，之后做了如下更改。 去掉那个C后，那个bug就没了，一切顺畅生成页面。四不四很无语，就这个鬼东西弄了一整天，不是说，就是这个静态页面配置太苛刻了，用md和yml去写，缩进不对都是要出错的。这给广大怀着博客梦的IT客破了一大盆冷水，太难了！ 我还试了在其他页面文件中的md文件里设置categories属性，结果都🆗。。。 tags文件里md文件配置了没问题,我是说categorioes属性，图片里没有，配置tags属性也没事(没打双引号都没事)。 1那到底是什么样的优化造成的魔王级的bug呢？ hexo主题本来就不会自带页面的配置优化，需要自己弄，就matery来说吧，除了归档页面，其他的页面都不会出现和用这个主题的人一样相似布局，所以接下来就告诉大家怎么弄。 1234就是在index.md文件里配置，只需添加如下几行：在categories里：type: &#x27;categories&#x27; layout: &#x27;categories&#x27; (注意：后空格)其他类推 这样在各个页面就有自己配置了，如下 这是弄好了友链页面后的效果，能看到基本上是有个排版了。但框框内却出现了乱码，很巧的是出现乱码的地方都是汉字该出现的地方。所以大家应该知道了，又是编码的问题。这次我们还用notepad++更改编码友链的josn格式,如果没有notepad++或不知道如何更改编码格式，请参考批处理文件编码出错原来友链的josn的编码格式为Ansi,我们需要utf-8格式。欧克，行了，如下： 谈谈hexohexo这样的博客虽然用了很流行的框架，但部署起来还是很费劲，就是用上去很费劲，powerful的博客框架还是太少了，什么都追求免费服务，哪有这么样的好事，这就导致了开发出优质的框架的人太少了。现在大牛的程序员都快是古董，做个IT技术更倾向于商业化，应用型。以上就是分享，另附个人博客","categories":[{"name":"网站运维","slug":"网站运维","permalink":"https://aachou.github.io/categories/%E7%BD%91%E7%AB%99%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"优化","slug":"优化","permalink":"https://aachou.github.io/tags/%E4%BC%98%E5%8C%96/"},{"name":"bug问题","slug":"bug问题","permalink":"https://aachou.github.io/tags/bug%E9%97%AE%E9%A2%98/"}],"author":"沧海一粟"},{"title":"解决执行批处理文件后出现的问题","slug":"解决执行批处理文件后出现的问题","date":"2020-04-06T10:35:45.000Z","updated":"2023-08-09T10:19:55.000Z","comments":true,"path":"2020/0406/","permalink":"https://aachou.github.io/2020/0406/","excerpt":"执行批处理文件后出现的乱码问题用windows批处理总是很放便的，特便是在抢时间的情况下用批处理开启程序，运行大量命令等等。","text":"执行批处理文件后出现的乱码问题用windows批处理总是很放便的，特便是在抢时间的情况下用批处理开启程序，运行大量命令等等。但对于刚接触的新手来说，可能是一件费劲的事！有时候还会遇到问题，比如今天要讲的执行批处理文件后出现的乱码问题。如下图：文件里的命令的意思就是在命令行输出“垃圾快跑”四个字，然后运行后如下 运行后出现的“致富喽”几个字。。。其实我也不知道是什么字。接着面对乱码的问题，大家想一想就明白估计是文件的编码格式出了问题，强调一下啊，是编码格式。在这里就要讲一个东西，就是windows的cmd命令行本身用的是Ansi编码，但用记事本打开或者说文件本身的编码其实不是Ansi编码，有可能是Utf-8。那这里就有两种解决方法。 一、使用notepad++转换编码格式 既然要用到notepad++，相信大家应该不会陌生，notepad++功能强大，可以说比sublime text好用，这里之所以不推荐sublime text，是因为它没有编码格式的转换功能，甚至没有Ansi格式的编码，最后建议选择notepad++。考虑到有人没用过，下面就送上notepad++的网盘下载地址：notepad++下载 提取码：xnl1 notepad++支持多种语法高亮和编码及文件兼容，是程序哥的必备良器。打开notepad++后，默认为utf-8格式，点击文件，选择打开，选择你要打开的批处理文件，看到菜单栏的编码选项(已经很醒目了)，之后点击编码，选择转换为Ansi格式，再在文件选项中点击保存。 在命令行后执行或直接点开批处理文件，解决乱码了 二、另存为 用记事本打开bat文件后，选择另存为，之后点击选择Ansi格式编码，同样能解决问题。 打开运行批处理文件后，就没出现过乱码啦。 以上就是解决类似问题的几个方法，可以的话就留言评论，希望大家多多留言哦。","categories":[{"name":"windows","slug":"windows","permalink":"https://aachou.github.io/categories/windows/"}],"tags":[{"name":"问题","slug":"问题","permalink":"https://aachou.github.io/tags/%E9%97%AE%E9%A2%98/"}],"author":"沧海一粟"},{"title":"用C语言实现链表","slug":"用C语言实现链表","date":"2020-04-05T01:40:19.000Z","updated":"2023-08-09T10:19:48.000Z","comments":true,"path":"2020/0405/","permalink":"https://aachou.github.io/2020/0405/","excerpt":"用C语言实现链表，附代码注释这里给已经在学C和数据结构的小伙伴提供一些弹药支持，虽然不知道管不管用，在这里大佬就勿扰了吧！哈哈！","text":"用C语言实现链表，附代码注释这里给已经在学C和数据结构的小伙伴提供一些弹药支持，虽然不知道管不管用，在这里大佬就勿扰了吧！哈哈！ 在实现一个简单的链表前需要用到哪些知识点呢？ C语言基础知识，比如要用到的结构体、指针、函数、运算 一点数据结构的知识，在学习数据结构也能看到链表的身影，我们这里实现的是单项链表 有手，有脑 现在上代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# include&lt;stdio.h&gt;# include&lt;malloc.h&gt;//创造链表 //定义一个节点类型typedef struct node&#123; int data; char name[10]; struct node *next;&#125;noDe,* pnoDe; // 输入函数 pnoDe funkin(void)&#123; pnoDe pHead = (pnoDe)malloc(sizeof(noDe)); //定义头指针和尾指针分别指向头和尾节点 pnoDe ptail = pHead; ptail-&gt;next = NULL; int n,score; //有效节点的数量 char name[10]; printf(&quot;please funkin a number:&quot;); scanf(&quot;%d&quot;,&amp;n); // 连续输入学生及成绩数据 for(int i=0;i&lt;n;i++)&#123; pnoDe pNew = (pnoDe)malloc(sizeof(noDe)); printf(&quot;please scanf the score of number %d :&quot;,i+1); scanf(&quot;%d %s&quot;,&amp;(pNew-&gt;data),pNew-&gt;name); /*核心代码*/ ptail-&gt;next = pNew; //让尾节点指针指向新节点 ptail = pNew; //让尾指针指向新节点 ,并移动到下一个节点 ptail-&gt;next = NULL; //让新节点指针域为空 &#125; return pHead;&#125; // 输出函数 void out(pnoDe pHead)&#123; int k = 1; pnoDe p = pHead-&gt;next; while(p != NULL)&#123; printf(&quot;\\nfunkout number %d: &quot;,k); printf(&quot;score= %d\\nname= %s\\n&quot;,p-&gt;data,p-&gt;name); p = p-&gt;next; k++; &#125; return;&#125;int main(void)&#123; pnoDe pHead = NULL; pHead = funkin(); out(pHead); return 0; &#125; 代码并不难懂，大概就是先输入需要创建的节点数或有效数据个数，之后创建了一个会构造链表的函数，并返回头指针。这个时候链表其实已经创建好了，并且已经放入了数据。之后，输出函数out()会输出数据。ok，就是这么简单！觉得可以就点赞加关注，博主会定期更新哦！哈！最后附上个人博客链接：csdn博客","categories":[{"name":"编程","slug":"编程","permalink":"https://aachou.github.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"c","slug":"c","permalink":"https://aachou.github.io/tags/c/"}],"author":"沧海一粟"},{"title":"致访客","slug":"致过去和未来","date":"2020-03-27T04:01:39.000Z","updated":"2023-08-09T10:18:27.000Z","comments":true,"path":"2020/0327/","permalink":"https://aachou.github.io/2020/0327/","excerpt":"这是经过多天努力的结果，这个站点就界面来说，不怎么酷炫。","text":"这是经过多天努力的结果，这个站点就界面来说，不怎么酷炫。但是是我一直想做的东西–建一个与众不同的个人网站，每天可以像发微博一样自由地推送我写好的博客文章。对于maliaoblog.cn，我很珍惜能拥有它，还是经过自己的不断尝试，一点一点地做出来的，就如心血的结晶。 来访I&#39;m so proud for your visit!我想说，感谢你能来见证我博客的诞生，正因为有你的加入，才能有我的博客的成长。以后大家可以通过我的博客官网看到我最新的动态，我会在这个站点和你面对面。 关于博客博客会不定期更新，我会不断的努力写出好的文章作品。 为什么叫maliaoblog可能因为马里奥比较出名吧！作为产码达人，一定要起一个好名字。 以后站点会变换吗？可能吧！但现在算是比较稳定了，起初，我想在站点加入更多功能插件，可是条件限制各方面因素，就只能到这！另外博客的站点是建在外网的，所以访问比较慢！这里就体谅一下吧！一个人建站比较幸苦的。 加油！毕竟建站不是我最终的想法，想着继续努力地学习成长，以后拥有更加幸福的生活。","categories":[{"name":"程序人生","slug":"程序人生","permalink":"https://aachou.github.io/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"}],"tags":[{"name":"博客简介","slug":"博客简介","permalink":"https://aachou.github.io/tags/%E5%8D%9A%E5%AE%A2%E7%AE%80%E4%BB%8B/"}],"author":"沧海一粟"}],"categories":[{"name":"java","slug":"java","permalink":"https://aachou.github.io/categories/java/"},{"name":"mysql","slug":"mysql","permalink":"https://aachou.github.io/categories/mysql/"},{"name":"linux","slug":"linux","permalink":"https://aachou.github.io/categories/linux/"},{"name":"git","slug":"git","permalink":"https://aachou.github.io/categories/git/"},{"name":"docker","slug":"docker","permalink":"https://aachou.github.io/categories/docker/"},{"name":"虚拟机","slug":"虚拟机","permalink":"https://aachou.github.io/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"碎碎念","slug":"碎碎念","permalink":"https://aachou.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"},{"name":"机器学习","slug":"机器学习","permalink":"https://aachou.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"项目","slug":"项目","permalink":"https://aachou.github.io/categories/%E9%A1%B9%E7%9B%AE/"},{"name":"Java","slug":"Java","permalink":"https://aachou.github.io/categories/Java/"},{"name":"网站运维","slug":"网站运维","permalink":"https://aachou.github.io/categories/%E7%BD%91%E7%AB%99%E8%BF%90%E7%BB%B4/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://aachou.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"数据结构","slug":"数据结构","permalink":"https://aachou.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"https://aachou.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"问题","slug":"问题","permalink":"https://aachou.github.io/categories/%E9%97%AE%E9%A2%98/"},{"name":"SQL","slug":"SQL","permalink":"https://aachou.github.io/categories/SQL/"},{"name":"c/c++","slug":"c-c","permalink":"https://aachou.github.io/categories/c-c/"},{"name":"IDE","slug":"IDE","permalink":"https://aachou.github.io/categories/IDE/"},{"name":"windows","slug":"windows","permalink":"https://aachou.github.io/categories/windows/"},{"name":"编程","slug":"编程","permalink":"https://aachou.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"程序人生","slug":"程序人生","permalink":"https://aachou.github.io/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"}],"tags":[{"name":"WSL","slug":"WSL","permalink":"https://aachou.github.io/tags/WSL/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://aachou.github.io/tags/Ubuntu/"},{"name":"windows","slug":"windows","permalink":"https://aachou.github.io/tags/windows/"},{"name":"博客","slug":"博客","permalink":"https://aachou.github.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"线程池","slug":"线程池","permalink":"https://aachou.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"},{"name":"多线程","slug":"多线程","permalink":"https://aachou.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"线程通信","slug":"线程通信","permalink":"https://aachou.github.io/tags/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/"},{"name":"IO流","slug":"IO流","permalink":"https://aachou.github.io/tags/IO%E6%B5%81/"},{"name":"NIO","slug":"NIO","permalink":"https://aachou.github.io/tags/NIO/"},{"name":"java","slug":"java","permalink":"https://aachou.github.io/tags/java/"},{"name":"IO流体系","slug":"IO流体系","permalink":"https://aachou.github.io/tags/IO%E6%B5%81%E4%BD%93%E7%B3%BB/"},{"name":"反射","slug":"反射","permalink":"https://aachou.github.io/tags/%E5%8F%8D%E5%B0%84/"},{"name":"类加载","slug":"类加载","permalink":"https://aachou.github.io/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD/"},{"name":"注解","slug":"注解","permalink":"https://aachou.github.io/tags/%E6%B3%A8%E8%A7%A3/"},{"name":"泛型","slug":"泛型","permalink":"https://aachou.github.io/tags/%E6%B3%9B%E5%9E%8B/"},{"name":"集合","slug":"集合","permalink":"https://aachou.github.io/tags/%E9%9B%86%E5%90%88/"},{"name":"工具类","slug":"工具类","permalink":"https://aachou.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"name":"Map集合","slug":"Map集合","permalink":"https://aachou.github.io/tags/Map%E9%9B%86%E5%90%88/"},{"name":"List","slug":"List","permalink":"https://aachou.github.io/tags/List/"},{"name":"Queue","slug":"Queue","permalink":"https://aachou.github.io/tags/Queue/"},{"name":"Set集合","slug":"Set集合","permalink":"https://aachou.github.io/tags/Set%E9%9B%86%E5%90%88/"},{"name":"接口","slug":"接口","permalink":"https://aachou.github.io/tags/%E6%8E%A5%E5%8F%A3/"},{"name":"集合类","slug":"集合类","permalink":"https://aachou.github.io/tags/%E9%9B%86%E5%90%88%E7%B1%BB/"},{"name":"遍历集合","slug":"遍历集合","permalink":"https://aachou.github.io/tags/%E9%81%8D%E5%8E%86%E9%9B%86%E5%90%88/"},{"name":"构造器重载","slug":"构造器重载","permalink":"https://aachou.github.io/tags/%E6%9E%84%E9%80%A0%E5%99%A8%E9%87%8D%E8%BD%BD/"},{"name":"初始化块","slug":"初始化块","permalink":"https://aachou.github.io/tags/%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9D%97/"},{"name":"静态初始化块","slug":"静态初始化块","permalink":"https://aachou.github.io/tags/%E9%9D%99%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9D%97/"},{"name":"变量分类","slug":"变量分类","permalink":"https://aachou.github.io/tags/%E5%8F%98%E9%87%8F%E5%88%86%E7%B1%BB/"},{"name":"自动装拆箱","slug":"自动装拆箱","permalink":"https://aachou.github.io/tags/%E8%87%AA%E5%8A%A8%E8%A3%85%E6%8B%86%E7%AE%B1/"},{"name":"继承","slug":"继承","permalink":"https://aachou.github.io/tags/%E7%BB%A7%E6%89%BF/"},{"name":"组合","slug":"组合","permalink":"https://aachou.github.io/tags/%E7%BB%84%E5%90%88/"},{"name":"单例类","slug":"单例类","permalink":"https://aachou.github.io/tags/%E5%8D%95%E4%BE%8B%E7%B1%BB/"},{"name":"不可变类","slug":"不可变类","permalink":"https://aachou.github.io/tags/%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%B1%BB/"},{"name":"String","slug":"String","permalink":"https://aachou.github.io/tags/String/"},{"name":"BigDecimal","slug":"BigDecimal","permalink":"https://aachou.github.io/tags/BigDecimal/"},{"name":"java异常","slug":"java异常","permalink":"https://aachou.github.io/tags/java%E5%BC%82%E5%B8%B8/"},{"name":"多态","slug":"多态","permalink":"https://aachou.github.io/tags/%E5%A4%9A%E6%80%81/"},{"name":"抽象","slug":"抽象","permalink":"https://aachou.github.io/tags/%E6%8A%BD%E8%B1%A1/"},{"name":"hexo-inject","slug":"hexo-inject","permalink":"https://aachou.github.io/tags/hexo-inject/"},{"name":"git","slug":"git","permalink":"https://aachou.github.io/tags/git/"},{"name":"matery","slug":"matery","permalink":"https://aachou.github.io/tags/matery/"},{"name":"美化","slug":"美化","permalink":"https://aachou.github.io/tags/%E7%BE%8E%E5%8C%96/"},{"name":"sakura","slug":"sakura","permalink":"https://aachou.github.io/tags/sakura/"},{"name":"博客园","slug":"博客园","permalink":"https://aachou.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"},{"name":"matery主题","slug":"matery主题","permalink":"https://aachou.github.io/tags/matery%E4%B8%BB%E9%A2%98/"},{"name":"音乐播放器","slug":"音乐播放器","permalink":"https://aachou.github.io/tags/%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/"},{"name":"博客美化","slug":"博客美化","permalink":"https://aachou.github.io/tags/%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://aachou.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"网络模型","slug":"网络模型","permalink":"https://aachou.github.io/tags/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/"},{"name":"TCP/IP","slug":"TCP-IP","permalink":"https://aachou.github.io/tags/TCP-IP/"},{"name":"内部类","slug":"内部类","permalink":"https://aachou.github.io/tags/%E5%86%85%E9%83%A8%E7%B1%BB/"},{"name":"数据结构","slug":"数据结构","permalink":"https://aachou.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"栈","slug":"栈","permalink":"https://aachou.github.io/tags/%E6%A0%88/"},{"name":"队列","slug":"队列","permalink":"https://aachou.github.io/tags/%E9%98%9F%E5%88%97/"},{"name":"浏览器","slug":"浏览器","permalink":"https://aachou.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"搜索引擎","slug":"搜索引擎","permalink":"https://aachou.github.io/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"},{"name":"互质","slug":"互质","permalink":"https://aachou.github.io/tags/%E4%BA%92%E8%B4%A8/"},{"name":"最小公倍数","slug":"最小公倍数","permalink":"https://aachou.github.io/tags/%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/"},{"name":"算法","slug":"算法","permalink":"https://aachou.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"递推","slug":"递推","permalink":"https://aachou.github.io/tags/%E9%80%92%E6%8E%A8/"},{"name":"算法复杂度","slug":"算法复杂度","permalink":"https://aachou.github.io/tags/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"name":"开源","slug":"开源","permalink":"https://aachou.github.io/tags/%E5%BC%80%E6%BA%90/"},{"name":"IDEA","slug":"IDEA","permalink":"https://aachou.github.io/tags/IDEA/"},{"name":"语法","slug":"语法","permalink":"https://aachou.github.io/tags/%E8%AF%AD%E6%B3%95/"},{"name":"eladmin","slug":"eladmin","permalink":"https://aachou.github.io/tags/eladmin/"},{"name":"项目","slug":"项目","permalink":"https://aachou.github.io/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"SQLserver","slug":"SQLserver","permalink":"https://aachou.github.io/tags/SQLserver/"},{"name":"moneykeeper","slug":"moneykeeper","permalink":"https://aachou.github.io/tags/moneykeeper/"},{"name":"c","slug":"c","permalink":"https://aachou.github.io/tags/c/"},{"name":"疫情","slug":"疫情","permalink":"https://aachou.github.io/tags/%E7%96%AB%E6%83%85/"},{"name":"equals","slug":"equals","permalink":"https://aachou.github.io/tags/equals/"},{"name":"idea","slug":"idea","permalink":"https://aachou.github.io/tags/idea/"},{"name":"c++","slug":"c","permalink":"https://aachou.github.io/tags/c/"},{"name":"面向对象","slug":"面向对象","permalink":"https://aachou.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"ghelper","slug":"ghelper","permalink":"https://aachou.github.io/tags/ghelper/"},{"name":"ubantu","slug":"ubantu","permalink":"https://aachou.github.io/tags/ubantu/"},{"name":"virtualbox虚拟机","slug":"virtualbox虚拟机","permalink":"https://aachou.github.io/tags/virtualbox%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"gitpage","slug":"gitpage","permalink":"https://aachou.github.io/tags/gitpage/"},{"name":"问题","slug":"问题","permalink":"https://aachou.github.io/tags/%E9%97%AE%E9%A2%98/"},{"name":"linux","slug":"linux","permalink":"https://aachou.github.io/tags/linux/"},{"name":"优化","slug":"优化","permalink":"https://aachou.github.io/tags/%E4%BC%98%E5%8C%96/"},{"name":"bug问题","slug":"bug问题","permalink":"https://aachou.github.io/tags/bug%E9%97%AE%E9%A2%98/"},{"name":"博客简介","slug":"博客简介","permalink":"https://aachou.github.io/tags/%E5%8D%9A%E5%AE%A2%E7%AE%80%E4%BB%8B/"}]}