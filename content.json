{"meta":{"title":"Hawke Blog","subtitle":"","description":"","author":"Hawke","url":"https://hawkezou.github.io","root":"/"},"pages":[{"title":"archives","date":"2020-04-06T23:57:32.000Z","updated":"2020-04-08T07:56:43.000Z","comments":true,"path":"archives/index.html","permalink":"https://hawkezou.github.io/archives/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-03-19T10:08:44.000Z","updated":"2020-06-27T01:31:13.000Z","comments":false,"path":"categories/index.html","permalink":"https://hawkezou.github.io/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2023-07-22T23:57:32.000Z","updated":"2026-02-11T15:10:11.430Z","comments":false,"path":"about/index.html","permalink":"https://hawkezou.github.io/about/index.html","excerpt":"","text":"This is my blog. Thank you for your attention!"}],"posts":[{"title":"SpringBoot原理解析","slug":"springboot","date":"2024-01-18T01:16:09.000Z","updated":"2026-02-11T15:25:10.960Z","comments":true,"path":"2024/0118/","permalink":"https://hawkezou.github.io/2024/0118/","excerpt":"springboot是一种简化springweb开发的框架，类似springmvc，他提供各种默认配置，达到开箱即用、敏捷开发的效果。本文主要介绍springboot的依赖管理、自动配置、web开发、thymeleaf与视图解析、拦截器、文件上传、异常处理、web原生组件注入、整合数据源Druid与Redis、Junit单元测试、spring Acutuator性能监控、高级特性与springboot启动原理。","text":"springboot是一种简化springweb开发的框架，类似springmvc，他提供各种默认配置，达到开箱即用、敏捷开发的效果。本文主要介绍springboot的依赖管理、自动配置、web开发、thymeleaf与视图解析、拦截器、文件上传、异常处理、web原生组件注入、整合数据源Druid与Redis、Junit单元测试、spring Acutuator性能监控、高级特性与springboot启动原理。 依赖管理父项目依赖123456&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.7.1&lt;/version&gt; &lt;relativePath/&gt;&lt;/parent&gt; 作用：依赖管理及版本管理。 父项目的父项目： 12345&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.7.1&lt;/version&gt;&lt;/parent&gt; 其中默认引入了许多依赖，自动版本仲裁无需关注版本，我们可以不用配置某些依赖的版本，但是第三方需要。根据maven就近原则，默认使用本项目pom.xml配置好的依赖，若需要修改依赖版本号： 1234&lt;properties&gt; &lt;java.version&gt;8&lt;/java.version&gt; &lt;mysql.version&gt;5.2.41&lt;/mysql.version&gt;&lt;/properties&gt; starter场景启动器starter也叫依赖管理器，spring-boot-starter-*是用来开发某一场景的一组依赖，引入starter就导入了相关的开发依赖。 starter基本依赖为pring-boot-starter，web开发还需要引入spring-boot-starter-json、spring-boot-starter-tomcat、spring-web、spring-webmvc。 自动配置启动时加载所有自动配置和组件，条件装配按需配置。自动配置tomcat、自动配置springMVC、自动配置web常见功能、自动扫描springboot主程序所在包及子包下的bean组件。 @SpringBootApplication注解相当于@SpringBootConfiguration、@EnableAutoConfiguration、@ComponentScan注解。 自动配置按需加载，pom.xml引入依赖后该依赖的自动配置才会生效。配置会映射到某个配置类中，springboot默认配置会映射到名为xxProperties.class配置类中，配置类也是组件。 @Configuration声明配置类，参数proxyBeanMethods默认为true，开启代理，即使用cglib生成代理对象，只会在容器中生成一个组件示例。若为false，则不会生成代理对象，每次调用组件都会创建一个实例对象。 @Bean给容器中添加组件，以类名或方法名做id，返回类型为组件类型，返回值即组件在容器中的示例。@Bean注解的方法名默认作为对象的名字，也可以用name属性定义对象的名字。@bean分为两种模式,一种是Lite Mode(轻量模式),这种模式下被@bean定义的方法需要在@Component下或者原生类下,效果类似于@Component注册在类上的效果。@Configuration下的@bean被称为是Full mode，bean的创建是通过cglib代理生成的被@Configuration定义的类的增强类，因为@Configuration定义的类的bean，默认都是被Spring通过Cglib增强的子类。 @Bean注解参数： value：定义bean在IOC容器中的id属性。name ：定义bean在IOC容器中的id属性。autowire：装配方式Autowire.NO (默认设置)Autowire.BY_NAMEAutowire.BY_TYPEinitMethod：指定初始化方法 相当于xml文件中 init-methoddestroyMethod：指定销毁的方法 相当于xml文件中 destroy-method @Bean和@Component的区别：@Bean和@Component都是将Spring Bean添加到Spring Context 中。 1）作用域 @Component注解表明一个类会作为组件类，并告知 Spring 要为这个类创建 bean。@Bean不能作用在类上，只能作用于方法。 @Bean注解告诉 Spring 这个方法将会返回一个对象，这个对象要注册为 Spring 应用上下文中的 bean。要获取这个 bean 的时候，Spring 要按照这种方式、去获取这个 bean。 2）注册方式 @Component注解表明一个类会作为组件类，并告知 Spring 要为这个类创建 bean。@Bean注解告诉 Spring 这个方法将会返回一个对象，这个对象要注册为 Spring 应用上下文中的 bean。通常方法体中包含了最终产生bean实例的逻辑。 当我们引用第三方库中的类需要装配到 Spring 容器时，则只能通过@Bean来实现。 3）使用方式 @Component（@Controller、@Service、@Repository）通常是通过类路径扫描来侦测及自动装配到 Spring 容器中。@Bean一般结合@Configuration一起使用，也可以配置在类的方法中。 容器功能注解组件添加： 1、@Configuration 2、@Bean、@Component、@Controller、@Service 3、@ComponentScan 4、@Conditional 原生配置文件导入： @ImportResource 配置绑定： 1、@ConfigurationProperties 2、@EnableConfigurationProperties+@ConfigurationProperties 3、@Component+@ConfigurationProperties @Import(&#123;xx.class,xx.class&#125;)，通过类型在容器中创建组件实例，组件名为全类名。 @Conditional，条件装配注解，满足指定条件进行组件注册。参数value为一个class泛型数组。@ConditionalOnBean(name &#x3D; “xxx”)，当ioc容器中存在该对象时，为该组件注册实例。 @ImportResource(&quot;classpath:beans.xml&quot;)，导入spring原生配置文件，支持xml配置。 @EnableConfigurationProperties(xx.class)，为xx.class开启配置属性绑定。 @AutoConfigurationPackage，自动配置包原则，利用Register批量地将主程序所在包下的所有组件批量注册进容器。 @ConfigurationProperties(prefix=&quot;spring&quot;)，为核心配置文件中的属性绑定前缀，在映射的实体类上添加注解，表示将该类注册成bean并配置属性值。 简化开发lombok开发 1、在maven项目的pom.xml文件中添加lombok依赖 2、执行maven导入依赖 3、添加@Data注解，免去get和set方法 4、添加@ToString重写toString方法。 spring Initailizr开发，再idea中使用spring Initailizr创建初始化项目，勾选依赖配置和版本，maven自动导入，实现快速初始化项目。 yaml（yaml ain’t markup language）配置，key-value写法，大小写敏感，缩进表层级，#为注释。字符串值用单引号或双引号包围，单引号将\\n作为字符串输出，双引号将\\n作为换行输出。 注：标记语言是一种将标记以及文本相关的其他信息结合起来，展现出关于文档结构和数据处理细节的文字编码。 spring-boot-configuration-processor配置处理器，显示配置提示信息，添加依赖： 12345678910111213141516171819202122&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;!--在打包项目的时候排除以下简化开发的插件--&gt; &lt;excludes&gt; &lt;exclude&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;/exclude&gt; &lt;/excludes&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; web场景开发src&#x2F;main&#x2F;java；src&#x2F;main&#x2F;resources都是classes类路径的根路径，下面的所有文件都在该类路径下。当请求来时，java先动态处理，无法处理后寻找静态资源。默认的静态资源路径有[&#x2F;static，&#x2F;resources，&#x2F;META-INF，&#x2F;public] 1private static final String[] CLASSPATH_RESOURCE_LOCATIONS = &#123; &quot;classpath:/META-INF/resources/&quot;,&quot;classpath:/resources/&quot;, &quot;classpath:/static/&quot;, &quot;classpath:/public/&quot; &#125;; 欢迎页处理： 12345678910111213WelcomePageHandlerMapping(TemplateAvailabilityProviders templateAvailabilityProviders, ApplicationContext applicationContext, Optional&lt;Resource&gt; welcomePage, String staticPathPattern) &#123; if (welcomePage.isPresent() &amp;&amp; &quot;/**&quot;.equals(staticPathPattern)) &#123; //要用欢迎页功能，必须是/** logger.info(&quot;Adding welcome page: &quot; + welcomePage.get()); setRootViewName(&quot;forward:index.html&quot;); &#125; else if (welcomeTemplateExists(templateAvailabilityProviders, applicationContext)) &#123; // 调用Controller /index logger.info(&quot;Adding welcome page template: index&quot;); setRootViewName(&quot;index&quot;); &#125;&#125; 请求处理1234&lt;form action=&quot;/user&quot; method=&quot;post&quot;&gt; &lt;input name=&quot;_method&quot; type=&quot;hidden&quot; value=&quot;delete&quot;/&gt; &lt;input type=&quot;submit&quot; value=&quot;delete提交&quot;/&gt;&lt;/form&gt; 核心Filter：HiddenHttpMethodFilter；用法： 表单method&#x3D;post，隐藏域 _method&#x3D;put，SpringBoot中手动开启。 12345spring: mvc: hiddenmethod: filter: enabled: true #开启页面表单的Rest功能 设置自定义的methodFilter，编写webconfig配置类，创建filter对象，调用HiddenHttpMethodFilter的setMethodParam方法。 Rest原理 表单提交会带上_method=PUT 请求过来被HiddenHttpMethodFilter拦截 请求是否正常，并且是POST 获取到_method的值。 兼容以下请求；PUT、DELETE、PATCH 原生request（post），包装模式requesWrapper重写了getMethod方法，返回的是传入的值。 过滤器链放行的时候用wrapper。以后的方法调用getMethod是调用requesWrapper。 Rest使用客户端工具，PostMan直接发送Put、delete等方式请求，无需Filter。 请求映射原理： SpringMVC功能分析都从 org.springframework.web.servlet.DispatcherServlet-&gt;doDispatch(） RequestMappingHandlerMapping：保存了所有@RequestMapping和handler的映射规则。 所有的请求映射都在HandlerMapping中。 SpringBoot自动配置欢迎页的 WelcomePageHandlerMapping ，访问 &#x2F;能访问到index.html SpringBoot自动配置了默认的RequestMappingHandlerMapping 请求进来，挨个尝试所有的HandlerMapping看是否有请求信息。如果有就找到这个请求对应的handler，如果没有就是下一个 HandlerMapping。 基本注解： 路径变量@PathVariable、获取请求头@RequestHeader、模型属性@ModelAttribute、声明请求参数@RequestParam、获取post请求体@RequestBody、声明请求属性@RequestAttribute、矩阵变量@MatrixVariable、获取cookie值@CookieValue、请求处理映射路径@RequestMapping。 123456789101112131415161718package com.example.demo;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;@SpringBootApplication@RestControllerpublic class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125; @GetMapping(&quot;/hello&quot;) public String hello(@RequestParam(value = &quot;name&quot;, defaultValue = &quot;World&quot;) String name) &#123; return String.format(&quot;Hello %s!&quot;, name); &#125;&#125; Servlet API： WebRequest、ServletRequest、MultipartRequest、 HttpSession、javax.servlet.http.PushBuilder、Principal、InputStream、Reader、HttpMethod、Locale、TimeZone、ZoneId。 复杂参数： Map、Model（map、model里面的数据会被放在request的请求域 request.setAttribute）、Errors&#x2F;BindingResult、RedirectAttributes（ 重定向携带数据）、ServletResponse（response）、SessionStatus、UriComponentsBuilder、ServletUriComponentsBuilder 自定义对象参数： 可以自动类型转换与格式化，可以级联封装 123456789101112@Datapublic class Person &#123; private String userName; private Integer age; private Pet pet; &#125;@Datapublic class Pet &#123; private String name; private String age;&#125; 参数处理原理 HandlerMapping中找到能处理请求的Handler（Controller.method()） 为当前Handler 找一个适配器 HandlerAdapter； RequestMappingHandlerAdapter 适配器执行目标方法并确定方法参数的每一个值 参数解析器-HandlerMethodArgumentResolver 确定将要执行的目标方法的每一个参数的值是什么，SpringMVC目标方法能写多少种参数类型。取决于参数解析器。 响应请求 响应JSON ， jackson+@ResponseBody（返回数据不返回页面视图） SpringMVC到底支持以下返回值： 1234567891011121314ModelAndViewModelViewResponseEntity ResponseBodyEmitterStreamingResponseBodyHttpEntityHttpHeadersCallableDeferredResultListenableFutureCompletionStageWebAsyncTask@ResponseBody---&gt; RequestResponseBodyMethodProcessor； 返回值解析器原理 返回值处理器判断是否支持这种类型返回值 supportsReturnType 返回值处理器调用 handleReturnValue 进行处理 RequestResponseBodyMethodProcessor 可以处理返回值标了@ResponseBody 注解的 底层利用 MessageConverters 进行处理 ，将数据写为json 1、内容协商（浏览器默认会以请求头的方式告诉服务器他能接受什么样的内容类型） 2、服务器最终根据自己自身的能力，决定服务器能生产出什么样内容类型的数据， 3、SpringMVC会挨个遍历所有容器底层的 HttpMessageConverter ，看谁能处理 得到MappingJackson2HttpMessageConverter可以将对象写为json 根据客户端接收能力不同，返回不同媒体类型的数据，只需要改变请求头中Accept字段。Http协议中规定的，告诉服务器本客户端可以接收的数据类型。 导入了jackson处理xml的包，xml的converter就会自动进来: 1234 &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt; &lt;artifactId&gt;jackson-dataformat-xml&lt;/artifactId&gt;&lt;/dependency&gt; 开启浏览器参数方式内容协商功能: 1234spring: contentnegotiation: favor-parameter: true #开启基于请求参数内容协商策略 内容协商原理 1、判断当前响应头中是否已经有确定的媒体类型MediaType。 2、获取客户端支持接收的内容类型。（获取客户端Accept请求头字段）。 ​ contentNegotiationManager内容协商管理器两种内容协商策略： ​ （1）ParameterContentNegotiationStrategy 基于format参数(mediaType有json;xml) ​ （2）HeaderContentNegotiationStrategy 默认基于请求头(mediaType为xml) 3、遍历循环所有当前系统的 MessageConverter，看谁支持操作这个对象。 4、找到支持操作Person的converter，把converter支持的媒体类型统计出来。 5、客户端需要【application&#x2F;xml】，服务端能力【10种、json、xml】。 6、进行内容协商的最佳匹配媒体类型。 7、用支持将对象转为 最佳匹配媒体类型 的converter。调用它进行转化 。 自定义返回值mediaType数据格式，配置内容协商策略，添加自定义的mediaType类型。 **自定义MessageConverter ** 实现多协议数据兼容。json、xml… (1)、@ResponseBody 返回响应数据出去，调用 RequestResponseBodyMethodProcessor 处理 (2)、Processor 处理方法返回值，通过 MessageConverter 处理 (3)、所有 MessageConverter 合起来可以支持各种媒体类型数据的操作（读、写） (4)、内容协商找到最终的 messageConverter thymeleaf一个XML&#x2F;XHTML&#x2F;HTML5模板引擎，可用于Web与非Web环境中的应用开发。它是一个开源的现代化服务端Java模板引擎，是整合 Spring MVC 的可选模块，在应用开发中，使用 Thymeleaf 来代替 JSP或其他模板引擎。官网 注：由于SpringBoot打包是以jar的方式，不是war。其次我们的tomcat是嵌入式的，所以现在SpringBoot默认不支持jsp。Spring官方文档 基本语法 ： 表达式名字 语法 用途 变量取值 ${…} 获取请求域、session域、对象等值 选择变量 *{…} 获取上下文对象值 消息 #{…} 获取国际化等值 链接 @{…} 生成链接 片段表达式 ~{…} jsp:include 作用，引入公共页面片段 2、字面量 文本值: ‘one text’ , ‘Another one!’ ,…数字: 0 , 34 , 3.0 , 12.3 ,…布尔值: true , false 空值: null 变量： one，two，…. 变量不能有空格 3、文本操作 字符串拼接: + 变量替换: |The name is ${name}| 4、数学运算 运算符: + , - , * , &#x2F; , % 5、布尔运算 运算符: and , or 一元运算: ! , not 6、比较运算 比较: &gt; , &lt; , &gt;&#x3D; , &lt;&#x3D; ( gt , lt , ge , le )等式: &#x3D;&#x3D; , !&#x3D; ( eq , ne ) 7、条件运算 If-then: (if) ? (then) If-then-else: (if) ? (then) : (else) Default: (value) ?: (defaultvalue) 8、特殊操作 无操作： _ 迭代： 12345&lt;tr th:each=&quot;prod : $&#123;prods&#125;&quot;&gt; &lt;td th:text=&quot;$&#123;prod.name&#125;&quot;&gt;Onions&lt;/td&gt; &lt;td th:text=&quot;$&#123;prod.price&#125;&quot;&gt;2.41&lt;/td&gt; &lt;td th:text=&quot;$&#123;prod.inStock&#125;? #&#123;true&#125; : #&#123;false&#125;&quot;&gt;yes&lt;/td&gt;&lt;/tr&gt; 使用thymeleaf 引入依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 在相关页面中定义命名空间： 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form class=&quot;layui-form&quot; lay-filter=&quot;userForm&quot; id=&quot;userForm&quot;&gt; &lt;!--/*@thymesVar id=&quot;myUserName&quot; type=&quot;ch&quot;*/--&gt; &lt;input type=&quot;text&quot; th:text=&quot;$&#123;myUserName&#125;&quot; name=&quot;userName&quot; lay-verify=&quot;required&quot; placeholder=&quot;请输入用户名&quot; autocomplete=&quot;off&quot; class=&quot;layui-input&quot;&gt;&lt;a href=&quot;www.xxxx.com&quot; th:href=&quot;$&#123;link&#125;&quot;&gt;百度&lt;/a&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; controller返回对应页面： 12345678@RequestMapping(&quot;/editUser&quot;)public String editUser(Model model)&#123; User u = userService.getUser(); model.addAttribute(&quot;myUserName&quot;,u.getUserName()); model.addAttribute(&quot;myNickName&quot;,u.getNickName()); model.addAttribute(&quot;link&quot;,&quot;www.baidu.com&quot;); return &quot;user&quot;;&#125; 视图解析原理流程1、目标方法处理的过程中，所有数据都会被放在 ModelAndViewContainer 里面。包括数据和视图地址 2、方法的参数是一个自定义类型对象（从请求参数中确定的），把他重新放在 ModelAndViewContainer 3、任何目标方法执行完成以后都会返回 ModelAndView（数据和视图地址）。 4、processDispatchResult 处理派发结果（页面改如何响应） render(mv, request, response); 进行页面渲染逻辑 根据方法的String返回值得到 View 对象（定义了页面的渲染逻辑），所有的视图解析器尝试是否能根据当前返回值得到View对象，得到了 redirect:&#x2F;main.html –&gt; Thymeleaf new RedirectView()，ContentNegotiationViewResolver 里面包含了下面所有的视图解析器，内部还是利用下面所有视图解析器得到视图对象。view.render(mv.getModelInternal(), request, response)，视图对象调用自定义的render进行页面渲染工作。 RedirectView 如何渲染【重定向到一个页面】 1、获取目标url地址 2、response.sendRedirect(encodedURL) 视图解析： 1）返回值以 forward: 开始： new InternalResourceView(forwardUrl)–&gt; 转发request.getRequestDispatcher(path).forward(request, response); 2）返回值以 redirect: 开始： new RedirectView() -&gt; render就是重定向 3）返回值是普通字符串： new ThymeleafView() HandlerInterceptor拦截器定义拦截器，实现HandlerInterceptor接口，重写preHandler方法： 123456789101112public class LoginInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; //获取session HttpSession httpSession = request.getSession(); if(httpSession.getAttribute(&quot;loginUser&quot;)==null)&#123; response.sendRedirect(&quot;/f/toLogin&quot;); return false; &#125; return true; &#125;&#125; webMvcConfig重写addInterceptor方法： 12345678910@Configurationpublic class WebConfig implements WebMvcConfigurer &#123; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new LoginInterceptor()) .addPathPatterns(&quot;/**&quot;) .excludePathPatterns(&quot;/&quot;,&quot;/login.html&quot;,&quot;/f/toLogin&quot;, &quot;/user/login&quot;,&quot;/img/*&quot;,&quot;/layui/**&quot;); &#125;&#125; 拦截器执行过程： preHandler-&gt;目标方法-&gt;postHandler-&gt;afterCompletion 原理： 1、根据当前请求，找到HandlerExecutionChain【可以处理请求的handler以及handler的所有拦截器】 2、先顺序执行 所有拦截器的 preHandle方法 如果当前拦截器prehandler返回为true。则执行下一个拦截器的preHandle。 如果当前拦截器返回为false。直接倒序执行所有已经执行了的拦截器的afterCompletion。 3、如果任何一个拦截器返回false。直接跳出不执行目标方法。 4、所有拦截器都返回True，执行目标方法。 5、倒序执行所有拦截器的postHandle方法。 6、前面的步骤有任何异常都会直接倒序触发 afterCompletion 7、页面成功渲染完成以后，也会倒序触发 afterCompletion 文件上传文件上传自动配置类-MultipartAutoConfiguration，spring boot自动配置好了 StandardServletMultipartResolver 文件上传解析器。 原理步骤： 1、请求进来使用文件上传解析器判断（isMultipart）并封装（resolveMultipart，返回MultipartHttpServletRequest）文件上传请求。 2、参数解析器来解析请求中的文件内容封装成MultipartFile。 3、将request中多个文件信息封装为一个Map ，MultiValueMap&lt;String, MultipartFile&gt; 。 注：可以FileCopyUtils文件复制工具类的copy方法，实现文件流的拷贝。 核心配置文件中配置spring文件上传大小： 12345spring: servlet: multipart: max-file-size: 10MB max-request-size: 100MB 前端页面表单： 12345&lt;!--post提交，上传至/upload，contentType=&quot;multipart/form-data&quot;--&gt;&lt;form method=&quot;post&quot; action=&quot;/upload&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt; 后端接口： 1234567891011/** * MultipartFile 自动封装上传过来的文件 * @RequestPart从请求中取multipartFile文件 */@PostMapping(&quot;/upload&quot;)public String upload(@RequestParam(&quot;username&quot;) String username, @RequestPart(&quot;headerImg&quot;) MultipartFile headerImg, @RequestPart(&quot;photos&quot;) MultipartFile[] photos) throws IOException &#123; return &quot;main&quot;;&#125; 异常处理错误处理默认规则 默认情况下，Spring Boot提供/error处理所有错误的映射 对于服务器端，它将生成JSON响应，其中包含错误，HTTP状态和异常消息的详细信息。对于浏览器端，响应一个“ WhitelabelErrorView”，以HTML格式呈现。 要对其进行自定义，添加View解析为error 要完全替换默认行为，可以实现 ErrorController 并注册该类型的Bean定义，或添加ErrorAttributes类型的组件以使用现有机制但替换其内容。 templates&#x2F;error&#x2F;下的4xx，5xx页面会被自动解析； 定制错误处理逻辑 自定义错误页 error&#x2F;404.html error&#x2F;5xx.html，有精确的错误状态码页面就匹配精确，没有就找 4xx.html；如果都没有就触发白页。 @ControllerAdvice+@ExceptionHandler处理全局异常，底层是使用ExceptionHandlerExceptionResolver @ResponseStatus(返回状态码)+自定义异常 ，底层是使用ResponseStatusExceptionResolver，把@ResponseStatus注解的信息封装成ModelAndView并返回，底层调用 response.sendError(statusCode, resolvedReason)。 Spring底层的异常，如参数类型转换异常，使用DefaultHandlerExceptionResolver 处理框架底层的异常。 response.sendError(HttpServletResponse.SC_BAD_REQUEST, ex.getMessage()) 自定义实现 HandlerExceptionResolver接口的异常解析器，可以作为默认的全局异常处理规则。 ErrorViewResolver实现自定义处理异常，response.sendError(411,”自定义异常”)，error请求就会转给controller。异常没有任何人能处理，则tomcat底层调用response.sendError，error请求就会转给controller。BasicErrorController要去的页面地址是ErrorViewResolver 。 异常处理自动配置 ErrorMvcAutoConfiguration 自动配置异常处理规则 容器中的组件：类型：DefaultErrorAttributes -&gt; id：errorAttributes。 public class DefaultErrorAttributes implements ErrorAttributes, HandlerExceptionResolver。 DefaultErrorAttributes：定义错误页面中可以包含哪些数据。 容器中的组件：类型：BasicErrorController –&gt; id：basicErrorController（json+白页 适配响应）。 处理默认 &#x2F;error 路径的请求，页面响应 new ModelAndView(“error”, model)。 容器中有组件 View-&gt;id是error（响应默认错误页）。 容器中放组件 BeanNameViewResolver，按照返回的视图名作为组件的id去容器中找View对象。 容器中的组件：类型：DefaultErrorViewResolver -&gt; id：conventionErrorViewResolver。 如果发生错误，会以HTTP的状态码作为视图页地址（viewName），找到真正的页面。 viewName：error&#x2F;404、5xx.html。 如果想要返回页面，就会找error视图StaticView类型的defaultErrorView，默认是一个白页。其中定义了类WhitelabelErrorViewConfiguration。 异常处理步骤流程1、执行目标方法，目标方法运行期间有任何异常都会被catch，而且标志当前请求结束，并且用 dispatchException封装 。 2、进入视图解析页面渲染 mav = processDispatchResult(processedRequest, response, mappedHandler, mav, dispatchException); 3、处理handler发生的异常，处理完成返回ModelAndView（跳转地址和页面数据）。 遍历所有的handlerExceptionResolvers，找到HandlerExceptionResolver处理器异常解析器。 默认异常解析器（DefaultErrorAttributes、DefaultHandlerExceptionResolver、ExceptionHandlerExceptionResolver、ResponseHandlerExceptionResolver） DefaultErrorAttributes定义错误信息(exception、status、stack_trace、error、message、path)，把异常信息保存到request域，并且返回null。默认没有任何人能处理异常，所以异常会被抛出 如果没有任何人能处理最终底层就会发送 &#x2F;error 请求，会被底层的BasicErrorController处理。解析错误视图，遍历所有的 ErrorViewResolver解析，找到默认的DefaultErrorViewResolver(作用是把响应状态码作为错误页的地址)，模板引擎最终响应这个页面error&#x2F;xxx.html。 Web原生组件注入（Servlet、Filter、Listener）使用Servlet API @ServletComponentScan(basePackages = &quot;com.xxx.xxx&quot;) :指定原生Servlet组件都放在那里 @WebServlet(urlPatterns = &quot;/my&quot;)：效果：直接响应，没有经过Spring的拦截器。 @WebFilter(urlPatterns=&#123;&quot;/css/\\*&quot;,&quot;/images/\\*&quot;&#125;) @WebListener DispatchServlet 如何注册进来 容器中自动配置了 DispatcherServlet 属性绑定到 WebMvcProperties；对应的配置文件配置项是 spring.mvc。 通过ServletRegistrationBean&lt;DispatcherServlet&gt;把 DispatcherServlet 配置进来。 默认映射的是 &#x2F; 路径。 Tomcat-Servlet； 多个Servlet都能处理到同一层路径，精确优选原则 A： &#x2F;my&#x2F; B： &#x2F;my&#x2F;1 使用RegistrationBean 1ServletRegistrationBean`, `FilterRegistrationBean`, and `ServletListenerRegistrationBean 嵌入式Servlet容器 默认支持的webServer有Tomcat, Jetty, or Undertow，ServletWebServerApplicationContext 容器启动寻找ServletWebServerFactory 并引导创建服务器。 原理 (1) SpringBoot应用启动发现当前是Web应用。web场景包-导入tomcat，web应用会创建一个web版的ioc容器 ServletWebServerApplicationContext 。ServletWebServerApplicationContext 启动的时候寻找 ServletWebServerFactory（Servlet 的web服务器工厂—&gt; Servlet 的web服务器）。 (2) SpringBoot底层默认有很多的WebServer工厂，TomcatServletWebServerFactory, JettyServletWebServerFactory, or UndertowServletWebServerFactory。底层直接会有一个自动配置类ServletWebServerFactoryAutoConfiguration，它导入了ServletWebServerFactoryConfiguration。 (3) ServletWebServerFactoryConfiguration 配置类 根据动态判断系统中到底导入了那个Web服务器的包。（默认是web-starter导入tomcat包），容器中就有TomcatServletWebServerFactory ，它创建出Tomcat服务器并启动。TomcatWebServer 的构造器拥有初始化方法initialize—this.tomcat.start()。 (4) 内嵌服务器就是手动把启动服务器的代码调用，前提是tomcat核心jar包存在。 定制Servlet容器 实现 WebServerFactoryCustomizer&lt;ConfigurableServletWebServerFactory&gt; 接口的xxxCustomizer定制化器，可以改变xxxx的默认规则。 把配置文件的值和ServletWebServerFactory 进行绑定。 修改核心配置文件，server.xxx。 直接自定义 ConfigurableServletWebServerFactory 编写一个配置类实现 WebMvcConfigurer 即可定制化web功能+ @Bean给容器中再扩展一些组件。 Druid数据源 Druid主要解决的问题就是传统数据库无法解决的大数据量查询性能的问题。 本质就是一个分布式支持实时数据分析的数据存储系统。 在实际应用中，MyBatis 可以利用 Druid 作为其连接池，这样可以避免频繁地创建和关闭连接。MyBatis 会指定 Druid 作为连接池，并从中获取连接。这样MyBatis 从 Druid 中获得连接的管理工作，专注于数据处理本身。总结来说，Druid 为 MyBatis 提供了一个高效且可靠的连接池服务，使得MyBatis能够在不需要手动管理连接的情况下进行数据库操作。 引入druid-starter： 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.17&lt;/version&gt;&lt;/dependency&gt; 系统中所有filter： 别名 Filter类名 default com.alibaba.druid.filter.stat.StatFilter stat com.alibaba.druid.filter.stat.StatFilter mergeStat com.alibaba.druid.filter.stat.MergeStatFilter encoding com.alibaba.druid.filter.encoding.EncodingConvertFilter log4j com.alibaba.druid.filter.logging.Log4jFilter log4j2 com.alibaba.druid.filter.logging.Log4j2Filter slf4j com.alibaba.druid.filter.logging.Slf4jLogFilter commonlogging com.alibaba.druid.filter.logging.CommonsLogFilter 核心配置： 12345678910111213141516171819202122232425262728293031spring: datasource: druid: url: jdbc:mysql://localhost:3306/db username: root password: 123456 driver-class-name: com.mysql.jdbc.Driver aop-patterns: com.xxx.admin.* #监控SpringBean filters: stat,wall # 底层开启功能，stat（sql监控），wall（防火墙） stat-view-servlet: # 配置监控页功能 enabled: true login-username: admin login-password: 123456 resetEnable: false web-stat-filter: # 监控web enabled: true urlPattern: /* exclusions: &#x27;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*&#x27; filter: stat: # 对上面filters里面的stat的详细配置 slow-sql-millis: 1000 logSlowSql: true enabled: true wall: enabled: true config: drop-table-allow: false SpringBoot配置示例 配置项列表 整合RedisRedis 是一个开源的内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构。 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 核心配置： 123456789spring: redis: host: r-bp1nc7reqesxisgxpipd.redis.rds.aliyuncs.com port: 6379 password: lfy:Lfy123456 #client-type: jedis # jedis: # pool: # max-active: 10 自动配置： RedisAutoConfiguration 自动配置类。RedisProperties 属性类 ，spring.redis.xxx是对redis的配置。 连接工厂是准备好的。LettuceConnectionConfiguration、JedisConnectionConfiguration。 自动注入了RedisTemplate&lt;Object, Object&gt; ： xxxTemplate。 自动注入了StringRedisTemplate；k：v都是String。 底层只要我们使用 StringRedisTemplate、RedisTemplate就可以操作redis。 连接测试： 1234567@Test void testRedis()&#123; ValueOperations&lt;String, String&gt; operations = redisTemplate.opsForValue(); operations.set(&quot;hello&quot;,&quot;world&quot;); String hello = operations.get(&quot;hello&quot;); System.out.println(hello); &#125; 单元测试 Spring Boot 2.2.0 版本开始引入 JUnit 5 作为单元测试默认库，作为最新版本的JUnit框架，JUnit5与之前版本的Junit框架有很大的不同。由三个不同子项目的几个不同模块组成。 JUnit 5 &#x3D; JUnit Platform + JUnit Jupiter + JUnit Vintage 1）JUnit Platform: Junit Platform是在JVM上启动测试框架的基础，不仅支持Junit自制的测试引擎，其他测试引擎也都可以接入。 2）JUnit Jupiter: 提供了JUnit5的新的编程模型，是JUnit5新特性的核心，内部包含了一个测试引擎，用于在Junit Platform上运行。 3）JUnit Vintage: 提供了兼容JUnit4.x,Junit3.x的测试引擎。 相关变化： 注解在 org.junit.jupiter.api 包中，断言在 org.junit.jupiter.api.Assertions 类中，前置条件在 org.junit.jupiter.api.Assumptions 类中。 把@Before 和@After 替换成@BeforeEach 和@AfterEach。 把@BeforeClass 和@AfterClass 替换成@BeforeAll 和@AfterAll。 把@Ignore 替换成@Disabled。 把@Category 替换成@Tag。 把@RunWith、@Rule 和@ClassRule 替换成@ExtendWith。 注意：SpringBoot 2.4 以上版本移除了默认对 Vintage 的依赖，不能使用junit4的功能 @Test，JUnit 5’s Vintage Engine 从spring-boot-starter-test中移除，如果需要继续兼容junit4需要自行引入vintage。 引入依赖： 1234567891011121314151617&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!--兼容junit4--&gt;&lt;dependency&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.hamcrest&lt;/groupId&gt; &lt;artifactId&gt;hamcrest-core&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; SpringBoot整合Junit以后,编写测试方法：@Test标注（注意需要使用junit5版本的注解），Junit类具有Spring的功能，@Autowired、@Transactional 标注测试方法，测试完成后自动回滚。 JUnit5常用注解JUnit5与JUnit4的注解变化 @Test :表示方法是测试方法。但是与JUnit4的@Test不同，他的职责非常单一不能声明任何属性，拓展的测试将会由Jupiter提供额外测试 @ParameterizedTest :表示方法是参数化测试 @RepeatedTest :表示方法可重复执行 @DisplayName :为测试类或者测试方法设置展示名称 @BeforeEach :表示在每个单元测试之前执行 @AfterEach :表示在每个单元测试之后执行 @BeforeAll :表示在所有单元测试之前执行 @AfterAll :表示在所有单元测试之后执行 @Tag :表示单元测试类别，类似于JUnit4中的@Categories @Disabled :表示测试类或测试方法不执行，类似于JUnit4中的@Ignore @Timeout :表示测试方法运行如果超过了指定时间将会返回错误 @ExtendWith :为测试类或测试方法提供扩展类引用 断言assertions断言（assertions）是测试方法中的核心部分，用来对测试需要满足的条件进行验证。这些断言方法都是 org.junit.jupiter.api.Assertions 的静态方法。JUnit 5 内置的断言可以分成如下几个类别： 1、简单断言 用来对单个值进行简单的验证，前面的断言失败，后面的代码不会执行。 方法 说明 assertEquals 判断两个对象或两个原始类型是否相等 assertNotEquals 判断两个对象或两个原始类型是否不相等 assertSame 判断两个对象引用是否指向同一个对象 assertNotSame 判断两个对象引用是否指向不同的对象 assertTrue 判断给定的布尔值是否为 true assertFalse 判断给定的布尔值是否为 false assertNull 判断给定的对象引用是否为 null assertNotNull 判断给定的对象引用是否不为 null 2、数组断言 通过 assertArrayEquals 方法来判断两个对象或原始类型的数组是否相等 12345@Test@DisplayName(&quot;array assertion&quot;)public void array() &#123; assertArrayEquals(new int[]&#123;1, 2&#125;, new int[] &#123;1, 2&#125;);&#125; 3、组合断言 assertAll 方法接受多个 org.junit.jupiter.api.Executable 函数式接口的实例作为要验证的断言，可以通过 lambda 表达式很容易的提供这些断言 12345678@Test@DisplayName(&quot;assert all&quot;)public void all() &#123; assertAll(&quot;Math&quot;, () -&gt; assertEquals(2, 1 + 1), () -&gt; assertTrue(1 &gt; 0) );&#125; 4、异常断言 在JUnit4时期，想要测试方法的异常情况时，需要用**@Rule注解的ExpectedException变量还是比较麻烦的。而JUnit5提供了一种新的断言方式Assertions.assertThrows()** ,配合函数式编程就可以进行使用。 12345678@Test@DisplayName(&quot;异常测试&quot;)public void exceptionTest() &#123; ArithmeticException exception = Assertions.assertThrows( //扔出断言异常 ArithmeticException.class, () -&gt; System.out.println(1 % 0));&#125; 5、超时断言 Junit5还提供了Assertions.assertTimeout() 为测试方法设置了超时时间 123456@Test@DisplayName(&quot;超时测试&quot;)public void timeoutTest() &#123; //如果测试方法时间超过1s将会异常 Assertions.assertTimeout(Duration.ofMillis(1000), () -&gt; Thread.sleep(500));&#125; 6、快速失败 通过 fail 方法直接使得测试失败 12345@Test@DisplayName(&quot;fail&quot;)public void shouldFail() &#123; fail(&quot;This should fail&quot;);&#125; 前置条件（assumptions）JUnit 5 中的前置条件类似于断言，不同之处在于不满足的断言会使得测试方法失败，而不满足的前置条件只会使得测试方法的执行终止直接跳过。前置条件可以看成是测试方法执行的前提，当该前提不满足时，就没有继续执行的必要。 1234567891011121314151617181920@DisplayName(&quot;前置条件&quot;)public class AssumptionsTest &#123; private final String environment = &quot;DEV&quot;; @Test @DisplayName(&quot;assumeTrue&quot;) public void simpleAssume() &#123; assumeTrue(Objects.equals(this.environment, &quot;DEV&quot;)); assumeFalse(() -&gt; Objects.equals(this.environment, &quot;PROD&quot;)); &#125; @Test @DisplayName(&quot;assumingThat&quot;) public void assumeThenDo() &#123; assumingThat( Objects.equals(this.environment, &quot;DEV&quot;), () -&gt; System.out.println(&quot;In DEV&quot;) ); &#125;&#125; assumeTrue 和 assumFalse 确保给定的条件为 true 或 false，不满足条件会使得测试执行终止。assumingThat 的参数是表示条件的布尔值和对应的 Executable 接口的实现对象。只有条件满足时，Executable 对象才会被执行；当条件不满足时，测试执行并不会终止。 嵌套测试JUnit 5 可以通过 Java 中的内部类和@Nested 注解实现嵌套测试，从而可以更好的把相关的测试方法组织在一起。在内部类中可以使用@BeforeEach 和@AfterEach 注解，而且嵌套的层次没有限制。但是，嵌套内部的@BeforeEach 和@AfterEach 方法不会对外部的@Test单元测试生效。相反，外层的会对内层的单元测试生效。 123456789class xxx &#123; @Test @DisplayName(&quot;is empty&quot;) void isEmpty() &#123;&#125; @Nested @DisplayName(&quot;after&quot;) class After &#123;&#125;&#125; 参数化测试参数化测试是JUnit5很重要的一个新特性，用不同的参数多次运行测试，为我们的单元测试带来许多便利。 相关注解： @ParameterizedTest：代表这是一个参数化测试单元，而不是普通测试单元。 @ValueSource：为参数化测试指定入参来源，支持八大基础类以及String类型,Class类型，使用不同的参数进行多次单元测试，而不需要每新增一个参数就新增一个单元测试，省去了很多冗余代码。 @NullSource: 表示为参数化测试提供一个null的入参。 @EnumSource: 表示为参数化测试提供一个枚举入参。 @CsvFileSource：表示读取指定CSV文件内容作为参数化测试入参。 @MethodSource：表示读取指定方法的返回值作为参数化测试入参(注意方法返回需要是一个流)。 123456789101112131415@ParameterizedTest@ValueSource(strings = &#123;&quot;x&quot;, &quot;xx&quot;, &quot;xxx&quot;&#125;)public void parameterizedTest1(String string) &#123; System.out.println(string); Assertions.assertTrue(StringUtils.isNotBlank(string));&#125;@ParameterizedTest@MethodSource(&quot;method&quot;) //指定方法名public void testWithExplicitLocalMethodSource(String name) &#123; System.out.println(name);&#125;static Stream&lt;String&gt; method() &#123; return Stream.of(&quot;xxx&quot;, &quot;xx&quot;);&#125; 注：当然如果参数化测试仅仅只能做到指定普通的入参，他的强大之处的地方在于可以支持外部的各类入参。如:CSV,YML,JSON 文件甚至方法的返回值也可以作为入参。只需要去实现ArgumentsProvider接口，任何外部文件都可以作为它的入参。 指标监控Actuator未来每一个微服务在云上部署以后，都需要对其进行监控、追踪、审计、控制等。SpringBoot就抽取了Actuator场景，使得我们每个微服务快速引用即可获得生产级别的应用监控、审计等功能。 引入依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; ​ 2.x版本与1.x版本不同在于在支持MVC的基础上支持webFlux函数式编程、注解扩展、丰富的安全策略，底层使用MicroMeter。 访问路径：localhost:8080&#x2F;actuator，localhost:8080&#x2F;actuator&#x2F;EndPoint 相关配置： 1234567#management是actuator的配置management: endpoints: enabled-by-default: true #暴露所有JMX端点信息 web: exposure: include: &#x27;*&#x27; #以web方式暴露所有端点 Actuator Endpoint常用的Endpoints监控端点 ID 描述 auditevents 暴露当前应用程序的审核事件信息。需要一个AuditEventRepository组件。 beans 显示应用程序中所有Spring Bean的完整列表。 caches 暴露可用的缓存。 conditions 显示自动配置的所有条件信息，包括匹配或不匹配的原因。 configprops 显示所有配置@ConfigurationProperties。 env 暴露Spring的属性ConfigurableEnvironment flyway 显示已应用的所有Flyway数据库迁移。 需要一个或多个Flyway组件。 health 显示应用程序运行状况信息。 httptrace 显示HTTP跟踪信息（默认情况下，最近100个HTTP请求-响应）。需要一个HttpTraceRepository组件。 info 显示应用程序信息。 integrationgraph 显示Spring integrationgraph 。需要依赖spring-integration-core。 loggers 显示和修改应用程序中日志的配置。 liquibase 显示已应用的所有Liquibase数据库迁移。需要一个或多个Liquibase组件。 metrics 显示当前应用程序的“指标”信息。 mappings 显示所有@RequestMapping路径列表。 scheduledtasks 显示应用程序中的计划任务。 sessions 允许从Spring Session支持的会话存储中检索和删除用户会话。需要使用Spring Session的基于Servlet的Web应用程序。 shutdown 使应用程序正常关闭。默认禁用。 startup 显示由ApplicationStartup收集的启动步骤数据。需要使用SpringApplication进行配置BufferingApplicationStartup。 threaddump 执行线程转储。 如果应用程序是Web应用程序（Spring MVC，Spring WebFlux或Jersey），则可以使用以下附加端点： ID 描述 heapdump 返回hprof堆转储文件。 jolokia 通过HTTP暴露JMX bean（需要引入Jolokia，不适用于WebFlux）。需要引入依赖jolokia-core。 logfile 返回日志文件的内容（如果已设置logging.file.name或logging.file.path属性）。支持使用HTTPRange标头来检索部分日志文件的内容。 prometheus 以Prometheus服务器可以抓取的格式公开指标。需要依赖micrometer-registry-prometheus。 最常用的Endpoint Health：监控状况 Metrics：运行时指标 Loggers：日志记录 Health Endpoint 健康检查端点，一般用于在云平台，平台会定时的检查应用的健康状况，status为up表示健康，为down不健康，web访问路径：localhost:8080&#x2F;actuator&#x2F;health。 Metrics Endpoint 提供详细的、层级的、空间指标信息，这些信息可以被主动推送或者被动获取方式得到。相关metric访问路径：localhost:8080&#x2F;actuator&#x2F;metrics&#x2F;http.server.requests。 管理Endpoints1、开启与禁用Endpoints 默认所有的Endpoint除过shutdown都是开启的。 需要开启或者禁用某个Endpoint，配置模式为management.endpoint.端点名.enabled = true 12345management: endpoint: health: show-details: always enabled: true 或者禁用所有的Endpoint然后手动开启指定的Endpoint 12345678management: endpoints: enabled-by-default: false endpoint: beans: enabled: true health: enabled: true 2、暴露Endpoints 支持的暴露方式 HTTP：默认只暴露health和info JMX：默认暴露所有Endpoint，cmd使用jconsole本地访问 除过health和info，剩下的Endpoint都应该进行保护访问。如果引入SpringSecurity，则会默认配置安全访问规则 JMX （Java Management Extensions，即Java管理扩展）是一个为应用程序、设备、系统等植入管理功能的框架，提供了一种简单的、标准的监控和管理资源的性能监控方式。 定制 Endpoint1、定制 Health 信息 监控端点的类名须以HealthIndicator结尾，方式一实现HealthIndicator接口： 1234567891011@Componentpublic class MyHealthIndicator implements HealthIndicator &#123; @Override public Health health() &#123; int errorCode = check(); if (errorCode != 0) &#123; return Health.down().withDetail(&quot;Error Code&quot;, errorCode).build(); &#125; return Health.up().build(); &#125;&#125; 方式二继承AbstractHealthIndicator抽象类： 12345678910111213141516171819public class MyhealthHealthIndicator extends AbstractHealthIndicator&#123; @Override protected void doHealthCheck(Health.Builder builder) throws Exception &#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); if(1 == 1)&#123; // builder.up(); 健康 builder.status(Status.UP); map.put(&quot;count&quot;,1); map.put(&quot;ms&quot;,100); &#125;else &#123; // builder.down(); builder.status(Status.OUT_OF_SERVICE); map.put(&quot;err&quot;,&quot;连接超时&quot;); map.put(&quot;ms&quot;,3000); &#125; builder.withDetail(&quot;code&quot;,100) .withDetails(map); &#125;&#125; 访问：localhost:8080&#x2F;actuator&#x2F;health 会返回的所有health信息，包括Myhealth。 2、定制info信息 常用两种方式： 1、编写核心配置文件 123456info: appName: MyAdmin version: 1.0.0 #使用@@可以获取maven的pom文件值 mavenProjectName: @project.artifactId@ mavenProjectVersion: @project.version@ 2、编写InfoContributor监控点 123456789101112131415import java.util.Collections;import org.springframework.boot.actuate.info.Info;import org.springframework.boot.actuate.info.InfoContributor;import org.springframework.stereotype.Component;@Componentpublic class ExampleInfoContributor implements InfoContributor &#123; @Override public void contribute(Info.Builder builder) &#123; builder.withDetail(&quot;example&quot;, Collections.singletonMap(&quot;key&quot;, &quot;value&quot;)) .withDetail(&quot;hello&quot;,&quot;world&quot;); &#125;&#125; 访问：localhost:8080&#x2F;actuator&#x2F;info 会输出以上方式返回的所有info信息。 3、定制Metrics信息 SpringBoot支持自动适配的Metrics。 增加定制Metrics： 12345678910111213141516class MyService&#123; Counter counter; public MyService(MeterRegistry meterRegistry)&#123; //通过Registry注册metrics指标 counter = meterRegistry.counter(&quot;myservice.hello.count&quot;); &#125; public void hello()&#123; //记录hello方法调用次数 counter.increment(); &#125;&#125;//也可以使用下面的方式@BeanMeterBinder queueSize(Queue queue) &#123; return (registry) -&gt; Gauge.builder(&quot;queueSize&quot;, queue::size).register(registry);&#125; 访问：localhost:8080&#x2F;actuator&#x2F;metrics&#x2F;myservice.hello.count，会输出该监控指标信息。 4、自定义Endpoint 使用@EndPoint注解，属性id为EndPointName。 123456789101112@Component@Endpoint(id = &quot;EPname&quot;)public class DockerEndpoint &#123; @ReadOperation public Map getDockerInfo()&#123; return Collections.singletonMap(&quot;info&quot;,&quot;docker started...&quot;); &#125; @WriteOperation private void stopDocker()&#123; System.out.println(&quot;docker stopped....&quot;); &#125;&#125; 访问：localhost:8080&#x2F;actuator&#x2F;EPname 获取以上信息。 开发ReadinessEndpoint来管理程序是否就绪，或者LivenessEndpoint来管理程序是否存活。 可视化应用监控服务引入springboot-admin-server依赖： 12345678910&lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-starter-server&lt;/artifactId&gt; &lt;version&gt;2.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-starter-client&lt;/artifactId&gt; &lt;version&gt;2.3.1&lt;/version&gt;&lt;/dependency&gt; 在主配置类上添加@EnableAdminServer注解开启admin监控，在核心配置文件中配置： 12345678910#admin访问地址spring.boot.admin.url=http://localhost:8080#应用以ip注册spring.boot.admin.instance.prefer-ip=true#应用名spring.application.name=hellomanagement.endpoints.enabled-by-default=true #暴露所有端点management.endpoints.web.exposure.include=*#以web方式暴露所有端点 高级特性与原理解析Profile功能为了方便多环境适配，springboot简化了profile功能。 1、application-profile功能 默认配置文件 application.yaml，任何时候都会加载。 指定环境配置文件： application-{env}.yaml，env可为test、prod。 激活指定环境并指定相关配置参数。 激活profile环境方式： 一、配置文件激活：spring.profiles.active=prod 二、命令行激活：java -jar xxx.jar --spring.profiles.active=prod --person.name=666 修改配置文件的任意值，命令行优先。 默认配置与环境配置同时生效。 同名配置项，profile配置优先。 2、@Profile条件装配功能 该注解使类或方法等在指定配置环境下生效。 12345@Configuration(proxyBeanMethods = false)@Profile(&quot;prod&quot;)//该类在生产环境下生效public class ProductionConfiguration &#123; // ...&#125; 3、profile分组 批量加载配置文件，互补配置，注意不要冲突。 1234spring.profiles.group.myprod[0]=prodspring.profiles.group.myprod[1]=testspring.profiles.active=myprod #激活 外部化配置1、外部配置源 常用：Java属性文件、YAML文件、环境变量、命令行参数 2、springboot配置文件查找位置 (1) classpath 根路径 (2) classpath 根路径下config目录 (3) jar包当前目录 (4) jar包当前目录的config目录 (5) &#x2F;config子目录的直接子目录 ​ 注：指定环境优先，外部优先，后面的可以覆盖前面的同名配置项 3、配置文件加载顺序 当前jar包内部的application.properties和application.yml 当前jar包内部的application-{profile}.properties 和 application-{profile}.yml 引用的外部jar包的application.properties和application.yml 引用的外部jar包的application-{profile}.properties 和 application-{profile}.yml springboot启动过程starter启动原理： autoconfigure包中配置使用 META-INF/spring.factories 中 EnableAutoConfiguration的值，使得项目启动加载指定的自动配置类。 编写自动配置类 xxxAutoConfiguration -&gt; xxxxProperties 1234@Configuration@Conditional@EnableConfigurationProperties@Bean 过程：引入starter —&gt;xxxAutoConfiguration —&gt; 容器中放入组件 —&gt; 绑定xxxProperties.java —&gt; 配置项 springboot应用启动过程： 创建 SpringApplication 保存一些信息。 判定当前应用的类型。 bootstrappers：初始启动引导器，去spring.factories文件中找 org.springframework.boot.Bootstrapper 找 ApplicationContextInitializer初始化器·，去spring.factories找 ApplicationContextInitializer。 找 ApplicationListener应用监听器(事件通知)，去spring.factories找ApplicationListener。 运行 SpringApplication StopWatch监控应用启停。 记录应用的启动时间。 创建引导上下文（Context环境）createBootstrapContext()，获取到所有之前的 bootstrappers 挨个执行 intitialize() 来完成对引导启动器上下文环境设置。 让当前应用进入headless模式。 获取所有RunListener（运行监听器），getSpringFactoriesInstances 去spring.factories找 SpringApplicationRunListener。 遍历SpringApplicationRunListener调用 starting 方法，相当于通知所有感兴趣系统正在启动过程的人，项目正在 starting。 保存命令行参数ApplicationArguments 准备环境 prepareEnvironment（） 返回或者创建基础环境信息对象StandardServletEnvironment 配置环境信息对象，读取所有的配置源的配置属性值 绑定环境信息 监听器调用listener.environmentPrepared()通知所有的监听器当前环境准备完成 创建IOC容器createApplicationContext 根据项目类型（Servlet）创建容器 当前会创建AnnotationConfigServletWebServerApplicationContext 准备ApplicationContext IOC容器的基本信息 prepareContext() 保存环境信息 IOC容器的后置处理流程 应用初始化器applyInitializers 遍历所有的 ApplicationContextInitializer，调用 initialize.来对ioc容器进行初始化扩展功能 遍历所有的 listener 调用 contextPrepared，EventPublishRunListenr，通知所有的监听器contextPrepared 所有的监听器 调用 contextLoaded，通知所有的监听器 contextLoaded。 刷新IOC容器refreshContext，创建容器中的所有组件 容器刷新完成后工作afterRefresh 所有监听器调用 listeners.started(context)，通知所有的监听器started 调用所有runners，callRunners() 获取容器中的ApplicationRunner 获取容器中的 CommandLineRunner 合并所有runner并且按照@Order进行排序 遍历所有的runner，调用 run 方法 如果以上有异常，调用Listener 的 failed方法。 调用所有监听器的 running 方法listeners.running(context)，通知所有的监听器应用运行中 running如果有问题，继续通知 failed ，调用所有 Listener 的 failed，通知所有的监听器 failed","categories":[{"name":"java","slug":"java","permalink":"https://hawkezou.github.io/categories/java/"}],"tags":[]},{"title":"Spring入门","slug":"spring","date":"2023-12-31T10:16:09.000Z","updated":"2026-02-11T15:25:02.567Z","comments":true,"path":"2023/1231/","permalink":"https://hawkezou.github.io/2023/1231/","excerpt":"Spring是一个开放源代码的JavaEE设计层面框架，解决了业务逻辑层和其他各层的松耦合问题，因此它将面向接口的编程思想贯穿整个系统应用，它的核心是IOC控制反转和AOP面向切面编程","text":"Spring是一个开放源代码的JavaEE设计层面框架，解决了业务逻辑层和其他各层的松耦合问题，因此它将面向接口的编程思想贯穿整个系统应用，它的核心是IOC控制反转和AOP面向切面编程。 七大模块：core、aop、orm、dao、web、context、web mvc。 IOC控制反转，面向对象的设计原则，用来降低代码之间的耦合度。它有一种Bean对象容器，帮我们创建、管理、装配对象，即bean管理。 原理：xml解析、工厂模式、反射 提供IOC容器的接口：BeanFactory、ApplicationContext(加载配置文件时创建对象)。 ApplicationContext接口实现类：FileSystemXmlApplicationContext、ClassPathXmlApplicationContext。 实现IOC的方法：依赖注入。 bean管理：创建对象、注入属性(装配)。 bean管理的两种方式：xml配置、注解。 两种Bean：普通bean、工厂bean。 bean的作用域：singleton单例（默认）、prototype原型、request、session、application。 123&lt;bean id=&quot;user&quot; class=&quot;com.xx.xxx.user&quot; scope=&quot;propotype&quot;&gt;&lt;!--原型，调用getBean方法时创建不同的对象--&gt;&lt;/bean&gt; Bean的生命周期： 123451.执行无参构造创建bean2.调用set方法设置属性值3.执行初始化方法(postProcess)4.获取bean实例5.调用销毁方法销毁 xml配置创建对象配置文件中配置bean。 &lt;bean id=&quot;user&quot; class=&quot;com.xx.xxx.user&quot; name=&quot;别名&quot;&gt; id：唯一标识 class：全类名 默认通过无参构造创建对象。 有参构造创建：1）通过对象构造器参数下标 2）通过参数名 3）通过参数类型 1234567&lt;bean id=&quot;user&quot; class=&quot;com.xx.xxx.user&quot;&gt; &lt;!--第一个参数设值--&gt; &lt;constructor-arg index=&quot;0&quot; value=&quot;xx&quot;&gt; &lt;!--通过参数名设值--&gt; &lt;constructor-arg name=&quot;xx&quot; value=&quot;xx&quot;&gt; &lt;constructor-arg type=&quot;int&quot; value=&quot;xx&quot;&gt;&lt;/bean&gt; xml配置注入属性1）set方法。 2）配置文件中配置属性注入。 属性注入方式：property标签 、collection集合、p命名空间 、c命名空间。 （1）property配置： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;bean id=&quot;user&quot; class=&quot;com.xx.xxx.user&quot; name=&quot;别名&quot;&gt; &lt;!--属性名，值--&gt; &lt;property name=&quot;xxx&quot; value=&quot;xxx&quot;/&gt; &lt;!--null注入--&gt; &lt;property name=&quot;xxx&quot;&gt; &lt;null/&gt; &lt;/property&gt; &lt;!--特殊符号注入--&gt; &lt;!--转义或CDATA--&gt; &lt;property name=&quot;xxx&quot;&gt; &lt;value&gt;&lt;![CDATA[&lt;&lt;年龄&gt;&gt;]]&gt;&lt;/value&gt; &lt;/property&gt; &lt;!--外部Bean注入，ref指向哪个bean--&gt; &lt;!--类中需定义对象属性，set方法--&gt; &lt;property name=&quot;xxx&quot; ref=&quot;xxx&quot;/&gt; &lt;!--内部Bean注入(对象注入)--&gt; &lt;property name=&quot;xxx&quot;&gt; &lt;bean id=&quot;dept&quot; class=&quot;com.xx.xx.Dept&quot;&gt; &lt;property name=&quot;dname&quot; value=&quot;xx&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/property&gt;&lt;!--通过级联赋值，对多个对象属性赋值，需要设置对象属性的get方法--&gt; &lt;!--&lt;property name=&quot;dept.dname&quot; value=&quot;xx&quot;/&gt;--&gt; &lt;!--数组注入--&gt; &lt;property name=&quot;xxx&quot;&gt; &lt;array&gt; &lt;value&gt;1&lt;/value&gt; &lt;value&gt;2&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;!--map注入--&gt; &lt;property name=&quot;xxx&quot;&gt; &lt;map&gt; &lt;entry key=&quot;x&quot; value=&quot;x&quot;&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;!--list类型注入--&gt; &lt;property name=&quot;xxx&quot;&gt; &lt;list&gt; &lt;value&gt;1&lt;/value&gt; &lt;value&gt;2&lt;/value&gt; &lt;!--list中存对象&lt;ref bean=&quot;外部bean对象&quot;&gt;&lt;/ref&gt;--&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 测试获取bean对象： 12ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);xxx x = (xxx)context.getBean(&quot;xxx&quot;); （2）p命名空间注入 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xmlns:p=&quot;http://www.springframework.org/schema/p&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/beanshttps://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;bean id=&quot;user&quot; class=&quot;com.xx.xx.user&quot; p:name=&quot;xx&quot; p:age=&quot;12&quot;/&gt;&lt;/beans&gt; （3）c命名空间注入 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xmlns:c=&quot;http://www.springframework.org/schema/c&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/beanshttps://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;!--constructor构造器参数注入--&gt;&lt;!--需要有参构造--&gt;&lt;bean id=&quot;user&quot; class=&quot;com.xx.xx.user&quot; c:name=&quot;xx&quot; c:age=&quot;12&quot;/&gt;&lt;/beans&gt; （4）公共集合属性提取 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xmlns:util=&quot;http://www.springframework.org/schema/util&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/beanshttps://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/utilhttps://www.springframework.org/schema/util/spring-util.xsd&quot;&gt; &lt;util:list id=&quot;booklist&quot;&gt; &lt;value&gt;xxx&lt;/value&gt; &lt;/util:util&gt; &lt;bean id=&quot;book&quot; class=&quot;com.xx.xx.book&quot;&gt; &lt;property name=&quot;list&quot; ref=&quot;booklist&quot;&gt;&lt;/property&gt; &lt;/beans&gt;&lt;/beans&gt; 自动装配spring根据属性名称和属性类型自动将bean的属性值注入。 byName：默认，在容器中寻找set方法中对应的Beand的id，id唯一。 byType：寻找和自己属性类型相同的对象，class唯一。 1234&lt;bean id=&quot;pet&quot; class=&quot;com.xx.xx.pet&quot;/&gt;&lt;bean id=&quot;people&quot; class=&quot;com.xx.xxx.user&quot; autowire=&quot;byName&quot;&gt; &lt;!--&lt;property name=&quot;name&quot; ref=&quot;pet&quot;/&gt;--&gt;&lt;/bean&gt; 引入外部属性文件引入数据库连接池配置 1、引入依赖 2、配置context命名空间 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xmlns:context=&quot;http://www.springframework.org/schema/context&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/beanshttps://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; 3、引入外部文件jdbc.properties 1&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; 4、配置连接池 123456&lt;bean id=&quot;dbs&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; autowire=&quot;byName&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;prop.driverClass&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;prop.url&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;prop.userName&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;prop.password&#125;&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 注解创建对象bean管理中使用注解创建对象，在要放入spring容器的对象上加上@Component注解，按照mvc架构，它的衍生注解有@Repository、@Service、@Controller，属性值设置使用@Value（相当于property配置）。 1)引入aop依赖。 2）添加context命名空间，开启注解扫描。 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xmlns:context=&quot;http://www.springframework.org/schema/context&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/beanshttps://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;&lt;context:component-scan base-package=&quot;com.xxx&quot;/&gt;&lt;/beans&gt; 3）在类上添加相关的bean注解，@Component(value=&quot;xx&quot;) 默认beanid为类名，首字母小写。value值设置beanid。 其他注解： @Nullable，在方法上表示返回值可以为空；用在方法的参数上表示参数可空；用在属性上表示属性可为空。 @Scope : 设置作用域。@Scope(“singleton”):单例模式。 @Configuration : 代表这是一个配置类，就像我们之前看的beans.xml。配合@Bean使用将实体类注册，本质是一个@Component。 @Bean : 注册一个bean，就相当于我们之前写的一个bean标签;这个方法的名字，就相当于bean标签中的id属性;这个方法的返回值，就相当于bean标签中的class属性。 @Import : @Import(XXX.class)可以引入其他配置类，使其合并为一个总配置类，使用时通过AnnotationConfig上下文来获取总配置类即可。 @Data : Lombok中的注解,放在实体类上会自己创建set和get方法，toString方法等。 自定义扫描哪些注解: 123&lt;context:component-scan base-package=&quot;com.xxx&quot; use-default-filter=&quot;false&quot;&gt;&lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;&gt;&lt;/context&gt;&lt;/context:component-scan&gt; 注解注入属性常用注解：Autowired、Qualifier、Resource、Value(普通类型注入)。 1）添加context命名约束 2）开启注解配置 12&lt;context:component-scan base-package=&quot;com.xxx&quot;/&gt;&lt;context:annotation-config/&gt; 3）添加@Autowired，根据属性类型实现自动装配 通过属性名称完成属性装配，使用@Qualifier(value=&quot;xxx&quot;)注解指定bean对象。@Resource注解也可以完成自动装配，通过beanid和class类型寻找匹配，名称注入通过name。@Value注解对基本数据类型进行注入。 @Autowired与@Resource的不同 1）来源不同@Autowired是Spring定义的注解，而@Resource是JSR-250定义的注解。 2）参数不同@Autowired只包含一个参数：required，表示是否开启自动准入，默认是true。而@Resource包含七个参数，其中最重要的两个参数是：name 和 type。@Autowired如果要使用byName，需要使用@Qualifier一起配合。而@Resource如果指定了name，则用byName自动装配，如果指定了type，则用byType自动装配。 3）使用不同@Autowired能够用在：构造器、方法、参数、成员变量和注解上，而@Resource能用在：类、成员变量和方法上。 4）装配顺序@Autowired默认按byType自动装配，而@Resource默认byName自动装配。 完全注解开发 Config配置类代替xml文件实现自动装配，实际使用springboot也能完成类似操作。 123import org.springframework.context.annotation.Beanimport org.springframework.context.annotation.Configurationimport org.springframework.context.annotation.ComponentScan 在一个类上加上注解@Configuration 代表这是一个配置类，配置类中加上@ComponentScan注解，扫描要注入的bean对象包，替代xml配置文件。 1ApplicationContext context = new AnnotationConfigApplicationContext(config.class); AOP面向切面编程，通过预编译方式和动态代理实现程序功能统一维护的一种技术。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 动态代理分为两大类：基于接口的动态代理，基于类的动态代理 基于接口 : JDK动态代理 基于类 : cglib 通过反射实现 专业术语： 横切关注点：跨越应用程序多个模块的方法和功能，如日志、安全、缓存、事务。切面aspect：增强的过程，被模块化的特殊对象，它是一个类。通知advice：需要增强的代码逻辑部分。切入点pointcut：实际增强的方法，必须定义。连接点jointpoint：可增强的方法。目标target：被通知的对象。代理proxy：向目标对象通知后创建的对象。 使用AOP需要导入一个依赖包 : 123456&lt;!--https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.4&lt;/version&gt;&lt;/dependency&gt; 方式一 : 通过JDK接口实现创建UserService接口和实现类UserServiceImpl，创建实现类的代理对象，并实现aop切入实现，注意导入约束。 通过Proxy的newProxyInstance方法创建代理对象。 12345678910111213141516import java.lang.reflect.Proxy;import java.lang.reflect.Method;import java.lang.reflect.InvocationHandler;public class MyProxy&#123; public static void main(String[] args)&#123; Class[] interfaces = &#123;UserService.class&#125;; UserSerivce us = (UserService)Proxy.newProxyInstance(MyProxy.class.getClassLoader(),interfaces,new InvocationHandler()&#123; @Override public Object invoke(Object proxy,Method method, Object[] args) throws Throwable&#123; return null; &#125; &#125;) &#125;&#125; 方式二 : 通过AspectJ实现AOPAspectJ是一个独立的AOP框架，结合spring实现aop操作。需要引入aop、aspectj、cglib、aopalliance依赖。 切入点表达式： execution([权限修饰符] [返回类型] [全类名] [方法名] ([参数列表])) 例：expression=&quot;execution(* com.xxx.xx.UserServiceImpl.*(..)) （1）xml方式实现： 1）创建类及其增强类(代理对象类) 2）添加aop命名空间 3）xml中配置切入点 定义类： 12345public class book &#123; public void buy()&#123; System.out.println(&quot;---buy-----&quot;); &#125; &#125; 定义增强类： 12345678public class Proxy &#123; public void before()&#123; System.out.println(&quot;----方法执行前------&quot;); &#125; public void after()&#123; System.out.println(&quot;----方法执行后------&quot;); &#125;&#125; 4）在Spring配置中增强(切入) 123456789101112131415&lt;!--创建两个类的对象--&gt;&lt;bean id=&quot;book&quot; class=&quot;com.xx.config.book&quot;/&gt;&lt;bean id=&quot;Proxy&quot; class=&quot;com.xx.config.Proxy&quot;/&gt;&lt;!--aop的配置--&gt;&lt;aop:config&gt; &lt;!--切入点--&gt; &lt;aop:pointcut id=&quot;P&quot; expression=&quot;execution(* com.xx.config.book.buy(..))&quot;/&gt;&lt;!--切面,增强类--&gt;&lt;aop:aspect ref=&quot;Proxy&quot;&gt; &lt;!--advice增强方法--&gt; &lt;aop:before pointcut-ref=&quot;p&quot; method=&quot;before&quot;/&gt; &lt;aop:after pointcut-ref=&quot;p&quot; method=&quot;after&quot;/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; （2）注解方式实现： @Aspect注解表示该类为为增强类或代理对象类。 1）创建类及其增强类(代理对象类) 2）添加aop命名空间 3）开启注解扫描和生成代理对象 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xmlns:context=&quot;http://www.springframework.org/schema/context&quot;xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;xsi:schemaLocation=&quot; http://www.springframework.org/schema/beanshttps://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsdhttp://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;&lt;context:component-scan base-package=&quot;com.xxx&quot;/&gt;&lt;bean id=&quot;annotationProxy&quot; class=&quot;com.xxx.config.AnnotationProxy&quot;/&gt;&lt;!--开启aspectj代理对象生成--&gt;&lt;aop:aspectj-autoproxy/&gt;&lt;/beans&gt; aop:aspectj-autoproxy有一个proxy-target-class属性，默认为false，默认使用jdk动态代理。当为true，表示使用CGLib动态代理。不过即使proxy-target-class设置为false，如果目标类没有声明接口，则spring将自动使用CGLib动态代理。 注：@EnableAspectJAutoProxy注解可以实现代理对象生成，效果一样。 4）使用注解创建类及增强类的对象 使用注解配置不同类型的advice通知（增强逻辑）。 1234567891011121314151617181920212223@Aspectpublic class AnnotationProxy&#123; @Before( &quot;execution(* com.x.service.UserServiceImpl.*(..))&quot;) public void before()&#123; System.out.println(&quot;------方法执行前------&quot;); &#125; @After( &quot;execution(* com.x.service.UserServiceImpl.*(..))&quot;) public void after()&#123; System.out.println(&quot;-----方法执行后-------&quot;); &#125; @Around( &quot;execution(* com.x.service.UserServiceImpl.*(..))&quot;) public void around(ProceedingJoinPoint jp) throws Throwable &#123; System.out.println(&quot;环绕前&quot;); System.out.println(&quot;签名:&quot;+jp.getSignature()); //执行目标方法proceed Object proceed = jp.proceed(); System.out.println(&quot;环绕后&quot;); System.out.println(proceed); &#125;&#125; 五种advice通知(增强)类型： @Before前置通知。 @Around环绕通知 @After最终通知 @AfterRetuning后置通知 @AfterThrowing异常通知 123456环绕之前...before...目标方法执行...环绕之后...after...afterReturning... 提取公共切入点：定义一个方法，添加注解@Pointcut(value=&quot;切入点表达式&quot;)，在advice注解设置value值为方法名()。当有多个增强类对同一切入点增强，使用@Order()注解设置增强类优先级。 JdbcTemplate它是spring对jdbc的封装。 1）导入mysql、druid、jdbc、tx、orm依赖包。 2）配置数据库连接池 在引入外部文件中已经配置过。 3）配置JdbcTemplate对象 123&lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt; 4）开启注解扫描，在dao层注入jdbcTemplate对象 Spring事务管理Spring在不同的事务管理API之上定义了一个抽象层，使得开发人员不必了解底层的事务管理器API。Spring的声明事务管理底层原理使用aop。 Spring支持编程式事务管理和声明式的事务管理。声明式的事务管理有两种实现方式：注解和xml配置。 注解方式 1）使用Spring管理事务，导入tx事务依赖，命名空间导入 : tx。 12345678910111213&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xmlns:context=&quot;http://www.springframework.org/schema/context&quot;xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;xsi:schemaLocation=&quot; http://www.springframework.org/schema/beanshttps://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsdhttp://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsdhttp://www.springframework.org/schema/txhttp://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; 2）创建事务管理器 123&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;&lt;/bean&gt; 3）开启事务注解 12&lt;tx:annotation-driven transaction-manager = &quot;transactionManager&quot;/&gt; 4）在service类上添加事务注解 @Transactional，添加在类上，类中方法开启事务。spring定义了7种事务传播行为。 xml方式 1）配置事务管理器 2）配置事务通知 123456789101112&lt;!--配置事务通知--&gt;&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;!--配置哪些方法使用什么样的事务,配置事务的传播特性--&gt; &lt;tx:method name=&quot;add&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;delete&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;update&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;search*&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;!--该方法只读，无法对数据库进行操作--&gt; &lt;tx:method name=&quot;get&quot; read-only=&quot;true&quot;/&gt; &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt; 3）配置aop，切入点、切面 1234567&lt;!--配置aop事务--&gt;&lt;aop:config&gt; &lt;aop:pointcut id=&quot;txPointcut&quot; expression=&quot;execution(* com.x.dao.*.*(..))&quot;/&gt; &lt;!--配置切面--&gt;&lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPointcut&quot;/&gt;&lt;/aop:config&gt; 完全注解开发 使用@Configuration、@ComponentScan、@EnableTransactionManager、@Bean注解完成事务。创建数据库连接池，事务管理器，jdbcTemplate。 整合Mybatis编写实体类 12345public class User &#123; private int id; private String name; private String pwd; &#125; 编写mybatis-config核心配置文件 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;typeAliases&gt; &lt;package name=&quot;com.x.pojo&quot;/&gt; &lt;/typeAliases&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;package name=&quot;com.x.dao&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 编写UserDao接口 123public interface UserMapper &#123; public List&lt;User&gt; selectUser();&#125; 编写接口对应的Mapper映射文件 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.xxx.dao.UserMapper&quot;&gt; &lt;select id=&quot;selectUser&quot; resultType=&quot;User&quot;&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; 导入spring-webmvc、spring-jdbc、mybatis、mybatis-spring、mysql-connector-java、aspectjweaver包。 配置Maven静态资源过滤问题： 123456789101112&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; Mybatis-Spring MyBatis-Spring 会帮助你将 MyBatis 代码无缝地整合到 Spring 中。它将允许 MyBatis 参与到 Spring 的事务管理之中，创建映射器 mapper 和 SqlSession 并注入到 bean 中，以及将 Mybatis 的异常转换为 Spring 的 DataAccessException。最终，可以做到应用代码不依赖于 MyBatis，Spring 或 MyBatis-Spring。 在 MyBatis-Spring 中，可使用SqlSessionFactoryBean来创建 SqlSessionFactory。要配置这个工厂 bean，只需要把下面代码放在 Spring 的 XML 配置文件中： 123&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;&lt;/bean&gt; 实现一引入Spring配置文件beans.xml 123&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;/beans&gt; 配置数据源替换mybatis数据源 1234567&lt;!--配置数据源：可以用第三方的，也可用Spring的--&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;&lt;/bean&gt; 配置SqlSessionFactory，关联Mybatis 1234567&lt;!--配置SqlSessionFactory--&gt;&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;!--关联Mybatis--&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:com/kuang/dao/*.xml&quot;/&gt;&lt;/bean&gt; 注册sqlSessionTemplate，关联sqlSessionFactory 12345&lt;!--注册sqlSessionTemplate , 关联sqlSessionFactory--&gt;&lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt; &lt;!--利用构造器注入--&gt; &lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot;/&gt;&lt;/bean&gt; 增加Dao接口的实现类；私有化sqlSessionTemplate 1234567891011public class UserDaoImpl implements UserMapper &#123; //sqlSession不用我们自己创建了，Spring来管理 private SqlSessionTemplate sqlSession; public void setSqlSession(SqlSessionTemplate sqlSession) &#123; this.sqlSession = sqlSession; &#125; public List&lt;User&gt; selectUser() &#123; UserMapper mapper = sqlSession.getMapper(UserMapper.class); return mapper.selectUser(); &#125;&#125; 注册bean实现 123&lt;bean id=&quot;userDao&quot; class=&quot;com.x.dao.UserDaoImpl&quot;&gt; &lt;property name=&quot;sqlSession&quot; ref=&quot;sqlSession&quot;/&gt;&lt;/bean&gt; 当前Mybatis配置文件内容: 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;typeAliases&gt; &lt;package name=&quot;com.x.pojo&quot;/&gt; &lt;/typeAliases&gt;&lt;/configuration&gt; 测试 1234567@Testpublic void test2()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); UserMapper mapper = (UserMapper) context.getBean(&quot;userDao&quot;); List&lt;User&gt; user = mapper.selectUser(); System.out.println(user);&#125; 实现二dao继承Support类 , 直接利用 getSqlSession() 获得 , 然后直接注入SqlSessionFactory . 比起方式一 , 不需要管理SqlSessionTemplate , 而且对事务的支持更加友好。 将UserDaoImpl修改一下 12345public class UserDaoImpl extends SqlSessionDaoSupport implements UserMapper &#123; public List&lt;User&gt; selectUser() &#123; UserMapper mapper = getSqlSession().getMapper(UserMapper.class); return mapper.selectUser(); &#125;&#125; 修改bean的配置 123&lt;bean id=&quot;userDao&quot; class=&quot;com.xx.dao.UserDaoImpl&quot;&gt; &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot; /&gt;&lt;/bean&gt; WebFlux函数式编程spring5的新功能，类似springMVC，用于web开发，流行的异步非阻塞的响应式编程框架，基于Reactor的api实现。","categories":[{"name":"java","slug":"java","permalink":"https://hawkezou.github.io/categories/java/"}],"tags":[]},{"title":"MySQL入门","slug":"Mysql入门","date":"2023-12-15T08:15:23.000Z","updated":"2026-02-11T15:24:47.277Z","comments":true,"path":"2023/1215/","permalink":"https://hawkezou.github.io/2023/1215/","excerpt":"本文介绍了什么是sql和nosql以及两者区别；介绍了mysql的特点、函数和SQL语句操作数据库；讲解了mysql事务及ACID原则和事务的4种隔离级别，索引的作用和原理；mysql的权限管理和数据备份恢复；数据库的设计和三大范式；SQL注入问题和避免；JDBC以及DBCP连接池连接数据库。","text":"本文介绍了什么是sql和nosql以及两者区别；介绍了mysql的特点、函数和SQL语句操作数据库；讲解了mysql事务及ACID原则和事务的4种隔离级别，索引的作用和原理；mysql的权限管理和数据备份恢复；数据库的设计和三大范式；SQL注入问题和避免；JDBC以及DBCP连接池连接数据库。 sql与nosql关系型数据库SQL是使用关系模式组织数据的结构化数据库系统。 非关系型数据库（NoSQL）是一类用于存储和管理非结构化数据的数据库系统。 关系数据库和非关系数据库区别体现在三个方面：数据存储方式不同；扩展方式不同；对事务性的支持不同。具体可参考：区别 关系型数据库的实现：Mysql，SQLserver，Oracle等。 非关系数据库实现：Redis（键值对），Mongodb（文档型），hbase（列存储），neo4j（Graph图像）。 mysqlSQL语言的特点：高度非过程化、面向集合操作、可移植性强、简洁灵活、支持三级模式结构、ACID（原子性，一致性，隔离性，持久性）。 SQL语言支持三级模式结构，通过外模式对应视图、基本表对应存储文件，以及内模式对应存储文件的方式实现。 Mysql默认不支持中文，在my.ini中配置编码character-set-server=utf8或，编写sql代码时加上DEFAULT CHARSET=UTF8。Mysql默认localhost本地连接，root为最高权限用户，默认数据库引擎为Innodb（支持事务，行级锁，外键，但是占用空间大）。 注释：–，&#x2F;**&#x2F; 数据库数值类型：tinyint(1byte)、smallint(2byte)、int(4byte)、float(4byte)、double(8byte)、decimal、varchar(0-65535)、text文本串、null date：YYYY-MM-DD time: HH:mm:ss datetime：YYYY-MMM-DD HH:mm:ss timestamp：时间戳，1970到现在的毫秒数 文档：reference DDL定义数据定义语言（DDL）：create，drop，alter 创建数据库：create database 数据库名 切换数据库：USE DATABASE 修改表：alter table &#39;表名&#39; rename as xxx 增加字段：alter table &#39;表名&#39; add Phone INT(11) 修改字段：alter table &#39;表名&#39; modify Phone VARCHAR(11)； 修改字段名：alter table &#39;表名&#39; change Phone Phone1 INT(11) 删除字段：alter table &#39;表名&#39; drop Phone INT(11) 12345678--创建表---CREATE TABLE `categoryin`(categoryin_id INT(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;收入分类id&#x27;,categoryin_name VARCHAR(20) CHARACTER SET utf8 COMMENT &#x27;收入分类名&#x27;,PRIMARY KEY (categoryin_id))ENGINE=INNODB AUTO_INCREMENT=3 CHARACTER SET = utf8 COMMENT=&#x27;收入分类&#x27;; DML操作管理数据操作语言（DML）：insert , delete , update，truncate insert into 表名 (字段1,字段2) values(值1，值2); 12INSERT INTO `categoryin` VALUES (1,&#x27;工资&#x27;);INSERT INTO `categoryin` VALUES (2,&#x27;彩票&#x27;); update 表名 set &#39;字段1&#39;=&#39;值1&#39;,&#39;字段2&#39;=&#39;值2&#39; where id=xxx; where条件运算符：&#x3D;，!&#x3D;(&lt;&gt;)， &gt;，&lt;，between and，and，or。 delete from 表名 where [条件] 清空表（自增变量归0）：truncate table &#39;表名&#39; DQL查询数据查询语言（DQL）：select select 字段1,字段2 from 表名 as 别名 字段去重，select distinct &#39;字段&#39; from 表名 12345678--查询系统版本select version();--计算select 2*3;--查询变量select @@auto_increment_increment--函数select 函数 模糊查询： select 字段 from 表名 where xxx like &#39;a__&#39; select 字段 from 表名 where xxx like &#39;%a%&#39; select 字段 from 表名 where xxx in (xxx,xxx,xxx) select 字段 from 表名 where xxx is &#39;xxx&#39; 多表查询： 联接查询：join 表名 as 别名 on [条件] 123456789select mi.in_id, mi.single_in, mi.zhanghu_id, mi.categoryin_id, mi.date, mi.beizhu, z.zhanghu_name,z.zhanghu_money, z.create_time, cin.categoryin_name from moneyin as mi join zhanghu as z on mi.zhanghu_id=z.zhanghu_id join categoryin cin on mi.categoryin_id=cin.categoryin_id inner join：只返回两个表中联结字段相等的行。 left join：返回左表所有值，即使没有匹配(使用null填充)。 right join：返回右表所有值，即使没有匹配(使用null填充)。 注意顺序： where指定结果满足条件； group by按照哪个字段分组 ； having过滤分组满足的次要条件； order by排序； limit分页。 分页limit和排序order by: 12345--ASC升序--DESC降序where ....order by xxx desclimit 0,10--limit 起始下标,pageSize页大小 子查询： 在where ..(select …)中嵌套一个查询 123select sNamefrom Studentwhere sId in (select distinct sId from score where tId=(select tId from teacher where tName=&#x27;Alice&#x27;)) DCL控制数据控制语言（DCL）：grant，revoke 。 五个约束主键约束（唯一约束）（Primay Key Counstraint）：唯一性，非空性。 唯一约束（Unique Counstraint）：唯一性，可以空，但只能有一个。 检查约束 (Check Counstraint) 12alter table useradd constraint CK_Sex check (sex=&#x27;男&#x27; or sex=&#x27;女&#x27;) 默认约束 (Default Counstraint) 12alter table useradd constraint df_age default (&#x27;0&#x27;) for age 外键约束 (Foreign Key Counstraint) 函数usage: select [函数]; 常用函数： abs绝对值，floor向下取整，celling向上取整，rand产生0-1随机数，char_length字符串长度，concat拼接，sign符号函数，current_date当前日期，now当前时间，localtime本地时间，sysdate系统时间，md加密。 first：返回指定的字段中第一个记录的值； last：返回指定的字段中最后一个记录的值； len：返回文本字段中值的长度； 聚合函数(计算最大、最小、平均值)： count计数 123select count(字段或p-k) from stduent;--忽略nullselect count(*) from student;--不会忽略nullselect count(1) from student;--不忽略null，本质：计算行数 sum求和；avg求平均；max；min select sum(‘字段’) as 总和 from 表;select avg(‘字段’) as 平均 from 表;select max(‘字段’) as 最大 from 表;select min(‘字段’) as 最小 from 表; 12345678--查询不同课程的平均分&gt;80，最高分，最低分select subjectName,avg(studentResult) as 平均分,max(studentResult) as 最高分,min(studentResult) as 最低分 from result rinner join &#x27;subject&#x27; sub on r.&#x27;subjectNo&#x27;=sub.&#x27;subjectNo&#x27;--根据不同课程分组group by r.&#x27;subjectNo&#x27;having 平均分&gt;80 事务数据库事务(Transaction)：指由一个或多个数据库操作组成的逻辑单位。 mysql默认开启事务自动提交！ set autocommit=0;设置手动提交事务。 start transaction开启事务。 commit事务提交，事务一旦提交，数据将持久化，回滚也无法恢复。 rollback事务回滚。 事务原则ACID ACID（原子性，一致性，隔离性，持久性）。 原子性atomic：事务要么所有的操作都执行成功,要么所有的操作都不执行,保证数据库的一致性和完整性。 一致性consistency：事务完成后符合逻辑运算，数据前后状态要一致。 持久性durability：事务没有提交则数据恢复原状，事务提交则数据不可逆，不会因宕机外部因素丢失数据。 隔离性isolation：排除其他事务对本次事务的影响。 事务隔离级别 脏读：一个事务读取另一个事务未提交的数据。 不可重复读：一次事务内多次读取某行的数据不同。 虚读(幻读)：一次事务中读取了其他事务插入的数据。 4 种隔离级别：读未提交 (READ UNCOMMITTED)、读已提交 (READ COMMITTED)、可重复读 (REPEATABLE READ)、串行化 (SERIALIZABLE)。 隔离级别 脏读 不可重复读 幻读 读未提交 可能 可能 可能 读提交 不可能 可能 可能 可重复读 不可能 不可能 可能 串行化 不可能 不可能 不可能 索引索引定义：：Index是帮助MySQL高效获取数据的数据结构。索引作用：通过索引可以大大的提高数据库的检索速度，提高数据库的性能。 索引类型唯一索引unique：唯一，可重复(多个列都可以标识为unique) 主键索引primary：唯一，不可重复(一张表只能有一个)。定义表主键的时候，会自动创建主键索引。 常规索引key：默认 全文索引FullText：快速定位数据。 1234567--1、创建表时添加索引--2、alter alter table 表名 add Index_TYPE index &#x27;索引名&#x27;(&#x27;字段&#x27;);--3、create-- 索引名：id_表名_字段名create index 索引名 on 表(&#x27;字段&#x27;); 聚集索引clustered index：表中各行的物理顺序与键值的逻辑顺序相同，每个表只能有一个。在聚集索引中，表中各行的物理顺序与键值的逻辑（索引）顺序相同。表只能包含一个聚集索引。 非聚集索引：非聚集索引指定表的逻辑顺序，数据存储在一个位置，索引存储在另一个位置，索引中包含指向数据存储位置的指针。 一个表只能创建1个聚集索引，多个非聚集索引。设置某列为主键，该列就默认为聚集索引。 索引数据结构：InnoDB使用聚集索引，数据记录本身被存于一棵B+树的叶子节点上，同一个叶子节点内的各条数据记录按主键顺序存放。每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子，则开辟一个新的页（节点）。 权限与DCL数据库mysql中user表记录了root、mysql.sys、mysql.session等用户的操作权限、访问主机host（默认localhost，只能本地连接）和各自密码(加密)。其中，root用户为最高权限用户，只有root有grant授权权限。 创建用户：create user xxx identified by &#39;PASSWORD&#39;; 删除用户：drop user xxx; 修改密码：update user set password=&#39;123456&#39; where user=&#39;root&#39;; set password for root = password(&#39;123456&#39;); 修改当前用户密码：set password = password(&#39;123456&#39;); 重命名用户：rename user xxx to xx; 数据控制语言（DCL）：grant，revoke 。 授权：grant 某权限[all privileges] on 库.表 to 用户; 查看权限：show grants for xxx 特殊的show grants for root@localhost 撤销权限：revoke 权限[privileges] on 库.表(*.*) from 用户; 当出现1130-host “xxx” is not allowed to connetced to this Mysql错误提示，表示访问拒绝非本地连接，需要修改host为%，可执行以下步骤。 1234--1. use mysql;--2. update user set host=&#x27;%&#x27; where user=&#x27;root&#x27;;--3. flush privileges;/*在不重启mysql下使修改生效*/ 备份恢复备份 方式一、物理拷贝 直接将mysql中的data目录下的文件数据拷贝出去。 方式二、mysqldump命令 mysqldump -h 主机 -u 用户 -p 密码 数据库 表名&gt; 导出位置/xx.sql mysqldump -h 主机 -u 用户 -p 密码 数据库&gt; 导出位置/xx.sql 例：mysqldump -u root -p 123456 mydb &gt; /home/db.bak 方式三、sqlyog可视化导出转储 恢复 登录数据库，使用source命令导入备份的sql或bak数据。 source 备份文件 或未登录下 mysqldump -h 主机 -u 用户 -p 密码 数据库&lt; xx.sql 数据库设计良好的设计将节省内存，提高查询速度，便于系统开发。 注意点：表名命名清晰、表结构合理、表关系(实体关系)设计、字段命名规范(不要大小写，统一小写加下划线)、字段类型及长度、主键设计、数据库引擎使用(通常为innodb)、字符集规范utf8。 三大范式数据库三大范式包含： 第一范式(1NF)：属性不可分割，每一列都是不可分的原子数据项。 第二范式(2NF)：满足第一范式，且不存在部分依赖，每一列必须和主键相关。非码属性必须完全依赖于候选码。 第三范式(3NF)：满足第二范式，且不存在传递依赖，每一列必须和主键直接相关，不存在间接相关。任何非主属性不依赖于其它非主属性，即在2NF基础上消除传递依赖。 设计注意事项：关联性查询最好不要超过三张表，设计时应该考虑性能与规范的问题。 JDBCJava DataBase Connectivity（Java数据库连接），是 JavaEE 平台下的技术规范， 定义了在 Java 语言中连接数据库，执行数据库操作的标准 ，可以为多种关系数据库提供统一访问，其本质是sun公司制定的一套接口。 因为每一个数据库的底层实现原理都不一样，每一个数据库产品都有自己独特的实现原理！所以为了方便java的开发，制定一个统一的连接数据库的规范势在必行，这就是JDBC。只要数据库厂商面向JDBC编写驱动，就能让开发者使用JDBC方便地操作各种数据库。 其中，java.sql.*；javax.sql.*里定义了与数据库操作有关的接口和方法。mysql-connector-java-8.0.11.jar包是标准JDBC的驱动程序，用于连接数据库。JdbcUtils工具类封装加载驱动，获取连接，释放资源。 1234567891011121314151617181920212223//加载驱动，执行静态代码块Class.forName(&quot;com.mysql.jdbc.Driver&quot;);//url，数据库信息String url=&quot;jdbc:mysql://localhost:3360/数据库?useSSL=true&amp; characterEncoding=utf-8 &amp; serverTimezone=Asia/Shanghai&quot;;String user=&quot;root&quot;;String password=&quot;123456&quot;;//数据库连接对象Connection connection =DriverManager.getConnection(url,user,password);//定义statement对象Statement statement=connection.createStatement();String sql = &quot;select * from user&quot;;//定义结果集ResultSet resultSet = statement.executeQuery(sql);while(resultSet.next())&#123; System.ou.println(&quot;id=&quot;+resultSet.getObject(&quot;id&quot;));&#125;//释放连接resultSet.close();statement.close();connection.close();//jdbcUtils.release(connetcion,statement,resultSet); oracle数据库连接：jdbc:oracle:thin:@//&lt;host&gt;:&lt;port&gt;/&lt;SERVICE_NAME&gt; sid连接：jdbc:oracle:thin:@localhost:1521:sid JDBC参考资料 SQL注入问题指攻击者在查询信息的结尾上添加额外的SQL语句以实现非法操作，执行非授权的任意查询，实质是web应用对用户输入的数据合法性判断不严。 Statement 采取直接编译 SQL 语句的方式，扔给数据库去执行，而 PreparedStatement 则先将 SQL 语句预编译一遍，再填充参数，这样效率会高一些。 Statement对象可能进行字符串与变量的拼接，很容易进行 SQL 注入攻击。采用PreparedStatement访问数据库不仅能防止sql注入，还是预编译的，不用重新编译整个sql语句，效率高。此外执行查询语句得到的结果集是离线的，连接关闭后，仍然可以访问结果集。 注意：PreparedStatement防止sql注入实质是将传入的参数看作字符串处理。${}是拼接，#{}整体当做字符串处理。 1234567891011121314//删除表中id=1且name=admin的记录Class.forName(com.mysql.jdbc.Driver); Connection con = DriverManager.getConnection( &quot;jdbc:mysql://localhost:3306/xxx...&quot;); //以？作为占位符，值待设置String sql = &quot;delete from user where id=? and name=?&quot;;//创建PreparedStatement时就传入sql语句，实现了预编译 PreparedStatement p = con.prepareStatement(sql); //传入参数p.setString(1,&quot;1&quot;);p.setString(2,&quot;admin&quot;);//设置sql语句的占位符的值，注意第一个参数位置是1不是0p.execute(); //执行 同时，mybatis-plus框架也会进行sql的预编译。Mybatis（plus）使用参数化查询，#&#123;xxx&#125; 是参数化查询的占位符，它将传入的参数插入到占位符中，而不会将其解释为 SQL 代码。在自定义查询语句时，为确保参数化查询，须使用 @Param 注解将参数传递给 sql查询。这些措施让Mybatis-plus能防止sql注入。 文章：PreparedStatement防止SQL注入原因 ​ MybatisPlus如何解决SQL注入 ​ Mybatis-plus sql注入及防止sql注入详解 DBCP数据库连接池DBCP连接池提高资源利用率，避免重复创建和销毁连接资源，减少系统开销。使用DBCP连接池后，免去了编写连接数据库的代码。使用DBCP需要导入dbcp相关jar包，导入依赖到项目中。 12commons-dbcp-1.4.jarcommons-pool-1.5.4jar 创建多个dbcp.properties文件，存储多个不同的连接池 连接池的工作原理：①使用连接池前：用jdbc连接数据库时，先getConnection获取连接，用完后要release释放连接，再次连接重复前两步，对程序性能影响很大。②使用连接池后：在程序开始之前，先创建几个连接，将连接放入到连接池中，连接池中缓存了一定量的Connection对象，当用户需要使用连接时，从连接池中获取，使用完毕之后将连接还回连接池。 连接池的种类：DBCP，C3P0，Druid，Tmcat内置连接池等。 dhcp配置: 123456789101112131415#导入dbcp的配置文件dbcp.propertiesdriverclassName=com.mysql.jbcp.Driverurl=jdbc:mysql://localhost:3306/xxx?useUnicode=true&amp;characterEncoding=utf-8user=rootpassword=123456initialSize=10 #初始连接数量maxActive=50 #最大活跃连接数量maxIdle=20 #最大空间连接数minIdle=5 #最小空间连接数maxWait=60000 #最大等待时间ms（毫秒），从连接池获取连接，如果连接池空了，等待的最大时间connectionProperties=useUnicode=true;characterEncoding=utf-8defaultAutoCommit=truedefaultTransactionIsolation=READ_COMMITTED 12345678910InputStream in = xxx.class.getClassLoader(). getResourceAsStream(&quot;dbcp.properties&quot;);Properties pro = new Properties();pro.load(in);//声明连接池static DataSource datasource=null;//创建连接池datasource=BasicDataSourceFactory.createDataSource(pro);//从连接池获取连接conn=datasource.getConnection()； DBCP参考资料","categories":[{"name":"mysql","slug":"mysql","permalink":"https://hawkezou.github.io/categories/mysql/"}],"tags":[]},{"title":"linux正则表达式与三剑客","slug":"linux正则表达式与三剑客","date":"2023-12-11T09:45:23.000Z","updated":"2026-02-11T15:24:40.410Z","comments":true,"path":"2023/1211/","permalink":"https://hawkezou.github.io/2023/1211/","excerpt":"本文介绍了如何使用linux正则表达式结合命令处理文本和awk,grep,sed三种文本工作命令。","text":"本文介绍了如何使用linux正则表达式结合命令处理文本和awk,grep,sed三种文本工作命令。 正则表达式（regular expression） 使用一些特殊字符+字母和或数字按照某个规则组合成一 个公式用来表示某个意思这就叫正则表达式。正则表达式是一种方法，很多命令可以采用这种方法：vim ，grep，sed，awk等都支持正则表达式，grep通常打印结果行。 元字符元字符：有特殊含义的字符，可以表示其他的含义 “ ^ “ 开头匹配后面的某开头字符。 cat a.txt | grep &quot;^a&quot; 12a bcabc “ $ “ 结尾匹配前面的某结尾字符。 cat a.txt | grep &quot;b$&quot; 12aa aabbbb “ . “单个匹配任意单个字符，长度不为0。 “a.{2}” 表示匹配以a开头的后面任意两个单个字符，至少两个，包括空格。 cat a.txt| egrep &quot;a.&#123;2&#125;&quot; 123a baaaa abcbbb afc “a.{4,6}” 表示匹配以a开头的后面任意4 - 6个单个字符，包括空格。 cat a.txt| egrep &quot;a.&#123;4,6&#125;&quot; 123bbb aaaaaabd efdddkkk baccccd “ * “ 任意匹配前面的字符出现0次或者任意，贪婪模式, 匹配*号前面的字符任意次，. *表示任意长度任意字符，包括空格。 cat a.txt| egrep &quot;aa.*&quot; 12aad daABC baa “ + “ 至少一次表示前面字符出现1次以上. cat a.txt | egrep &quot;[abc]+&quot; 123abcdeadebbb 相当于 cat a.txt| egrep &quot;[abc]&quot; cat a.txt | egrep &quot;abc+&quot; 123abcabccc ddd abc “ ? “ 可有可无匹配其前面的字符0或1次,即前面的字符可有可无。 cat a.txt| egrep &quot;ab?&quot; 123abadd aad “{ }”次数区间注意，在使用grep基本正则表达式要带\\转义字符，即\\&#123;4,6\\&#125;，这里以拓展正则表达式为例，就不用带转义字符。 {m} ，匹配前面的字符m次。{m,n} ，匹配前面字符至少m次，最多n次。 cat a.txt| egrep &quot;abcd&#123;2,3&#125;&quot; 12ef abcddabcdddef “ | “或者 cat a.txt| egrep &quot;a|bc&quot; 12bc asdd bcd ^patten$ 模式匹配 ^a$表示只匹配以a这个字符开头和结尾的行。 cat a.txt | egrep &quot;^a$&quot; “\\“ 转义“\\“表示是转义字符，就是把元字符转义为普通字符，比如\\\\表示普通符号”\\“，把普通字符转换为特殊意义符号，比如”\\n”表示把普通字符n转义为换行符。 \\&lt;或\\b ，单词左侧，表示以该单词为词首\\&gt;或\\b ，单词右侧，表示以该单词为词尾\\&lt;PATTERN\\&gt; ，匹配整个单词 “[ ]”方括号表达式[abc] 表示 a，b，c任意一个，实际上，[abc] &#x3D; “a|b|c”&#x3D;(a|b|c)。 示例： [a-z] 表示小写字母 [A-Z] 表示大写字母 [0-Z] 表示数字和字母 egrep (ab|ba) a.txt 12abd efgacd baef 12([0-9])|([0][0-9])|([1][0-9])#表示匹配0-9或者00-09或者10-19范围的字符。 ^在方括号里面和外面的区别方括号里面：表示对字符取反，排除某些字符。 方括号外面：表示以某字符开头。 示例：查找不是以数字开头的行 行开头可能是字母或特殊字符。 cat a.txt| egrep &quot;^[^0-9]&quot; []和 {}组合使用 [0-9]{2} 表示0-9里面可以取2次的意思。 [0-9]{2,5} 表示从0-9里可以取2-5次的数字，至少2个数字，最多5个。 [0-9]{2,} 表示从0-9里可以取两次以上，最少2次 a{2} 表示花括号前面的a连续出现两次。 abc{2}表示abc中的c出现2次。 案例：从文本里面过滤出所有邮箱地址 root@localhost lianxi]# cat mail.txta a1@qq.com aab 2b@sina.com bbc c3@163.com ccd 4d@163.com dd 写一个表示邮箱的正则，过滤邮箱。邮箱地址：字符串1@字符串2.字符串3 字符串1：a-Z_0-9 字符串2：0-Z 字符串3：a-Z cat mail.txt | grep -o &quot;[0-Z$_]+@[0-z]+.[0-z]+&quot; awk-F，字段分隔符，默认为空格 -f，从脚本中读取命令 1）以冒号为分割，显示第一列和第三列的内容： awk -F ：&#39;&#123;print $1 &quot;\\t&quot; $3&#125;&#39; a.txt 2）以冒号为分割，显示UID大于500的用户信息： awk -F : &#39;$3&gt;500&#39; /etc/passwd 3）以冒号为分割，搜索含root关键字的所有行： awk -F &#39;/root/&#39; /etc/passwd 4）以冒号为分割，搜索UID大于500的用户，并显示sh awk -F : &#39;$3&gt;500&#123;print $7&#125;&#39; /etc/passwd 5)BEGIN AND awk -F : &#39;BEGIN&#123;print &quot;name \\t uid&quot;&#125;&#123;print $1 &quot;\\t&quot; $3&#125;END&#123;print&quot;from /etc/passwd&quot;&#125;&#39; /etc/passwd grep用法: grep [选项] PATTERN [FILE] 在每个 FILE 或是标准输入中查找 PATTERN。默认的 PATTERN 是一个基本正则表达式(缩写为 BRE)，也可以是拓展正则表达式。 例如: grep -i ‘hello world’ menu.h main.c options: -e : 使用正则表达式，用于指定多个搜索模式。 -E：使用拓展表达式 -i : ignore-case忽略大小写 -v: 反转匹配。 -w, –word-regexp ，强制 PATTERN 仅完全匹配字词。 -x：完全匹配整行内容，包括行首行尾空格内容都要完全匹配。 -f : 指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式。 -c： 输出每个文件所匹配到的行数。 -r：递归搜索匹配内容 -L：列出不满足匹配要求的文件名，不输出行内容 -l ： 列出满足匹配要求的文件名，不输出行内容。 -z ：匹配一个 0 字节的数据行，但不是空行。 -m n：当匹配内容的行数达到n行后停止搜索,并输出停止前搜索到的匹配内容。 -o: 只输出匹配的具体字符串,匹配行中其他内容不会输出。 -q：安静模式,不会有任何输出内容,echo $?查找到匹配内容会返回0,未查找到匹配内容就返回非0 -s：不会输出查找过程中出现的任何错误消息。 输出线前缀控制： -b：输出每一个匹配行或字符串时附上偏移量(从文件第一个字符到该匹配内容之间的字节数) -n：输出匹配内容的同时输出其所在行号。 -H：在每一个匹配行之前加上文件名一起输出。 -h：不带文件名输出。 -T：在匹配信息和其前的附加信息之间加入tab以使格式整齐。 上下文线控制选项： -A n：匹配到搜索到的行以及该行下面的n行 -B n：匹配到搜索到的行以及该行上面的n行 -C n：匹配到搜索到的行以及上下各n行 案例1：在&#x2F;home目录下查找所有内容含abc的文件名 grep -rl abc * 案例2：统计在passwd和shadow文件中含root的行数 grep -c root /etc/passwd /etc/shadow sed sed 全名为 stream editor，流编辑器，用程序的方式来编辑文本，功能相当的强大。是贝尔实验室的 Lee E.M 在 1974年开发完成，目前可以在大多数操作系统中使用。与vim等编辑器不同，sed 是一种非交互式编辑器，它使用预先设定好的编辑指令对输入的文本进行编辑，完成之后再输出编辑结构。 sed会一次处理一行内容，处理时，把当前处理的行存储在临时缓冲区中，成为”模式空间”pattern space，接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾，文件内容并没有改变。 用法：sed [options] ‘command’ file，options有-n，-e，-i，-f，-r选项。 -n 使用安静模式，加入-n 后只打印被匹配的行。-e 多重编辑，命令顺序会影响结果。-r 使用扩展正则表达式。-i 将操作结果写入文档，不在屏幕上输出。-f 指定一个 sed 脚本文件到命令行执行。 COMMNAD: 123456789101112131415a 在当前行后添加一行或多行c 用新文本修改（替换）当前行中的文本d 删除行i 在当前行之前插入文本p 从暂存区打印行s 用一个字符串替换另一个h 把模式空间里的内容复制到暂存缓存区H 把模式空间里的内容追加到暂存缓存区g 取出暂存缓冲区里的内容，将其复制到模式空间，覆盖该处原有内容G 取出暂存缓冲区里的内容，将其复制到模式空间，追加在原有内容后面l 列出非打印字符n 读入下一输入行，并从下一条命令而不是第一条命令开始处理q 结束或退出 sedr 从文件中读取输入行！ 对所选行之外的所有行应用命令 1）安静打印 sed -n &#39;p&#39; a.txt 或sed &#39;r&#39; a.txt 2）每行打印两遍输出 sed &#39;p&#39; a.txt 3）只输出第2到5行，原文件内容不变 sed -n &#39;2,5p&#39; a.txt 4）打印第4行后退出 sed &#39;4q&#39; a.txt 5）搜索指定内容并打印 找到含abc的行并把该行输出： sed -n &#39;/abc/p&#39; a.txt 注意与sed &#39;/abc/p&#39; a.txt的区别，这是全部输出并把这行打印2遍。 6）删除 删除第2,到4行的数据： sed &#39;2,4d&#39; a.txt 删除含abc的行： sed &#39;/abc/d&#39; a.txt 7）追加a和插入i 在第二行下插入abc sed &#39;2a abc&#39; a.txt 在第二行上插入abc sed &#39;2i abc&#39; a.txt 8）整行替换 替换2,3,4行为abc sed &#39;2,4c abc&#39; a.txt 9）字符串替换 全局替换将文件中的abc替换为a字符,g(global) sed &#39;s/abc/a/g&#39; a.txt 仅换将文件中第3行的abc替换为a字符 sed &#39;3s/abc/a/g&#39; a.txt 多条件替换： 将abc和def替换为a字符 sed -e &#39;s/abc/a/g;s/def/a/g&#39; a.txt 10）结果写入 使用-i选项，将原本输出到屏幕的结果写入文档。 sed -i &#39;/abc/p&#39; a.txt 11）从文件读入 子命令r，类似于a，也是将内容追加到指定行的后边，只不过r是将指定文件内容读取并追加到指定行下边。 例：sed &#39;2r b.txt&#39; a.txt 将b.txt文件内容读取并插入到a.txt文件第2行的下边。 其他文本处理命令nl 编写行号nl [options] [file]，默认空行不统计 -b，选择样式，a所有、t非空行、n不显示、BRE正则(正则匹配的行才显示行号) -n，–number-format&#x3D;格式，根据指定格式插入行号。 -w, –number-width&#x3D;数字，为行号使用指定的栏数。 -s, –number-separator&#x3D;字符串，可能的话在行号后添加字符串。 格式是下列之一: ln 左对齐，空格不用0 填充 rn 右对齐，空格不用0 填充 rz 右对齐，空格用0 填充 nl -b a a.txt，统计a.txt中所有行， wc词数统计wc [options] [file] wc a.txt 1234567897 14 74 a.txt#行数 字（单词）数 字节数$1 1111 aaa$2 22222 bbb$3 33333 cccc$4 44444 ddd$5 bbb aaaaa$6 abd efddd$7 kkk baccccd options: -w，只统计文件中单词数 -m，字符数 -c，统计字节数 -L，显示最长行长度（可见字符加空格） -l，行数 sortsort a.txt，文本排序，默认按首字母、第一个数字顺序排序。 options: -n，按数值大小排序。 -r，逆序排列。 -t，指定分隔符 -k，选取分隔后的哪一列 案例：按a.txt文件中第三列数字大小进行排序输出 sort -k 3 -n a.txt uniquniq a.txt，去连续重行。 -d，只打印重复的行 -u，只打印不重复的行 -c，统计重复行的出现次数","categories":[{"name":"linux","slug":"linux","permalink":"https://hawkezou.github.io/categories/linux/"}],"tags":[]},{"title":"Git入门","slug":"Git入门","date":"2023-12-01T07:16:09.000Z","updated":"2026-02-11T15:22:46.996Z","comments":true,"path":"2023/1201/","permalink":"https://hawkezou.github.io/2023/1201/","excerpt":"本文介绍的git版本控制、配置、命令操作、分支和文件状态等内容","text":"本文介绍的git版本控制、配置、命令操作、分支和文件状态等内容 版本控制本地版本控制：在本地记录每一次版本更新。 集中版本控制：版本数据都保存在单一服务器，不联网就看不到版本信息。SVN 分布式版本控制：所有的版本信息都同步到本地的每个用户，可以离线在本地提交，只需在联网时push。Git SVN与Git的区别： SVN 是集中式的；Git 是分布式的 SVN 的分支操作成本（创建&#x2F;删除&#x2F;合并）比 Git 高 SVN 是存储变更差异；Git 是存储文件快照 SVN必须联网操作，只有服务器上的版本控制；Git支持离线操作，有本地的版本控制 git配置1）git\\mingw64\\etc\\gitconfig ，–system系统级 2）C:\\Users\\用户\\.gitconfig ，–global全局 Git branch 获取分支列表 ，列表保存到refs&#x2F;heads&#x2F;master 下面。 git config -l，配置清单 git config --system --list，系统配置 git config --global --list，全局配置（用户配置） 安装好git后，设置用户名和邮箱（必要）： 12git config --global user.name &quot;xxx&quot;git config --global user.email &quot;xxx@qq.com&quot; 配置ssh公私钥连接远程仓库： 在c:&#x2F;Users&#x2F;用户&#x2F;.ssh下打开git bash，运行ssh-kengen生成公私钥，将pub公钥粘贴到远程仓库配置中。 工作区域git本地有四个工作区域：工作目录、暂存区(stage&#x2F;index)、资源库(repository)、远程仓库(remote repository)。 工作区：平时写代码项目文件的目录。 index&#x2F;stage：存放提交的文件列表信息的文件。 Local R本地仓库：存放提交的所有版本信息，HEAD指针总是指向当前分支。 Remote：托管代码的远程服务器。 文件状态untracked：未加入到本地库中，不参与版本控制，使用git add变为staged状态 unmodify：文件已入库，未修改。被修改则变为modified文件或git rm移除版本库变为untracked状态。 modified：文件已修改。通过git add变为staged状态，或通过git checkout放弃修改回到unmodify状态。 staged：暂存状态。执行git commit提交到版本库中，文件变为unmodify状态，执行git reset HEAD filename取消暂存，文件变为modified状态。 git对象模型在git系统中有四种对象： commit：指向一个tree，纪录了文件操作，作者，提交者信息； tree：对象关系树，管理tree和blob的关系； blob：保存文件内容； tag：标记提交。 基础命令git init，本地创建一个新的项目。 git clone [url]，克隆远程仓库上的项目代码。 git rm/mv [file]，删除移动文件 git status [xx]，查看文件状态。 git commit -m xxx，提交暂存区中的内容到本地仓库，-v提交时显示diff信息。 git branch，查看本地分支，-r查看远程，-d [name]删除分支，-rd删除远程分支 git branch [bname]，新建分支 12# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch] git merge [branch]，合并分支到当前分支。 git checkout [branch]或git switch，切换到指定分支，实际是移动HEAD指针。 git checkout [file]，恢复暂存区文件到工作区。 git reset --hard [版本号]，版本穿梭(切换版本)。 git log，显示当前分支版本历史，-S [key]根据关键词搜索提交历史，–follow [file]显示某文件的版本历史，–oneline简洁显示。 git reflog，显示当前分支的最近几次提交。 git shortlog -sn，显示所有提交过的用户。 git blame [file]，显示文件被什么人什么时间修改。 git diff，显示工作区和暂存区的差异。 git show [commit]，显示某次提交的时间和内容变化。 git fetch [remote]，下载远程仓库变动到本地版本库。 git remote -v，显示所有远程仓库，add添加仓库，remove删除。 git pull [remote] [branch]，取回远程仓库分支的变化并与本地合并。 git push [remote] [branch]，推送本地分支到远程仓库。 master分支主要用于发布新版本，常用工作分支使用dev等分支。 推送失败，因为最新提交和你试图推送的提交有冲突，两者对同一文件同一地点进行了修改。先用git pull把最新提交从origin&#x2F;dev抓下来，然后在本地合并，解决冲突再推送或者进行git reset回滚。git pull也失败了，原因是没有指定本地dev分支与远程origin&#x2F;dev分支的链接，根据提示，设置dev和origin&#x2F;dev的链接。 1git branch --set-upstream-to=origin/dev dev 这回git pull成功，但是合并有冲突，需要手动合并，即vim编辑冲突的文件，删除特殊符号，决定保留哪些内容，wq保存后，提交暂存区，提交本地库，再push。 .gitignore忽略文件在目录下创建.gitignore文件，将某些文件排除在版本控制外。 #：注释。 tmp/*.txt：忽略tmp目录所有以.txt结尾的文件，不包括tmp/d/*.txt。 !：除了这个文件外忽略所有 /tmp：忽略除tmp文件夹外的其他文件 tmp/：忽略tmp目录下的所有文件 12345678910111213141516171819202122HELP.mdtarget/!.mvn/wrapper/maven-wrapper.jar!**/src/main/**/target/!**/src/test/**/target/### STS ###.apt_generated.classpath.factorypath.project.settings.springBeans.sts4-cache### IntelliJ IDEA ###.idea*.iws*.iml*.ipr IDEA集成Git将所有克隆下来的git项目或新创建的git项目文件拷贝到IDEA项目中即可。","categories":[{"name":"git","slug":"git","permalink":"https://hawkezou.github.io/categories/git/"}],"tags":[]},{"title":"docker实战","slug":"docker实战","date":"2023-11-22T03:38:31.000Z","updated":"2026-02-11T15:22:33.773Z","comments":true,"path":"2023/1122/","permalink":"https://hawkezou.github.io/2023/1122/","excerpt":"本文将讲述如何使用docker制作tomcat镜像并上传至阿里云，部署redis和springboot项目。","text":"本文将讲述如何使用docker制作tomcat镜像并上传至阿里云，部署redis和springboot项目。 制作tomcat镜像通过dockerfile制作一个tomcat镜像并发布到阿里云镜像仓库。 1、在用户工作的主目录中创建一个build&#x2F;tomcat文件夹 2、准备tomcat和jdk安装包上传到该文件夹下 3、在文件夹下创建一个README.txt文件并编写Dockerfile文件 touch README.txt vim Dockerfile 123456789101112131415161718192021FROM centos#本地基础镜像docker images查看是否有该镜像否则将失败MAINTAINER zzh&lt;xxxx@qq.com&gt;COPY README.txt /usr/local/ADD /root/build/tomcat/apache-tomcat-8.5.94.tar.gz /usr/local/ADD /root/build/tomcat/jdk-8u151-linux-x64.tar.gz /usr/local/RUN yum -y install vimRUN yum -y install net-toolsENV MYPATH /usr/localWORKDIR $MYPATHENV JAVA_HOME /usr/local/jdk1.8.0_151ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools/jarENV CATALINA_HOME /usr/local/apache-tomcat-8.5.94ENV CATALINA_BASH /usr/local/apache-tomcat-8.5.94ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/binEXPOSE 8080CMD /usr/local/apache-tomcat-8.5.94/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-8.5.94/logs/catalina.out 4、构建diytomcat镜像 docker build -t diytomcat . 5、创建容器运行 docker run -d -p 3355:8080 --name mytomcat01 -v /root/build/tomcat/test:/usr/local/apache-tomcat-8.5.94/webapps/test -v /root/build/tomcat/logs:/usr/local/apache-tomcat-8.5.94/logs diytomcat 6、测试运行 在linux主机测试：curl localhost:3355或直接访问。 7、上传至阿里云镜像仓库 docker login --username=xxx registry.cn-shanghai.aliyuncs.com #重命名镜像 docker tag 镜像 registry.cn-shanghai.aliyuncs.com/命名空间/仓库名:tag docker push registry.cn-shanghai.aliyuncs.com/命名空间/仓库名:tag Redis集群部署1、创建网络 docker network create redis --subnet 172.17.0.0/16 2、通过脚本创建redis配置 12345678910111213141516171819202122for port in $(seq 1 6); \\do \\mkdir -p /mydata/redis/node-$&#123;port&#125;/conftouch /mydata/redis/node-$&#123;port&#125;/conf/redis.confcat &lt;&lt; EOF &gt;/mydata/redis/node-$&#123;port&#125;/conf/redis.confport 6379bind 0.0.0.0cluster-enabled yescluster-config-file node.confcluster-node-timeout 5000cluster-announce-ip 172.17.0.1$&#123;port&#125;cluster-announce-port 6379cluster-announce-bus-port 16379appendonly yesEOFdonedocker run -p 637$&#123;port&#125;:6379 -p 16371:16379 --name redis-$&#123;port&#125; \\-v /mydata/redis/node-$&#123;port&#125;/data:/data \\-v /mydata/redis/node-$&#123;port&#125;/conf/redis.conf:/etc/redis/redis.conf \\-d --net redis --ip 172.17.0.1$&#123;port&#125; redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf docker run -p 6371:6379 -p 16371:16379 --name redis-1 \\ -v /mydata/redis/node-1/data:/data \\ -v /mydata/redis/node-1/conf/redis.conf:/etc/redis/redis.conf \\ -d --net redis --ip 172.17.0.11 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf 3、查看redis容器，进入容器 docker ps docker exec -it redis-1 /bin/sh 3、创建redis集群 redis-cli --cluster create 172.17.0.11:6379 172.17.0.12:6379 172.17.0.13:6379 172.17.0.14:6379 172.17.0.15:6379 172.17.0.16:6379 --cluster-relicas 1 4、查看集群 redis-cli -c cluster info cluster nodes SpringBoot微服务打包docker镜像1、将springboot项目打包为xxx.jar 2、编写Dockerfile文件 1234567FROM java:8MAINTAINER z&lt;xx@qq.com&gt;COPY *.jar /app.jarEXPOSE 8080ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;] 3、构建镜像 docker build -t myApp . 4、发布镜像，下载镜像运行 docker push myApp docker pull myApp docker run -d -p 8080:8080 --name X-WEB-APP myApp 5、测试 curl localhost:8080 拓展compose、swarm、Jenkins","categories":[{"name":"docker","slug":"docker","permalink":"https://hawkezou.github.io/categories/docker/"}],"tags":[]},{"title":"docker入门","slug":"docker入门","date":"2023-11-21T02:17:40.000Z","updated":"2026-02-11T15:22:23.514Z","comments":true,"path":"2023/1121/","permalink":"https://hawkezou.github.io/2023/1121/","excerpt":"什么是Docker Docker是内核级别的虚拟化，可以在一个物理机上可以运行很多的容器实例。服务器的性能可以被压榨到极致。Docker是基于Go语言开发的，开源项目。","text":"什么是Docker Docker是内核级别的虚拟化，可以在一个物理机上可以运行很多的容器实例。服务器的性能可以被压榨到极致。Docker是基于Go语言开发的，开源项目。 镜像（image）：docker镜像就好比是一个模板，可以通过这个模板来创建容器服务，镜像&#x3D;&gt;run&#x3D;&gt;容器，通过这个镜像可以创建多个容器（最终服务运行或者项目运行就是在容器中的）。 容器（container）：Docker利用容器技术，独立运行一个或者一个组应用，通过镜像来创建的。启动，停止，删除。 仓库（repository）：仓库就是存放镜像的地方。 官网：https://www.docker.com/文档地址：https://docs.docker.com/Doker镜像仓库地址：https://hub.docker.com/ Linux下安装docker1、需要的安装包 yum install -y yum-utils 2、设置镜像的仓库 yum config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 3、更新yum软件包索引。 yum makecache 4、安装 yum install docker-ce docker-ce-cli containerd.io 5、启动docker systemctl start docker&#96; 6、使用docker version查看是否安装成功 docker run hello-world 配置阿里云镜像加速登录阿里云，找到容器服务。找到镜像加速地址，配置使用。 12345678sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;&#123;&quot;registry-mirrors&quot;: [&quot;https://xxx.xxx.xxx.com&quot;]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker docker命令docker --help 帮助 docker version 版本 docker info 详细信息 docker stats实时查看容器运行情况 docker history IMAGEID查看镜像构建记录 镜像命令： docker images [-a所有镜像,-q只要镜像ID]查看本机镜像 docker tag 镜像id 新镜像名:tag标签 克隆命名新的镜像 docker search xxx 搜素镜像 1docker search mysql --filter=STARS=3000 [root@CentOS7 docker]# docker search mysql –filter&#x3D;STARS&#x3D;3000NAME DESCRIPTION STARS OFFICIAL AUTOMATEDmysql MySQL is a widely used, open-source… 14616 [OK]mariadb MariaDB Server is a high performing… 5573 [OK] docker pull xx 下载镜像，默认最新版（分层下载，节省开销，加快速度） 指定版本下载：docker pull mysql:5.7 docker rmi [-f] 镜像名/镜像ID 删除镜像 **删除所有镜像**文件： docker rmi -f $(docker images -aq) 生成镜像 docker commit 容器id xx镜像名，根据容器的changes生成一个镜像，-a，作者名；-m，信息。 docker build [options] 生成路径path，根据dockerfile生成镜像。 docker build [选项] 镜像名[:标签]或者上下文路径或者URL 所执行目录（.表示在当前目录执行） 例：docker build -f mydockerfile -t mytomcat . 上传提交镜像 docker push [OPTIONS] NAME[:TAG]，上传一个镜像到远程仓库。 Options: -a, –all-tags，将所有版本的镜像提交。 –disable-content-trust 忽略镜像提示。 -q, –quiet ，简洁生成。 上传到dockerhub 1）在hub.docker.com创建账号 2）登录账户：docker login -u xxx -p 3）上传镜像 docker push 镜像:tag 上传到阿里云 1）登录到阿里云，找到容器镜像服务 2）创建命名空间 3）创建容器镜像仓库 4）查看仓库基本信息，获取ip地址，按照操作指南执行 5）比如登录： sudo docker login --usename xxx registry.cn-beijing.aliyuncs.com 容器命令： 有了镜像才能创建容器。 运行容器 docker run [options] 镜像 ，创建容器运行镜像 --name， 命名容器，Repository:Tag --rm，退出时删除容器 -d ，以后台方式运行，若容器不向客户端提供服务则停止运行 -it ，交互方式运行，启动进入容器查看内容 exit或ctrl+d退出停止运行；ctrl + p + q退出不停止 -p ，指定容器端口，主机端口：容器端口 例1：交互式运行centos docker run -it centos /bin/bash #会进入容器的交互终端 docker run -itd centos /bin/bash #以后台交互方式运行容器，不会进入容器 后面的&#x2F;bin&#x2F;bash的作用是表示运行bash ,docker中必须要保持一个进程的运行，这个&#x2F;bin&#x2F;bash就表示启动容器后启动bash。 例2：以脚本方式运行centos镜像，每隔1秒启动容器。 docker run -d centos /bin/bash -c &quot;while true;do echo xxx;sleep 1 ; done&quot; 例3：以后台方式创建容器运行nginx镜像，并向外开放3344端口 docker run -d --name nginx01 -p 3344:80 nginx 查看容器 docker ps [options]，查看正在运行的容器 -a查看运行记录，-n=?显示最近运行的容器，-q显示ID docker container ls 删除容器 docker rm 容器id，删除容器；-f，强制删除 例：删除所有容器 docker rm -f $(docker ps -aq) 启动和停止容器 docker start 容器id docker restart 容器id docker stop 容器id docker kill id，强制停止运行 （生成）镜像 docker container commit 容器id xx镜像名，-a，作者名，-m，信息。 docker build [options] 生成路径path，根据dockerfile生成镜像。 docker build [选项] 镜像名[:标签]或者上下文路径或者URL 所执行目录（.表示在当前目录执行） -f指定dockerfile文件，-t命名镜像 例1：提交容器3fdf3rfe4生成镜像tomcat01 docker commit -a=&quot;xxx&quot; -m=&quot;xxx&quot; 3fdf3rfe4 tomcat01:1.0 例2：根据dockerfile生成镜像保存到当前目录 docker build -f /home/dockerfile -t myimage:1.0 . 其他命令： docker logs [options] 容器id，查看日志 Options: –details，显示详细信息-f, –follow ，实时输出日志–since ，显示在某个时间后的日志-n, –tail ，展示最后n行日志-t, –timestamps ,显示时间–until ,显示一个时间前的日志 docker top 容器id，查看正在运行的容器中的进程 docker inspect 容器id，查看容器的元数据(返回的JSON格式) docker exec -it 容器id /bin/bash，以新终端进入正在运行的容器 docker attach 容器id，进入容器正在运行的终端 docker cp 容器id:文件绝对路径 主机目的路径，从容器中拷贝文件到主机 docker pause 容器id 悬挂中断 docker unpause 容器id 部署安装Tomcat、EStomcat 1、下载镜像 docker pull tomcat:9.0 2、启动镜像 docker run -d --name tomcat01 -p 3355:8080 tomcat:9.0 3、进入tomcat容器中，配置&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;webapps目录 docker exec -it tomcat01 /bin/bash cp -r webapps.dist webapps 4、访问测试 docker ps curl localhost:3355 ES docker run -d --name es01 -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; -e ES_JAVA_OPTS=&quot;-Xms64m -Xmx512m&quot; elasticsearch:7.7.0 容器数据卷让容器内的文件数据与linux主机或容器之间同步互通，形成共享，修改容器配置文件时可直接在主机服务器上修改，不需要进入容器，实现容器数据持久化。 方式一、-v卷挂载命令 例：docker run -it -v 主机路径:容器内路径 centos /bin/bash 在主机上通过docker inspect 容器，查看mount挂载情况。 例：安装mysql同步数据 docker pull mysql:5.7 docker run -d -p 3304:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql_01 mysql:5.7 参数说明：-d后台运行，-p端口映射，-v卷映射，-e环境配置。 容器启动成功后在本地连接3304端口连接数据库。 匿名挂载：-v 容器内路径 docker run -d -p --name nginx01 -v /etc/nginx nginx 具名挂载：-v 卷名:容器内路径 docker run -d -p --name nginx01 -v nginx_01:/etc/nginx nginx 默认卷挂载到本地的/var/lib/docker/volumes/ 指定路径挂载：-v 本地路径:容器路径 docker run -d -p --name nginx01 -v /home/nginx01/:/etc/nginx nginx 卷管理 docker volume [options]，管理数据卷，参数说明： create ，创建一个卷；inspect，查看卷详细信息；ls，列出所有卷；prune，删除未使用的本地卷；rm，删除卷 方式二、dockerfile 1、创建一个dockerfile文件 vim dockerfile 2、编写dockerfile 1234567FROM centosVOLUME [&quot;volume01&quot;]CMD echo &quot;----end----&quot;CMD /bin/bash#解释FROM 镜像名:标签 #FROM指定基础镜像，其必须为Dcokerfile中第一条指令RUN 命令 #在该镜像中执行命令，如果执行多个命令用 &amp;&amp;连接起来 3、docker build 生成镜像文件 docker build -f /home/dockerfile -t 镜像名(repo):版本标签(tag) . 方式三、容器之间–volumes-from 创建一个容器docker02与其他容器共享数据。 docker run -it --name docker02 --volumes-from docker01 nginx 删除容器docker01数据依旧存在，因为它的数据在本地&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volume下。 DockerFiledockerfile用来构建镜像文件，命令脚本。 dockerfile指令： FROM #基础镜像MAINTAINER #维护者，姓名+邮箱RUN #镜像构建时需要运行的命令ADD #添加文件，若是压缩包则自动解压WORKDIR #镜像工作目录VOLUME #挂载目录EXPOSE #保留端口配置CMD #指容器启动需要运行的命令，只有最后一个生效，追加命令会覆盖ENTRYPOINT #指定容器运行时需要的命令，可以docker run时追加命令ONBUILD #当构建一个被继承的dockerfile时触发onbuild指令COPY #将主机文件拷贝到制作的镜像中ENV #构建时设置环境变量 例：编写一个mycentos镜像文件，生成镜像 vim mydockerfile-centos FROM centosMAINTAINER z&lt;zzh@163.com&gt;ENV MYWORKPATH /usr/localWORKDIR $MYWORKPATHRUN yum -y install vimRUN yum -y install net-tools EXPOSE 80CMD echo $MYWORKPATHCMD echo &quot;---end---&quot;CMD /bin/bash docker build -f mydockerfile-centos -t mycentos:1.0 . CMD与ENTRYPOINT比较 相同点： 1、只能写一条，如果写了多条，那么只有最后一条生效 2、容器启动时才运行，运行时机相同 不同点： ENTRYPOINT不会被运行的command覆盖，而CMD则会被覆盖，如果我们在Dockerfile种同时写了ENTRYPOINT和CMD，并且CMD是一个完整的指令，那么它们两个会互相覆盖，谁在最后谁生效。 docker网络docker网络是一种虚拟网络，网络为成对的bridge桥接模式。主机可与创建的容器进行通信，但是容器之间通信需要额外的操作。docker默认给容器分配一个虚拟内部ip地址，网络为docker0。 例：docker exec -it tomcat01 ping tomcat01 无法ping通，因为容器在docker0网络，无法通过容器名ping通。 ping不同的另一种原因： OCI runtime exec failed: exec failed: unable to start container process: exec: &quot;ping&quot;: executable file not found in $PATH: unknown 以上报错是因为docker创建的容器相当于一个miniLinux，很多命令和软件没有安装，包括network这一网络工具都没有。下载软件包只能通过apt-get或wget和curl命令。 docker network网络管理 docker network [options]，options如下： connect，连接容器到网络 create，创建网络 inspect ，查看网络 ls ，列出所有网络 rm ，删除网络 –link实现单向通信 运行tomcat02容器，使其能够与tomcat01通信。原理是在容器的&#x2F;etc&#x2F;hosts文件中配置了主机名与ip地址映射。 docker run -d --name tomcat02 --link tomcar01 tomcat 自定义网络 自定义网络支持通过容器名通信，创建一个自定义网络： docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 Mynet –net指定网络 使用自定义网络创建容器，在该网络中为容器分配ip： docker run -d --name tomcat02 --net Mynet tomcat 在该网络中的容器可以相互通信，可ping tomcat02。 容器-网络连接 如何让一个容器连接到另一个网络或者与另一个网络中的容器通信，可使用docker network connect，原理是将容器添加到该网络中。 docker network connect [OPTIONS] NETWORK CONTAINER Options: –alias 为网络添加作用范围scope –driver-opt 选择网络模式driver –ip 指定一个容器ip地址 –link list 添加到另一个容器的连接 –link-local-ip 为容器添加一个本地ip地址 docker network connect Mynet tomcat02，将tomcat02挂到Mynet网络。 可使用docker network inspect 查看网络中有哪些容器。","categories":[{"name":"docker","slug":"docker","permalink":"https://hawkezou.github.io/categories/docker/"}],"tags":[]},{"title":"linux进阶","slug":"linux进阶","date":"2023-11-14T01:11:52.000Z","updated":"2026-02-11T15:24:24.549Z","comments":true,"path":"2023/1114/","permalink":"https://hawkezou.github.io/2023/1114/","excerpt":"本篇介绍linux日志管理、内核升级、数据备份与恢复的相关内容。","text":"本篇介绍linux日志管理、内核升级、数据备份与恢复的相关内容。 linux系统文件结构： &#x2F; 根目录&#x2F;bin 存放必要的命令&#x2F;boot 存放内核以及启动所需的文件&#x2F;dev 存放设备文件&#x2F;etc 存放系统配置文件&#x2F;home 普通用户的宿主目录，用户数据存放在其主目录中lib 存放必要 的运行库&#x2F;mnt 存放临时的映射文件系统，通常用来挂载使用&#x2F;proc 存放存储进程和系统信息&#x2F;root 超级用户的主目录&#x2F;sbin 存放系统管理程序&#x2F;tmp 存放临时文件&#x2F;usr 存放应用程序，命令程序文件、程序库、手册和其它文档。&#x2F;var 系统默认日志存放目录录 日志管理rsyslogd日志管理服务，配置文件&#x2F;etc&#x2F;rsyslog.conf，各日志文件有： &#x2F;var&#x2F;log&#x2F;boot.log系统启动日志 &#x2F;var&#x2F;log&#x2F;cron记录定时任务 &#x2F;var&#x2F;log&#x2F;lastlog记录最后一次登录信息 &#x2F;var&#x2F;log&#x2F;message记录系统重要信息 &#x2F;var&#x2F;log&#x2F;secure记录验证授权信息 &#x2F;var&#x2F;log&#x2F;wtmp和&#x2F;var&#x2F;log&#x2F;btmp 记录登录和失败登录信息 &#x2F;var&#x2F;tuned&#x2F;ulmp&#x2F;记录当前登录用户的信息 日志类型auth #pam产生的日志 authpriv #ssh\\ftp等登录产生的日志 cron #时间任务 kern #内核 lpr #打印 mail #邮件 mark #服务内部信息 user #用户程序信息 uucp #主机通信 local 1-7 #自定义设备 日志级别由低到高： debug 调试信息 info 一般信息 notice 重要信息 warning 警告 err 错误 crit 严重错误 alert 修改 emerge 内核崩溃 none 不记录 日志轮替创建新的日志文件，删除旧的日志，日志轮替配置文件&#x2F;etc&#x2F;logrotate.conf。日志轮替依赖于系统定时任务，在&#x2F;etc&#x2F;cron.daily&#x2F;目录下有logrotate可执行文件。 keep 4 weeks worth of backlogsrotate 4 #共保存 4 份日志文件,当建立新的日志文件时,旧的将会被删。 use date as a suffix of the rotated file dateext #以日期为后缀 自定义日志轮替自定义日志轮替规则，如： &#x2F;var&#x2F;log&#x2F;wtmp { monthly create 0664 root utmp minsize 1M rotate 1} 1）直接在&#x2F;etc&#x2F;logrotate.conf中写入该日志轮替规则。 2）在&#x2F;etc&#x2F;logrotate.d&#x2F;目录中建立新的日志文件，在文件中写入轮替策略。 参数说明： daily，每天轮替 weekly，每周轮替 monthly ， 每月轮替 rotate 数字， 保留日志文件个数 compress ，轮替时对旧的日志压缩 create mode owner group ， 创建新日志时指定权限所有者所在组 mail address ，日志轮替时输出内容到指定邮件地址 missingok ， 若日志不存在则忽略该日志警告 notifepmty ， 若日志为空则不轮替 minsize 大小 ，日志大小达到最小值才会轮替 size 大小，日志只有大于指定大小才进行轮替 dateext ，使用日期作为日志文件后缀 sharedscripts， 在此关键字后脚本只执行一次 prerotate&#x2F;endscript，在日志轮替之前执行脚本 postrotate&#x2F;endscript ，在日志轮替之后执行脚本 内存日志journalctl 查看内存日志 journalctl -n 3，查看最近3条 journalctl –since 1:00 –until 1:30 ，查看某时间段日志 journalctl -p err，查看报错日志 journalctl -o verbose ，查看详细信息 journalctl _PID&#x3D;xxx _COMM&#x3D;sshd ，查看带某参数信息的日志 journalctl | grep sshd 内核升级将linux系统的内核升级到兼容的版本 uname -a：查看当前内核 yum info kernel -q：检测内核版本 yum update kernel：升级内核 yum list kernel -q：查看已安装的内核 数据备份和恢复2种方式： 1）把需要的文件用tar打包 2）dump和restore指令 若没有两个指令需要安装 yum -y install dump yum -y install restore dump分区备份，增量备份，备份上次增加或修改过的文件 dump -cu -[123456789] -f 备份后的文件 -T 日期 [目录或文件系统] 参数说明： -c，创建新的备份文件 -[0,1,2,3,4,5,6,7,8,9]，备份的层级，0为完整备份，0以上则备份上次修改或新增的文件，9以后再次轮替。 -f，指定备份后的文件名 -j，使用bizlib库压缩 -T，指定开始备份的时间和日期 -u，备份后在&#x2F;etc&#x2F;dumpdares中记录备份的文件系统，层级、日期时间 -t，指定文件名，若文件已备份则列出名称 -W，显示需要备份的文件及最后一次备份的层级时间 -w，只显示需要备份的文件 查看备份时间文件：cat &#x2F;etc&#x2F;dumpdates 应用案例： 案例1：将&#x2F;boot分区所有内容备份到&#x2F;opt&#x2F;boot.bak.bz2文件中，备份的层级为0 dump -0uj -f /opt/boot.bak.bz2 /boot/ 案例2：在&#x2F;boot下创建一个新的文件hello.txt，增量备份，备份层级为1 vi hello.txt dump -1uj -f /opt/boot.bak1.bz2 /boot/ 注意，dump不支持文件和目录的增量备份，只能0级备份 例：备份&#x2F;etc目录到&#x2F;opt&#x2F;etc.bak.bz2 dump -0j -f /opt/etc.bak.bz2 /etc/ restore恢复dump备份的数据文件。 restore [模式mode] [选项option] 首先指定一种模式执行，-C对比，-i交互，-r还原，-t查看文件。 选项：-f 备份文件，从dump备份文件中读取数据。 案例1：比较备份文件和原文件 restore -C -f /opt/boot.bak.bz2 案例2：查看备份了那些文件 restore -t -f /opt/boot.bak.bz2 案例3：还原备份文件&#x2F;opt&#x2F;boot.bak0.bz2到&#x2F;opt&#x2F;boottmp&#x2F;下 mkdir /opt/boottmp cd /opt/boottmp #恢复到第一次完全备份状态 restore -r -f /opt/boot.bak0.bz2 #若有增量备份文件boot.bak1.bz2则需要进行恢复，有几个恢复几个 restore -r -f /opt/boot.bak1.bz2 可视化管理bt宝塔可视化管理面板可以帮助运维人员提高效率，支持一键安装集群和数据库。 安装： yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh 安装成功后显示用户名和密码。 权限安全尽量使用普通用户登录服务器，执行root命令时使用sudo操作。对于重要的系统文件可以进行锁定，chattr +i /etc/passwd，使自己和他人无法操作文件。 使用SUID、SGID、Sticky设置特殊权限 使用chkrootkit&#x2F;rootkit hunter工具检查系统文件是否被修改或异常，监测root脚本，下载地址chkrootkit.org。 使用Tripwire检测系统文件完整性。 IO读写监控iotop可以监控磁盘读写情况，首先安装iotop，yum install iotop，iotop。","categories":[{"name":"linux","slug":"linux","permalink":"https://hawkezou.github.io/categories/linux/"}],"tags":[]},{"title":"找回mysql密码","slug":"找回mysql密码","date":"2023-11-13T06:16:30.000Z","updated":"2026-02-11T15:27:09.059Z","comments":true,"path":"2023/1113/","permalink":"https://hawkezou.github.io/2023/1113/","excerpt":"这篇文章记录了如何在Linux和windows下找回mysql密码。","text":"这篇文章记录了如何在Linux和windows下找回mysql密码。 linux下找回Mysql密码1、修改&#x2F;etc&#x2F;my.cnf文件 2、插入skip-grant-tables 3、重启mysqld服务 service restart mysqld 4、进入mysql mysql -u root -p 5、修改mysql数据库中user表的authentication_string字段 use mysql; update user set authentication_string=password(&quot;12345678&quot;) where user=&#39;root&#39;; #刷新权限 flush privileges; 6、退出mysql，再次修改my.cnf配置文件 #skip-grant-tables windows下找回mysql密码1、停止MySQL服务 首先，我们需要停止MySQL服务。 net stop mysql 2、修改配置文件 在MySQL停止的情况下，我们需要修改MySQL的配置文件以跳过密码验证。在MySQL的安装目录中，找到名为my.ini或my.cnf的配置文件，使用文本编辑器打开该文件。在配置文件中找到[mysqld]部分，在该部分下添加以下一行代码：skip-grant-tables 3、重启MySQL服务 现在，我们需要重新启动MySQL服务，并且由于我们已经修改了配置文件，MySQL将不再需要密码进行验证。以下是重启MySQL服务的步骤： net start mysql 4、登录MySQL并修改密码 登录MySQL数据库并修改账户密码。 mysql -u root 如果使用的是其他账户，请将root替换为其他账户名。登录成功后，我们可以使用以下命令来修改密码： ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;new_password&#39;; 修改密码成功后，可以退出MySQL数据库。 5、恢复配置文件 打开MySQL的安装目录，打开之前修改的配置文件（my.ini或my.cnf），删除或注释掉之前添加的一行。","categories":[{"name":"mysql","slug":"mysql","permalink":"https://hawkezou.github.io/categories/mysql/"}],"tags":[]},{"title":"Linux常用指令","slug":"Linux常用指令","date":"2023-11-12T09:49:23.000Z","updated":"2026-02-11T15:24:11.504Z","comments":true,"path":"2023/1112/","permalink":"https://hawkezou.github.io/2023/1112/","excerpt":"在学习linux的过程中，有一些指令经常使用，下面是学习笔记。","text":"在学习linux的过程中，有一些指令经常使用，下面是学习笔记。 登录注销su - 用户名，logout 注销用户登录（运行级别3下有效） 关机重启shutdown -h now 立刻关机shutdown -h 1 1分钟后关机，默认一分钟shutdown -r now 现在重启shutdown -c 取消关机，取消重启halt关机reboot重启sync同步内存数据 Vim编辑器快捷键拷贝当前行 ：yy粘贴：p删除当前行: dd，删除以下5行：5dd查找某个单词：命令行下&#x2F;关键词，回车，n查找下一个。设置文件行号：命令行set nu撤销：一般模式下，u移动到20行：一般模式下，输入20,然后shift+g移动到最末行最首行：一般模式下G， gg 文件目录类ls :显示当前目录下的文件，-a 所有文件,-l 列表展示信息,-h 方便浏览cat xxx:安全打开，只读vi xxx:用vim编辑器打开文件more: 分页打开less： 打开大文件head -n 11 xx 打开文件开头11行，默认10行tail -n 11 xxx 打开文件末尾11行 tail -f xxx实时监控文件 history: 命令执行记录history 10最近执行的10条指令!488执行第488条指令 rm: 删除文件 -f 强制删除, -r逐层递归删除文件cp: 复制文件或覆盖，-r递归复制整个文件夹 ，&#x2F;cp强制覆盖mv: 移动文件、重命名touch：创建空文件mkdir:创建文件夹rmdir:删除文件夹ln: 符号连接，软连接ln -s /root/ myroot 打包、解包、压缩和解压指令Linux 主要有3种压缩方式，zip，gzip，xz是压缩解压指令。gzip：压缩速度最快，应用广泛bzip2：压缩成的文件小xz：最新的方式，提供最佳的压缩率 tar是打包指令： -c，进行打包-v，显示详细信息-f，指定压缩或解压的文件包-z，支持gzip压缩和解压，-j支持bzip压缩，-J支持xz压缩-x，解包文件-t，显示文件的内容-k，保留原有文件不覆盖-C，切换到指定目录 案例1：压缩多个文件 tar -zcvf pc.tar.gz &#x2F;home&#x2F;pig.txt &#x2F;home&#x2F;cat.txt 案例2：将&#x2F;home文件夹压缩 tar -zcvf myhome.tar,gz &#x2F;home&#x2F; 案例3：将myhome.tar.gz解压到当前目录 tar -zxvf myhome.tar.gz 案例4：将myhome.tar.gz解压到&#x2F;opt&#x2F;tmp2下 mkdir &#x2F;opt&#x2F;tmp2tar -zxvf &#x2F;home&#x2F;myhome.tar.gz -C &#x2F;opt&#x2F;tmp2 1、tar打包：tar cvf xxx.tar xxx文件解包：tar xvf xxx.tar 2、.gz压缩：gzip xxx解压：gunzip xxx.gz 3、.tar.gz 和 .tgz压缩：tar zcvf xxx.tar.gz xxxx解压：tar zxvf xxx.tar.gz 4、.tar.bz2压缩：tar jcvf xxx.tar.bz2 xxx解缩：tar jxvf xxx.tar.bz2 5、.zip压缩：zip xxx.zip xxx解压：unzip xxx.zip 例：zip -r myhome.zip &#x2F;home&#x2F;把home文件夹及子文件压缩unzip -d &#x2F;opt&#x2F;tmp myhome.zip 把myhome.zip解压到&#x2F;opt&#x2F;tmp 6、.rar压缩：rar a xxx.rar xxx解压：rar x xxx.rar 7、.bz2压缩： bzip2 -z xxxx解压1：bzip2 -d &#x2F;xxx xxx.bz2解压2：bunzip2 xxx.bz2 输出重定向&gt;和追加&gt;&gt;指令ls -l &gt; info.txtcat 文件1&gt; 文件2echo “xxx”&gt;文件 echo $PATH $HOSTNAME 时间日期类date: 打印当前时间 date &quot;+%Y-%m-%D&quot;打印年月日date set &quot;+%Y-%m-%D %H:%M:%S&quot; cal :打印当前日历 cal 2023打印2023年日历 搜索查找类find :-name ；-user； -size find /home -name hello.txt -user root找到/home目录下用户名为root的hello.txt文件find / -size +200M 在根目录下找大于200M的文件 locate: 无需遍历整个系统，查询快 updatedblocate hello.txt 定位hello.txt所在的目录 grep: 过滤查找 cat hello.txt | grep -n &quot;hello&quot; 打开hello.txt并查找hello所在行 案例1：在&#x2F;home目录下查找所有内容含cat的文件名 grep -r &quot;cat&quot; /home | cut -d &quot;:&quot; -f 1 案例2：请统计&#x2F;home目录下所有文件个数及文件的总行数 find -r /home -name &quot;*.*&quot; | wc -l find -r /home -name &quot;*.*&quot; |xargs wc -l 用户管理添加用户：useradd xxx删除用户：userdel xxx修改用户所在组：usermod -g 新组名 user修改用户登录目录：usermod -d 目录 user查看用户是否存在：id user查看当前用户：whoami 文件所有者所在组添加&#x2F;删除组：groupadd&#x2F;groupdel查看了文件的所有者：ls -ahl xxx改变文件的所有者：chown 新用户 文件名&#x2F;目录改变文件所在组：chgrp 新组名 文件名&#x2F;目录改变文件目录所有者所在组：chown newowner:newgroup 加上参数-R将目录下所有文件都会改变 权限管理-rw-r--r--. 1 root root 239 10月 24 10:13 hello.java （1）drwxr-xr-x. 2 root root 4096 10月 23 13:56 桌面 （2） r:读 w:写 x:执行 [4,2,1] r+w+x&#x3D;7 0~9位： 1）0位：文件类型，-文件，d目录，c字符设备(键盘鼠标)，b块设备(硬盘)2）1~3位：所有者权限3）4~6：所在组权限4）7~9：其他组权限 [rwx]作用于文件r:只读cat； w:写修改但不能删除 ；x:可执行[rwx]作用于目录r: 查看目录内容ls，但对文件有独立的权限; w：可在目录内创建、删除文件 ; x：可进入目录cd 注（1）中数字1表示文件数或子目录数，第一个root为用户，第二个为用户组，239为文件大小单位字节，“10月 24 10:13”为最后修改日期。 变更权限chmod修改文件目录的权限, u所有者，g所在组，o其他组，a所有人(1)+ ，-， &#x3D;chmod u&#x3D;rwx,g&#x3D;rx,o&#x3D;x 文件名&#x2F;目录 ：给用户rwx，所在组rx，其他组xchmod o+x 文件名&#x2F;目录 ：给其他组执行权限chmod a-x 文件名&#x2F;目录 ：所有人剥夺执行权限 (2)通过数字变更 r：4 w：2 x：1 rwx&#x3D;7，rw：6，rx:5，r：4，wx：3，w：2，x：1 无权限：0 chmod u=rwx,g=rx,o=x 文件名/目录相当于chmod 751 文件名/目录 crond任务时间调度设置任务调度文件：&#x2F;etc&#x2F;crontab 设置个人调度任务：执行crontab -e指令，接着输入任务到调度文件。如： */1 * * * * ls -l /etc &gt; /tmp/to.txt 每小时每分钟执行ls -l /etc &gt; /tmp/to.txt 五个占位符参数： 第一个*：一小时中第几分钟，0~59 第二个*：一天中第几小时，0~23 第三个*：一个月中第几天，1~31 第四个*：一年中第几个月，1~12 第五个*：一周中星期几，0~7（0,7为星期日） crond相关指令： -r终止任务调度（删除），-e编辑任务，-l列出任务 service crond restart重启crond调度 特殊符号说明： * ：任何时间，若第一个为*表示每分钟执行。 ,：逗号代表不连续的时间，0 8,12,16 * * *表示每天8点12点16点0分执行。 -：表示连续时间范围， 0 5 ** 1-6周一到周六凌晨五点执行。 */n：表示每隔多久执行，*/10 表示每隔10分钟执行。 案例1：每隔一分钟将当前时间和日期追加到&#x2F;home&#x2F;mycal中1）vim my.sh写入date &gt;&gt; /home/mycal和cal &gt;&gt; /home/mycal2) 给my.sh增加执行权限，chmod u+x my.sh3) crontab -e写入任务*/1 * * * * /home/my.sh 案例2：每天凌晨2点备份数据库mydb1）crontab -e2）0 2 * * * mysqldump -u root -p 123456 mydb &gt; &#x2F;home&#x2F;db.bak at定时任务at命令是一次性定时任务，at的守护进程atd检查作业队列，以后台模式运行，每60秒检查一次，若时间与当前时间匹配则运行。使用at要保证atd在运行，使用以下命令查看进程： ps -ef | grep atd at [选项] [时间] atq查询任务，atrm删除Ctrl+D结束命令输入 at时间格式：1）hh:mm(04:00)当天或第二天执行2）midnight&#x2F;noon&#x2F;teatime3）12小时制，如9am ,3pm4）指定具体日期：month day或mm&#x2F;dd&#x2F;yy或dd.mm.yy，指定日期必须在时间后面04:00 2023-11-15）相对计时：now + count time-units，now是当前时间，count是数量，tim-units是时间单位，minutes,hours,days,months,weeks。 now + 5 days 五天后5pm + 2 days 两天后下午五点 6）today、tommorow 案例1：每天下午5点，把时间输入到&#x2F;root&#x2F;data.log里 at 5pm tommorow date &gt; /root/data.log 案例2：2天后五点执行&#x2F;bin&#x2F;ls &#x2F;home1)at 5pm + 2 days2)/bin/ls /home 案例3：删除5号at任务atrm 5 磁盘分区磁盘分区和文件系统之间通过挂载mount联系起来，分区构成整个文件系统。 查看设备挂载情况：lsblk -f Linux硬盘分为IDE和SCSI类型，目前主要为SCSI。 对于IDE硬盘，驱动器标识符为hdx~，hd表示IDE设备类型，x表示盘号(a主盘，b从属盘,c…)，~表示分区，前四个分区用1-4数字表示，5开始为逻辑分区。如hda2表示第一个IDE硬盘的第二个分区。 对于SCSI&#x2F;SATA硬盘，标识为“sdx~”，sd为SCSI硬盘类型，其余和IDE表示类似。 对于NVMe硬盘，以nvme0n开头，nvme0n1p1是第一块硬盘的第一个分区，而nvme0n2p3则是第二块硬盘的第三个分区。 案例：挂载一块硬盘 1.虚拟机添加硬盘 在虚拟机设置中在设备列表里添加一块硬盘，完成后重启才能识别。 2.分区 fdisk /dev/sdb m 显示命令列表p 显示磁盘分区，fdisk -ln 新增分区d 删除分区w写入并退出q 直接退出 3.格式化 格式化文件系统获得UUID：mkfs -t ext4 /dev/sdb1 4.挂载 将分区和文件目录联系起来：mount 设备名 文件目录 mount /dev/sdb1 /newdisk umount 设备名或挂载目录(mountpoint) umount /dev/sdb1或umount /newdisk 但是重启后失效 5.设置自动挂载 实现永久挂载，修改&#x2F;etc&#x2F;fstab文件，添加设备，重启或执行mount -a立刻生效。 /dev/sdb1 /newdisk 0.0 磁盘情况查询1）查看磁盘整体使用情况 ：df -h 2）查询指定目录的磁盘占用情况 du -h 默认当前目录 -s 占用大小汇总-h 带计量单位-a 带上文件–max-depth&#x3D;1子目录深度-c 列出明细，增加汇总值 案例1：查询&#x2F;opt目录下一层子目录的磁盘使用情况 du -h --max-depth=1 /opt 3）查看内存使用情况：free -h 查看系统负载命令：uptime-p，显示系统运行时间，-s，显示系统启动时间 1215:32:56 up 6:59, 2 users, load average: 0.04, 0.03, 0.0515:32:56当前时间，up运行时间，2个用户，过去1、5、15分钟负载 5）虚拟内存状态、io状态vmstat\\iostat 工作实用指令1）统计&#x2F;opt文件夹下文件的个数 ls -l /opt | grep &quot;^-&quot; | wc -l 2）统计&#x2F;opt文件夹下目录的个数 ls -l /opt | grep &quot;^d&quot; | wc -l 3）统计&#x2F;opt文件夹下文件的个数，包括子文件夹下的文件 ls -lR /opt | grep &quot;^-&quot; | wc -l 4）统计&#x2F;opt文件夹下目录的个数，包括子文件夹下 ls -lR /opt | grep &quot;^d&quot; | wc -l 5）树状显示目录结构 yum install treetree /opt Linux网络配置查看网络配置：ifconfig或ip addr测试网络连通：ping ip地址 1）DHCP动态路由分配 自动分配，ip不会冲突，但是不固定。 2）静态分配IP(固定IP) 修改网卡配置文件，vi /etc/sysconfig/network-scripts/ifcfg-ens33，将ip地址配置成静态的，添加固定ip如下。 DEVICE&#x3D;ens33 (设备网卡名)HWADDR&#x3D;00:0c:2x:6x:0x:xx (MAC地址)TYPE&#x3D;ethernet (网络类型)UUID&#x3D;029ad-d12e-dw23-32da-1d2c (随机id)ONBOOT&#x3D; yes (系统启动时网络接口是否开启)BOOTPROTO&#x3D;static (ip配置方法)[none;static;dhcp;bootp]IPADDR&#x3D;192.168.157.129 (ip地址)GATEWAY&#x3D;192.168.157.2 (网关)DNS1&#x3D;192.168.157.2 (DNS解析器) 在虚拟机中找到虚拟网络编辑器，找到该网络如vmnet8，修改子网ip地址为192.168.157.0，修改NAT配置中网关地址，点击确定再点击应用。之后重启系统或者输入service network restart生效。 设置主机名和HOST映射查看主机名：hostname修改主机名：vi /etc/hostname，重启 设置HOST映射： 1）在windows的”C:\\Windows\\System32\\drivers\\etc\\hosts”下添加ip与主机名的映射：192.168.157.129 CentOS7 ping CentOS7可ping通。windows cmd窗口ipconfig /displaydns列出本地dns缓存，ipconfig /flushdns清除缓存。 2）linux在&#x2F;etc&#x2F;hosts文件修改 监控网络状态netstat [options]，选项说明： -an，按一定顺序输出 ；-p，显示哪个进程在调用 例如：查看sshd服务的信息 netstat -anp |grep sshd ping ip，监测网络连接。 案例：统计连接到服务器的各个ip情况，并按连接数从大到小排 netstat -an | grep ESTABLISHED | awk -F &quot; &quot; &#39;&#123;print $5&#125;&#39; | cut -d &quot;:&quot; -f 1 | sort |uniq -c | sort -nr 案例：使用tcpdump监听本机来自192.168.300.1，端口为22的通信，并保存到tcpdump.log tcpdump -i ens33 host 192.168.300.1 and port 22 &gt;&gt; /opt/tcpdump.log 进程管理1、查看进程信息 ps指令： ps -A 显示当前所有进程信息ps -a 显示所有终端机下执行的程序ps -u 以用户的格式显示进程信息ps -x 显示后台进程运行的参数ps -aux | grep sshd 查看也没有sshd服务 USER进程执行用户，PID进程号，%CPU进程占CPU百分比，%MEM进程占物理内存的百分比，VSZ进程占虚拟内存的大小，RSS进程占物理内存的大小KB，TTY终端名称，STAT进程状态(S睡眠，R正在运行，Z僵尸进程，D短期等待，T被跟踪或被停止，&gt;高优先级)，START进程开始执行时间，TIME占用CPU时间，COMMAND启动进程的命令或参数。 ps -ef 以全格式显示所以进程，不会截断，System V格式。 ps -ef | grep sshd UID用户ID，PID进程号，PPID父进程PID，TTY终端设备号。 &#x2F;&#x2F;查找进程状态信息cat &#x2F;proc&#x2F;pid&#x2F;status&#x2F;&#x2F;查找进程启动命令行cat &#x2F;proc&#x2F;pid&#x2F;cmdline 2、终止进程 kill [option] PID ，终止进程，option&#x3D;-9表示强制终止。killall 进程名 ，终止该进程及子进程。 案例1：踢掉某个非法登录用户tomroot 1143 1 0 16:23 ? 00:00:00 &#x2F;usr&#x2F;sbin&#x2F;sshd -Droot 1741 1143 0 16:23 ? 00:00:00 sshd: root@pts&#x2F;0root 5031 1143 1 20:03 ? 00:00:00 sshd: tom [priv]tom 5043 5031 0 20:03 ? 00:00:00 sshd: tom@pts&#x2F;1 kill 5031 案例2：终止远程登录服务器sshd，合适时重启服务 kill 1143/bin/systemctl start sshd.service 案例3：终止多个gedit killall gedit 案例4：强制杀死终端 root 5277 5267 0 20:16 pts&#x2F;1 00:00:00 bash kill -9 5277 3、查看进程树 pstree ，-p 显示进程号，-u显示用户 4、top动态监控进程（性能监视器，任务管理器） top: 实时显示进程信息top -d 秒数，几秒后刷新top -i，不显示闲置和僵尸进程top -p PID，指定某进程ID监控进程 top交互操作说明，输入： P，以CPU使用率排序，默认N，以PID排序M，以内存使用率排序q，退出u，接着输入用户名，回车即可查看某用户相关进程k，接着输入进程号，回车即可终止某进程 案例1：监控用户tom的相关进程 top，输入u，接着输入tom 案例2：终止指定进程，踢掉tom PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND2060 tom 20 0 160988 2372 1028 S 0.0 0.1 0:00.01 sshd2064 tom 20 0 116876 3296 1676 S 0.0 0.2 0:00.04 bash top，输入u回车，输入tom回车，输入k回车，输入2064回车。 Service服务管理查看系统服务： 1）setup，系统服务。2）service指令管理服务在&#x2F;etc&#x2F;init.d查看，ls -l /etc/init.d/ service指令： service 服务名 [start|stop|restart|reload|status] CentOS7以后，大多服务不使用service，而使用systemctl。[使用service关闭network服务，一旦关闭，将无法连接SSH服务] 服务运行级别，在&#x2F;etc&#x2F;initab查看，systemctl get-default查看当前运行级别，systemctl set-default T.target设置默认级别。 chkconfig指令： 查看服务：chkconfig –list设置服务在level级别开启：chkconfig --level [0/1/2/3/4/5/6] 服务名 on/off 如设置network在3级别打开或关闭：chkconfig --level 3 network on/off，之后重启系统即可生效。 systemctl指令： systemctl [start |stop |restart |status |enable |disable] 服务名 该指令管理的服务在&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system查看。 systemctl list-unit-files，查看服务开机启动状态systemctl enable 服务名 ，设置服务开机启动systemctl disable 服务名，关闭服务自启动systemctl is-enabled 服务名 ，查看某个服务是否自启动 案例1：查看当前防火墙状态，关闭和打开防火墙服务 systemctl list-unit-files | grep firewalld 或systemctl is-enabled firewalld 或systemctl status firewalldsystemctl stop firewalldsystemctl start firewalld 【systemctl start&#x2F;stop 服务，服务在系统重启后恢复原样】 案例2：防火墙打开和关闭指定端口111 打开打开：firewall-cmd --permanent --add-port=端口/协议关闭打开：firewall-cmd --permanent --remove-port=端口/协议重载生效：firewall-cmd --reload查询端口是否开放：firewall-cmd --query-port=端口/协议查看那些已添加端口：firewall-cmd --list-port firewall-cmd --permanent --add-port=111/tcpfirewall-cmd --reload RPM和YUMrpm rpm是linux常用的下载和打包安装工具，生成.rpm结尾的文件。 软件包名基本格式：firefox-68.10.0-1.el7.centos.x86_64，名称：firefox，版本：68.10.0，适用操作系统：el7.centos.x86_64，norach表示32位64位通用。1）查询查询已安装的rpm包列表：rpm -qa | grep xxx查询所有rpm包：rpm -qa查询软件包是否安装：rpm -q 软件包名查询软件包信息：rpm -qi 软件包名查询软件包中的安装文件：rpm -ql 软件包名查询文件所属软件包：rpm -qf 文件全路径例：rpm -qf &#x2F;etc&#x2F;passwd 2）安装安装软件包：rpm -ivh 软件包全路径，-i安装，-h显示进度，-v显示安装信息例：rpm -ivh &#x2F;opt&#x2F;firefox-68.10.0-1.el7.centos.x86_643）卸载卸载安装包：rpm -e xx软件包名 [erase]强制卸载：rpm -e –nodeps xxx yum yum是一个Shell前端软件包管理器，基于rpm，能够从服务器中下载rpm包并安装，可以自动处理依赖关系，并一次性安装所以依赖，但需要连接网络。 -y:代替手动输入yes，自动执行安装查询服务器是否有可安装的xx软件：yum list | grep xxx查看可更新的软件：yum list updates查看已安装的软件：yum list installed安装包：yum install xxx删除软件：yum remove xxx更新所以软件：yum update更新一个软件：yum update xxx检查更新的包：yum check-update清除缓存目录下的软件包：yum clean all更新软件包缓存：yum makecache搜寻软件包：yum search xxx查看软件包信息：yum info xxx设置镜像的仓库：yum config-manager --add-repo http://mirrors.aliyun.com/repo/Centos-7.repo 影响yum使用的主要文件:基本设置： &#x2F;etc&#x2F;yum.conf仓库软件源集： &#x2F;etc&#x2F;yum.repo.d&#x2F;*.repo日志文件： &#x2F;var&#x2F;log&#x2F;yum.log *.repo的基本配置项：App-Stream BaseOS Extras[base]：名称，可以随意取name：描述repo含义baseurl：后面接地址，是指定一个固定地址enabled:是否启用此频道（1为启动，0为不启用）gpgcheck：是否需要查阅RPM文件内数字证书gpgkey：数字证书公钥文件所在位置，使用默认值 开启软件缓存 nano &#x2F;etc&#x2F;yum.conf 案例：使用yum安装firefoxrpm -e firefoxyum list | grep firefoxyum install firefox","categories":[{"name":"linux","slug":"linux","permalink":"https://hawkezou.github.io/categories/linux/"}],"tags":[]},{"title":"Shell编程","slug":"Shell编程","date":"2023-11-11T04:58:45.000Z","updated":"2026-02-11T15:24:54.884Z","comments":true,"path":"2023/1111/","permalink":"https://hawkezou.github.io/2023/1111/","excerpt":"Shell是一个命令解释器，它提供一个向内核发送请求的界面系统级程序。","text":"Shell是一个命令解释器，它提供一个向内核发送请求的界面系统级程序。 1、shell入门脚本格式要求：以#!&#x2F;bin&#x2F;bash开头，脚本要有可执行权限。 编写一个shell脚本： vim hello.sh#!/bin/bashecho &quot;hello java~&quot; 脚本执行方式： 1）输入脚本的绝对或相对路径，前提要有执行权限 .&#x2F;hello.sh 2）sh +脚本，没有权限也能执行 sh .&#x2F;hello.sh 2、变量shell变量分为系统变量和自定义变量，变量名称可以由字母、数字、下划线组成，字母一般大写。 系统变量：$PATH $HOME $PWD $USER $SHELL显示当前所有变量：set定义变量：变量名&#x3D;值（等号不要空格）撤销变量：unset 变量声明静态变量：readonly 变量（不可以unset） #!/bin/bashA=10echo &quot;A=$A&quot; 将命令的返回值赋值给变量：A&#x3D;`date`或A&#x3D;$(date) 设置环境变量: export 变量名&#x3D;变量值 （将shell变量输出为环境变量\\全局变量）source 配置文件echo $变量名 案例：在&#x2F;etc&#x2F;profile中定义TOMCAT_HOME环境变量，查看环境变量的值，在另一个shell程序中使用TOMCAT_HOME 在profile文件中写入：export TOMCAT_HOME&#x3D;&#x2F;opt&#x2F;tomcat更新环境变量：source &#x2F;etc&#x2F;profile 位置参数变量： 在执行脚本时可以传入相应的参数，如：.&#x2F;myshell.sh 100 200 基本语法： $&#123;&#125;：获取变量的值，{}可省略；$n：(n代表数字，$0为命令本身，$1-9代表第一到第九个参数，10以上用大括号$&#123;10&#125;)；$@：代表所有参数，但区分每个参数；$# ：命令行中参数个数；$* ：代表所有参数，所有参数看为一个整体 预定义变量： $$:当前进程的进程号$!：后台运行的最后一个进程的进程号$?：最后一次执行命令的返回状态，0代表执行成功，非0失败 #!/bin/bashecho &quot;当前执行进程的id=$$&quot; #以后台运行一个脚本，并获取它的进程号。 .&#x2F;myshell.sh 100 200 &amp;echo &quot;最后一个执行进程id=$!&quot;echo &quot;执行结果=$?&quot; 3、shell注释单行注释：#多行注释： :&lt;&lt;!内容! 4、运算符（1）$$((运算式)) （2）$[运算式] （3）expr表达式（运算符之间要有空格） +、-、\\*、&#x2F;、%加减乘除取余 expr 5 + 3注意空格 案例1：计算(2+3)x4第一种方式res=$(((2+3)*4))或第二种res=$[(2+3)*4]或exprtemp&#x3D;`expr 2 + 3` res&#x3D;`$temp \\* 4` echo “$res” 5、条件判断(1)if语句 单分支： if [ 条件 ]then代码fi 两个分支： if [ 条件 ]then代码else代码fi 多分支： if [ 条件 ]then代码elif [ 条件 ]then代码else代码fi (2)条件语句： [ 条件 ] 注意左右空格 例： [ abc ] 返回true[ ] 返回false[ 条件 ] &amp;&amp; echo ok || echo !ok 条件满足执行后面语句 判断条件： 1)&#x3D;字符串比较 2)整数比较 -lt 小于（&lt;）-le 小于等于(&lt;&#x3D;)-eq 等于（&#x3D;&#x3D;）-gt 大于(&gt;)-ge 大于等于(&gt;&#x3D;)-ne 不等于(!&#x3D;) 3）按照文件权限判断 -r 有读权限-w 有写权限-x 有执行权限 4）按照文件类型判断 -f 文件存在&amp;普通文件-e 文件存在-d 文件存在&amp;为目录 案例：编写一个shell程序，输入一个数，大于大于60及格，小于不及格 #!/bin/bashif [ $1 -ge 60 ]thenecho &quot;及格&quot;elif [ $1 -lt 60 ]thenecho &quot;不及格&quot;fi 6、case语句case expression in pattern1) statement1 ;; pattern2) statement2 ;; pattern3) statement3 ;; #其他pattern情形 *) statement esac pattern支持正则表达式： * ：表示任意字符串。[abc]：表示 a、b、c 三个字符中的任意一个。比如，[15ZH] 表示 1、5、Z、H 四个字符中的任意一个。[m-n]：表示从 m 到 n 的任意一个字符。比如，[0-9] 表示任意一个数字，[0-9a-zA-Z] 表示字母或数字。| ：表示多重选择，类似逻辑运算中的或运算。比如，abc | xyz 表示匹配字符串 “abc” 或者 “xyz”。 expression 既可以是一个变量、一个数字、一个字符串，还可以是一个计算表达式，或者是命令的执行结果，只要能够得到 expression 的值就可以。pattern 可以是一个数字、一个字符串，甚至是一个简单的正则表达式。有时候相近的内容作为一个pattern时，这些内容以“|”隔开，比如 y|yes|YES)。如果 expression 和某个模式匹配成功，就会执行这模式后面对应的所有语句（该语句可以有一条，也可以有多条），直到遇见双分号;;才停止，然后整个 case 语句就执行完了，程序会跳出整个 case 语句，执行 esac 后面的其它语句。如果 expression 没有匹配到任何一个模式，那么就执行*)后面的语句，直到遇见双分号;;或者esac才结束。最后一个分支可以写;;，也可以不写。执行到 esac 都会结束整个 case in 语句。最后一个分支*)并不是什么语法规定，它只是一个正则表达式，*表示任意字符串。 case $1 in 1) echo “星期一” ;; 2) echo “星期二” ;; 3) echo “星期三” ;; #其他pattern情形 *) echo “others”esac 7、循环for循环案例一：编写一个num.sh，将输入的数字参数输出 #!/bin/bashfor i in &quot;$@&quot;doecho &quot;n is $i&quot;done 案例二：编写一个sum.sh对1到100求和输出结果 #!/bin/bashSUM=0for(( i=1;i&lt;=100;i++ ))do​ $SUM=$[$SUM+Si]doneecho $SUM while循环while [ 条件 ]do代码done 案例：从命令行输入一个参数n，计算1+2+…+n #!&#x2F;bin&#x2F;bashSUM=0i=1while [ $i -le $1 ]do​ SUM=$[ $SUM+$i ]​ i=$[ $i+1 ]doneecho $SUM 8、read读取输入-p : 读取时的提示；-t：读取等待的秒数 案例：读取控制台输入的两个数输出 read -p &quot;请输入一个数=&quot; NUM1echo $NUM1read -t 10 -p &quot;请在10秒内输入一个数=&quot; NUM2echo $NUM2 9、函数系统函数basename\\dirnamebasename返回路径后的文件名，dirname返回文件所在文件夹绝对路径 案例1：取出&#x2F;home&#x2F;myhome&#x2F;a.txt的a.txt文件名 basename /home/myhome/a.txt 案例2：取出&#x2F;home&#x2F;myhome&#x2F;a.txt的文件的绝对路径&#x2F;home&#x2F;myhome dirname /home/myhome/a.txt 自定义函数:function 函数名(){ } 调用函数：函数名+参数值 案例：定义一个函数getSum()求出输入参数之和 #!&#x2F;bin&#x2F;bashfunction getSum()&#123;​ SUM=$[$n1+$n2]​ echo &quot;$SUM&quot;&#125;read -p &quot;请输入一个数n1=&quot; n1read -p &quot;请输入一个数n2=&quot; n2getSum $n1 $n2 10、备份数据库练习在&#x2F;usr&#x2F;sbin下创建数据库备份脚本文件mysql_db_backup.sh #!&#x2F;bin&#x2F;bashBACKUP=/data/backup/db#时间DATETIME=$(date +%Y-%m-%d_%H%M%S)echo $DATETIME#主机HOST=localhost#用户DB_USER=root#密码DB_PASS=root#数据库名DATABASE=MyDB#创建备份目录[ ! -d &quot;$&#123;BACKUP&#125;/$&#123;DATETIME&#125;&quot; ] &amp;&amp; mkdir -p &quot;$&#123;BACKUP&#125;/$&#123;DATETIME&#125;&quot;#备份mysqldump -u&#123;DB_USER&#125; -p&#123;DB_PASS&#125; --host=$&#123;HOST&#125; -q -R --datebases $&#123;DATABASE&#125; | gzip &gt; $&#123;BACKUP&#125;/$&#123;DATETIME&#125;/$DATETIME.sql.gz#打包cd $&#123;BACKUP&#125;tar -zcvf $DATETIME.tar.gz $&#123;DATETIME&#125;#删除备份目录rm -rf $&#123;BACKUP&#125;/$&#123;DATETIME&#125;#删除10天前备份数据find $&#123;BACKUP&#125; -atime 10+ -name &quot;\\*.tar.gz&quot; -exec rm -rf &#123;&#125; \\echo &quot;备份$DATABASE 成功~&quot; 每天2点半定时备份crontab -e30 2 * * * /usr/sbin/mysql_db_backup.sh","categories":[{"name":"linux","slug":"linux","permalink":"https://hawkezou.github.io/categories/linux/"}],"tags":[]},{"title":"虚拟机IP突然消失的解决方法","slug":"虚拟机IP突然消失的解决方法","date":"2023-11-02T01:19:39.000Z","updated":"2026-02-11T15:27:00.063Z","comments":true,"path":"2023/1102/","permalink":"https://hawkezou.github.io/2023/1102/","excerpt":"基础方法如下：如果这个文件 ifcfg-ens33已经将ONBOOT改为yes了，之前用的还好好的还有ip地址的但是现在没有了。","text":"基础方法如下：如果这个文件 ifcfg-ens33已经将ONBOOT改为yes了，之前用的还好好的还有ip地址的但是现在没有了。 1.先重启网络服务 sudo service network restart但是重启网络失败的话，那就执行下边命令。 出现问题解决方式：禁用NetworkManager 2.执行下边这两条命令 systemctl stop NetworkManagersystemctl disable NetworkManager 3.执行完成之后重新启动网络服务。 sudo service network restart 然后重新启动网络服务就OK了 4.输入ip addr查看ip地址。在使用VMware过程中，有时候出现ssh工具连接不上的情况，在VMware中使用ip addr或者ifconfig命令查看ip，发现ip已消失 若为kali系统，可以试试以下命令：dhclient eth0eth0为网卡名字，该操作为网卡自动分配ip。 解决办法二：1、查看VMware的网络设置，网络适配器，将网络适配器设置为NAT模式2、设置VMware的虚拟网络编辑器，设置NAT模式的网段。（点击虚拟网络编辑器”更改设置“。如果不点击这里，“还原默认设置”按钮将是灰色的）3、点击虚拟网络编辑器“还原默认设置”。 解决办法三：重启网卡：service network restart如果报错，则可以停止网络管理，systemctl stop NetworkManager。若为kali则重启网络服务为service networking restart 解决办法四：由于启动服务器时未加载网卡，导致IP地址初始化失败。修改网络初始化配置，设定网卡在系统启动时初始化。cat /etc/sysconfig/network-scripts/ifcfg-ens33 进入目录：&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts 编辑文件：vi ifcfg-ens33，将ONBOOT&#x3D;no改为ONBOOT&#x3D;yes","categories":[{"name":"虚拟机","slug":"虚拟机","permalink":"https://hawkezou.github.io/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA/"}],"tags":[]},{"title":"linux找回root密码，CentOS7","slug":"linux找回root密码，CentOS7","date":"2023-10-27T04:55:09.000Z","updated":"2026-02-11T15:24:31.446Z","comments":true,"path":"2023/1027/","permalink":"https://hawkezou.github.io/2023/1027/","excerpt":"linux找回密码需要进入单用户模式，linux运行级别有0~6，可以通过init切换。","text":"linux找回密码需要进入单用户模式，linux运行级别有0~6，可以通过init切换。 0：关机 1：单用户模式 2：多用户状态无网络 3：多用户状态有网络muti-user.target 4：系统未使用保留用户 5：图形用户graphical.target 6：系统重启 进入单用户模式通过以下步骤找回密码： 1.进入系统，在开机界面按住’e’进入编辑界面 2.进入编辑界面，找到’Linux16’开头的行，在末尾输入: init&#x3D; &#x2F;bin&#x2F;sh 3.按住快捷键ctrl+x进入单用户模式 4.在光标闪烁的位置输入：mount -o remount,rw &#x2F; ，完成后enter回车 5.在新的一行最后输入passwd回车，输入密码即可 6.接着输入touch &#x2F;.autorelabel回车 7.然后输入exec &#x2F;sbin&#x2F;init回车，等待系统完成重启","categories":[{"name":"linux","slug":"linux","permalink":"https://hawkezou.github.io/categories/linux/"}],"tags":[]},{"title":"写在大学最后的时光","slug":"写在大学最后的时光","date":"2023-02-08T08:49:24.000Z","updated":"2026-02-11T15:15:38.831Z","comments":true,"path":"2023/0208/","permalink":"https://hawkezou.github.io/2023/0208/","excerpt":"当决定考研的那一刻，我并不知道我为什么一定要考研，内心的我是这样想的：考上了研究生，将来会更有优势。想法非常的单纯，在将近一年的准备的过程中，感觉身心疲惫，简直就是在折磨自己，每天三点一线的模式，大部分时间就是坐在板凳上看书学习，只能靠着听音乐和以后所谓的“美好将来”的幻想来迷惑自己","text":"当决定考研的那一刻，我并不知道我为什么一定要考研，内心的我是这样想的：考上了研究生，将来会更有优势。想法非常的单纯，在将近一年的准备的过程中，感觉身心疲惫，简直就是在折磨自己，每天三点一线的模式，大部分时间就是坐在板凳上看书学习，只能靠着听音乐和以后所谓的“美好将来”的幻想来迷惑自己。 到了考试前终于停下了，整个人一度的摆烂，考试那几天几乎没有看书，那些天有特殊情况，学校让隔离了，本来大家都要回家隔离再回来考试的，全宿舍都被感染了新冠，考试当天就发烧头痛。已经无所谓了，就这两三天，也没什么心思看书，只希望早点回家。当坐在回去的列车上，看着窗外飞速而过的树木，我知道这一年真的太不容易。 就像22年的卡塔尔世界杯，梅西带领阿根廷闯进世界杯决赛，我在拼命的刷数学题，我们每个人都在拼命地朝着目标前进，都在付出，最后阿根廷赢了，而我并不知道自己赢没赢，人生真的是一场比赛或者游戏吗？ 回想大学四年的时光，自己懵懵懂懂地进入大学，把以前的无知和天真带了进来，左右折腾也没有找到那些大牛口中声称的“热爱”，可能是校园太小了吧，或者是我的能力和资源有限的原因吧，我迷茫地花掉了大学的大部分时光，期间也曾起来试图摆脱平庸，和其他人一起考了大学英语四六级，但是考过了又怎样。进入大三了，我又开始陷入另一种迷茫，要不要考研？网上各种声音，说考研是人生的一个转折点；说考研是一种逃避毕业工作的途径；又说考研是为了将来更好的自己，还说是在提高自己，我不懂在提高自己的什么，血压和体重吗？还是自己的受骗率？只是为了学历就算了，说实话，我还是挺佩服那些努力考上研的同学，网上基本上都是知名大学，每当看到我们这些双非院校的能逆袭985、211的视频，我更加迷茫了，我不知道是为了什么，我只是照着别人的路线继续按部就班地走下去罢了，从来没有听听内心的真实想法。所以一年下来也非常痛苦，搬书来来回回，晚上10点多才回宿舍，总是在逃避着什么。我也不清楚，进入大学以来一个人突然地像被释放了，自由独立多了，没有什么约束，也就迷茫了。从来没有人向我介绍大学生活，也没有人告诉我们大学里应该怎么做，网上倒是有很多教程，有关生活的各个方面，都被安排的明明白白。 马上就要毕业了，我依然是这样的不知所措，准备毕设加可能的研究生复试加就业，我不可能面面俱到，人生就是这样，有得有失，我准备好了面对结果了。也许我并不在乎最终结果，大概只是喜欢努力过后能有一点收获的感觉吧，可能有付出并不会有回报，就挺打击的。 如果我如愿考上研究生，那就针对的起大学这几年的颓废和迷茫吗？我又陷入了一种“迷茫”，我在读研究生，每天看着各种文献，敲着代码，导师可能一个星期就联系一次，等到毕业了又不知道如何面对以后的生活，如何融入这个陌生的社会，如何在这个世界生存下去，只能说学校建了一堵厚厚的墙，把里面的我们保护的很好，看起来我只是换了一个学校继续迷茫罢了。当初大学填报志愿的时候只是怀着一丝好奇选择了计算机专业，大学之前也没有太多机会接触计算机，直到枯燥的课程扑面而来，我才算是入门计算机了，之后的话几乎停留在理论的基础上，运用的最多是和同学一起玩游戏，大学期间电脑游戏也算是入门了。 可能是时间的原因，推着我们向前走，直到认清自己，开始接受现实，我只是一个“被编好程序的人”，安排来接受教育之后进入社会打工罢了，不然怎么叫程序员呢。当程序员也好呀，走到了人生的最后几步了，不用担心没有钱吃喝住了，心里踏实平静多了，也许不迷茫了，当然买房可能是个问题，不过比待业在家啃老强，好歹有个稳定收入养活一家子。以后操心事多了，就不继续遐想了，总之顺其自然吧，父母希望子女有个出息，但是我也就这样了，他们知不知道我们现在的压力呢，年轻人拼了命的努力，最后只为了在目标城市买到一块安生之地。 虽然现在考试分数还没出来，但是毕设和企业春招已经开始了，是时候走出迷茫了，走一个令人舒畅的路了，疫情这几年真不容易，真是难受！","categories":[{"name":"碎碎念","slug":"碎碎念","permalink":"https://hawkezou.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}],"tags":[]},{"title":"关于28岁的字节工程师离世的感慨","slug":"关于28岁的字节工程师离世的感慨","date":"2022-02-24T08:36:49.000Z","updated":"2026-02-11T15:26:24.728Z","comments":true,"path":"2022/0224/","permalink":"https://hawkezou.github.io/2022/0224/","excerpt":"此前网传年轻的字节跳动员工吴同学已离世，字节跳动的内网一则通知显示，从医院获知，吴同学不幸离世。经过大概是这样的，2月21日晚上18点，28岁的吴同学走进字节跳动的健身房，吴同学在运动约1小时后出现头晕现象，情况加重。当晚19时30分许，急救人员到场救治，并将其送上救护车","text":"此前网传年轻的字节跳动员工吴同学已离世，字节跳动的内网一则通知显示，从医院获知，吴同学不幸离世。经过大概是这样的，2月21日晚上18点，28岁的吴同学走进字节跳动的健身房，吴同学在运动约1小时后出现头晕现象，情况加重。当晚19时30分许，急救人员到场救治，并将其送上救护车。2月23日0时30分，医院反馈，该员工情况危重。不久，吴同学便去世了。 说到这，我是软件的本科生，起初同样是怀着兴趣报考了计算机相关的专业，以至于来到了之后不太满意的学校。28岁可以称他为‘学长’了，大了我几岁，但还是年轻的生命啊！吴学长有着名校的学历，很早就有了从事IT行业的想法，在毕业后进入字节努力地工作，结了婚，买了房，出了书，几个月前妻子还有了孩子。很难想到这样一位年轻的学长，本应在日后获得更加幸福美好的生活，然而现实却是如此的残酷，他是匆匆地离开世间。 从吴学长生前的个人平台和当前报道来看，吴学长是一位有梦想、活泼开朗的人，而且能力还是很强的，还买了房，虽然是贷款的。尽管在医院奋力的抢救，还是没能挽回吴学长的生命。吴学长的逝世给了吴学长妻子很大的压力，她打算退了房子回到小县城，和她母亲孕育孩子，抚养成人。 关于以上的消息，我对吴学长的离开感到难过和一点惋惜，惋惜他是一位值得被生活善待的人，结局令人悲痛；还对软件专业的自己感到迷茫，因为面临着就业和考研的烦恼，现在怀疑要不要继续学习计算机或进入相关的行业；也对计算机相关专业在读的同学或即将从事计算机相关行业的人感到一丝忧虑和庆幸，庆幸我们还有当前健康的身体和生活，庆幸我们还有一些选择。 吴学长的离世不是孤例，另一位26岁的年轻人也上了热搜。上海一家设计事务所的设计师，疑似因加班过度，于15日清晨在出租屋内猝死。两个年轻人的离世消息撞到一起，给人的冲击格外大，难道生活的真相就是如此吗？大家都知道IT行业普遍加班，工作压力很大，生活压力也大，而且相关从业者都生活在大城市。据了解，字节这样的公司喜欢自律能力强的人，基本上福利多，有免费三餐和酒水，免费健身房，五险一金等等，在这样的环境中，人不想向上爬都难，回到家也是不断地学习。 总之，IT行业就一个字，“卷”！因为社会的某种普遍共识，行业薪资高，不光是入职找工作卷，高考和研究生报考也开始卷起来了，考啥一定考计算机相关的专业，甚至跨考，光想着以后会待遇高，可是也看到了报考人数上涨，招生扩招都无法满足大家的录取，只能越来越卷。不是其他行业不卷，是计算机卷得太厉害了，炸天了！不管适不适合读相关专业，做不做的了相关工作，都涌入大潮之中，特别是人工智能开始发展兴起之后。 与此同时，在当前像字节这样的大公司里工作，可以自由地享受各种优厚待遇，也会感受到了一种被限制的自由。尽管有弹性的工作制，工作的员工要完成各种任务，和优秀的人在一起会更优秀，但是也要抗住辛苦和劳累。不是说大家不要努力向上，而是看看给自己带来了什么，忽视了长远的利益发展和被迫劳累所带来的危害，即使是强壮的巨人最终也会倒下。 当时看到吴学长的新闻，就十分感慨，他为何遭遇这样的不幸。因为很难说清他的猝死和加班有没有关联，但应该反思一下，如何在如此的生活压力下，让巨头字节和它的员工的心都保持跳动。·","categories":[{"name":"碎碎念","slug":"碎碎念","permalink":"https://hawkezou.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}],"tags":[]},{"title":"ACM、OI、IOI编程竞赛模式介绍","slug":"ACM、OI、IOI编程竞赛模式介绍","date":"2021-11-23T12:07:51.000Z","updated":"2026-02-11T15:21:53.382Z","comments":true,"path":"2021/1123/","permalink":"https://hawkezou.github.io/2021/1123/","excerpt":"介绍一下编程比赛：ICPC是国际大学生程序设计竞赛(ACM International Collegiate ProgrammingContest（ACM-ICPC或ICPC）是由美国计算机协会(ACM)主办的，一项旨在展示大学生创新能力、团队精神和在压力下编写程序、分析和解决问题能力的年度竞赛。经过近30多年的发展，ACM国际大学生程序设计竞赛已经发展成为最具影响力的大学生计算机竞赛。","text":"介绍一下编程比赛：ICPC是国际大学生程序设计竞赛(ACM International Collegiate ProgrammingContest（ACM-ICPC或ICPC）是由美国计算机协会(ACM)主办的，一项旨在展示大学生创新能力、团队精神和在压力下编写程序、分析和解决问题能力的年度竞赛。经过近30多年的发展，ACM国际大学生程序设计竞赛已经发展成为最具影响力的大学生计算机竞赛。 CCPC中国大学生程序设计竞赛(China Collegiate Programming Contest) 是由中国大学生程序设计竞赛协会主办的面向世界大学生的国际性年度赛事，旨在激励当代大学生运用计算机编程技术和技能来解决实际问题，激发其学习算法和程序设计的兴趣，培养其团队合作意识、创新能力和挑战精神。 IOI是国际信息学奥林匹克竞赛 (International Olympiad in Informatics），是面向中学生的一年一度的信息学科竞赛。举办历史较长，第一届国际信息学奥林匹克竞赛于1989年在保加利亚举行。 NOI是中国计算机学会举办了全国青少年计算机程序设计竞赛，即全国青少年信息学奥林匹克竞赛(简称NOI）。 NOIP是全国青少年信息学奥林匹克联赛（National Olympiad in Informatics in Provinces）自1995年至今已举办19次，每年由中国计算机学会统一组织。 介绍一下编程比赛中最常见的三种赛制：ACM赛制、OI赛制、IOI赛制。先普及一些常见的竞赛术语：提交反馈，实时排名，按点给分，题数罚时，测试点(测试用例)等。 提交反馈：一般为“通过AC”、“答案错误”、“运行超时”等等反馈 实时排名：比赛中能看到排名，如ACM赛制 全有或全无：只有通过全部测试点才算通过，只要有一个测试点不通过就不能AC(答案accept) 按点给分：每道题有多个测试点，通过几个测试点就给相应分值 题数罚时：题数多者排名靠前，只有当题数相同时才比较时间，时间少者排名靠前，或再比较罚时，罚时为提交错误答案给予相应的罚时，罚时和比赛时间没有关系，只用来排名，每做错一道题会有罚时相加，罚时少排名靠前。 先看通过的题目数量，单独绿色表示通过，然后看罚时，罚时短的靠前，每个题目下面黑色数字表示做出这个题的时间，然后把ac的题的时间数累加到罚时中，其间每一次提交运行结果被判错误的话将被加罚20分钟时间，未正确解答的试题不记时。红色- 表示没通过的题和错误提交次数，蓝色的表示比赛结束后的通过。 赛制 提交反馈 实时排名 计分方式 排名方式 相关比赛 ACM制 有 有 全有或全无 题数+时间 ICPC、CCPC、牛客小白赛、传智杯 OI制 无 无 按点给分 分数 NOI、计算机能力挑战赛、蓝桥杯 IOI制 有 有 按点给分 分数 PAT、团体程序设计天梯赛、CCF ACM赛制：每道题提交之后都有反馈，但看不到错误的测试样例(leetcode周赛可以看到)，每道题都有多个测试点，每道题必须通过了所有的测试点才算通过。每道题不限制提交次数，没通过的话会有罚时，比赛过程中可以看到实时排名，通过题数相同的情况下按照答题时间+罚时来排名。 ACM赛制的比赛：ICPC、CCPC、codeforces、leetcode周赛及全国编程大赛、传智杯 OI赛制：每道题提交之后都没有反馈，根据每道题通过的测试点的数量获得相应的分数。每道题不限制提交次数，如果提交错误没有任何惩罚，仅以最后一次提交为准，赛后按照总得分来排名。 OI赛制的比赛：NOI、考研机试、蓝桥杯、计算机能力挑战赛。 IOI赛制：每道题提交之后都有反馈，可以实时看到自己每道题得了多少分，但看不到错误的测试样例。每道题都有多个测试点，根据通过的测试点的数量获得相应的分数。每道题不限制提交次数，如果提交错误没有任何惩罚。比赛过程中一般可以看到实时排名，按照总得分来排名。IOI赛制是结合了OI赛制和ACM赛制的特点。 IOI赛制的比赛：PAT、团体程序设计天梯赛、CCF、CSP、洛谷月赛。 注意Tips：OI赛制和IOI赛制没有提交限制，提交错误也没有惩罚，所以可以大胆地提交，但ACM赛制的罚时会很大拉开差距。","categories":[{"name":"碎碎念","slug":"碎碎念","permalink":"https://hawkezou.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}],"tags":[]},{"title":"CC知识共享许可协议简介","slug":"CC知识共享许可协议简介","date":"2021-09-16T13:07:56.000Z","updated":"2026-02-11T15:22:11.743Z","comments":true,"path":"2021/0916/","permalink":"https://hawkezou.github.io/2021/0916/","excerpt":"在博客文章下面一般都有版权声明，标明文章作者、链接和版权类型，最常见的类型就是CC BY-SA。这种版权声明是知识共享许可协议Creative Commons license，又叫CC协议或创作公共协议，是一种允许他人分发作品的公共版权许可。2002年美国非盈利性组织知识共享Creative Commons首次发布了CC协议，它并不是什么法律法规，而是基于一定的知识产权法律基础上建立的一种知识作品等分享约定协议，旨在促进创意作品流通和分享。 在经历了三个不同版本之后，CC4.0版本于2013年发布。自此之后，CC4.0被鼓励在全球范围内适用。除了放弃版权将作品完全公布到公共领域 (即CC0协议) 之外，CC4.0版本中一共有6种常用的版权规定组合","text":"在博客文章下面一般都有版权声明，标明文章作者、链接和版权类型，最常见的类型就是CC BY-SA。这种版权声明是知识共享许可协议Creative Commons license，又叫CC协议或创作公共协议，是一种允许他人分发作品的公共版权许可。2002年美国非盈利性组织知识共享Creative Commons首次发布了CC协议，它并不是什么法律法规，而是基于一定的知识产权法律基础上建立的一种知识作品等分享约定协议，旨在促进创意作品流通和分享。 在经历了三个不同版本之后，CC4.0版本于2013年发布。自此之后，CC4.0被鼓励在全球范围内适用。除了放弃版权将作品完全公布到公共领域 (即CC0协议) 之外，CC4.0版本中一共有6种常用的版权规定组合。下面这六种不同的许可协议，这里从基础许可到受限许可开始列举： CC BY CC BY : 此类型许可允许进行版本分发，作品合成修改和建立在任何媒介或格式的材料上，只要归属于创造者。许可证允许商业使用。包括以下： BY – 版权必须归属于作者，必须按照作者或授权人所指定的方式，保留其姓名标示。 CC BY-SA CC BY-SA : 此类型允许进行版本分发，作品合成修改和建立在任何媒介或格式的材料上，只要归属于创造者。许可证允许商业使用。假如你合成修改或者建立生成新作品，必须在相同的条款下许可授权，不能变更许可协议 。CC BY-SA 包括以下条件: BY – 版权必须归属于作者，必须按照作者或授权人所指定的方式，保留其姓名标示。 SA – 修改必须在相同的条款协议下共享(Shared) CC BY-NC CC BY-NC : 本许可证允许使用者仅出于非商业目的，以任何媒体或格式分发、合成、改编和构建材料作品，并且版权要归属创作者。CC BY-NC 包括以下条件: BY – 版权必须归属于作者，必须按照作者或授权人所指定的方式，保留其姓名标示。 NC – 只能用于非商业用途(NonCommercial) CC BY-NC-SA CC BY-NC-SA : 本许可证允许使用在仅出于非商业目的下，以任何媒体或格式分发、合成、改编和构建材料作品，并且版权要归属创作者。要合成修改或者建立生成新作品，必须在相同的条款协议下许可。CC BY-NC-SA 包括以下条件: BY – 版权必须归属于作者，必须按照作者或授权人所指定的方式，保留其姓名标示。 NC – 只能被用于非商业用途 SA – 修改必须在相同的条款协议下共享(Shared) CC BY-ND CC BY-ND : 此类许可允许仅以未修改的形式，以任何媒介或格式复制和分发作品材料，版权归属作者，但可以用于商业用途。CC BY-ND 包括以下: BY – 版权必须归属于作者，必须按照作者或授权人所指定的方式，保留其姓名标示。 ND – 作品的衍生和改编是不允许的(No derivatives or adaptations ) CC BY-NC-ND CC BY-NC-ND : 此类许可允许仅以未修改的形式在仅出于非商业目的下，以任何媒介或格式复制和分发作品材料, 最后版权依然归于作者。CC BY-NC-ND 包括以下: BY – 版权必须归属于作者，必须按照作者或授权人所指定的方式，保留其姓名标示。 NC – 只能被用于非商业用途 ND – 作品的衍生和改编是不允许的 知识共享公共领域公开CC0 CC0 (又名CC Zero)是一个知识作品公布共享协议，它表示创作者放弃他们的版权，将他们的作品放到全球公共领域，CC0允许使用者无条件地以任何媒介或格式分发、合成、改编和构建材料，是一种彻底的开放版权协议，建议谨慎使用。 附录：参考CC官网","categories":[{"name":"碎碎念","slug":"碎碎念","permalink":"https://hawkezou.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}],"tags":[]},{"title":"Java类加载篇","slug":"Java类加载篇","date":"2020-10-18T09:19:51.000Z","updated":"2026-02-11T15:23:46.487Z","comments":false,"path":"2020/1018/","permalink":"https://hawkezou.github.io/2020/1018/","excerpt":"Java类加载这部分知识比较深入底层，将重点介绍类加载和反射，会提到JDK动态代理、AOP，反射等诸多知识点。当调用Java命令允许程序时，该命令会启动多个线程，它们都处于该Java虚拟机进程里。所有线程、变量处于同一个进程里，它们都使用JVM进程的内存区。当出现以下情况，进程将终止：","text":"Java类加载这部分知识比较深入底层，将重点介绍类加载和反射，会提到JDK动态代理、AOP，反射等诸多知识点。当调用Java命令允许程序时，该命令会启动多个线程，它们都处于该Java虚拟机进程里。所有线程、变量处于同一个进程里，它们都使用JVM进程的内存区。当出现以下情况，进程将终止： 程序结束 使用System.exit()或Runtime.getRuntime().exit()代码 未捕获到异常 强制结束进程 123public class A&#123; public static int a = 6;&#125; 1234567public class Test1&#123; public static void main(String[] args)&#123; A a = new A(); a.a++; System.out.println(a.a); &#125;//输出7&#125; 123456public class Test2&#123; public static void main(String[] args)&#123; A b = new A(); System.out.println(b.a); &#125;//输出6&#125; 上述代码表明，不同的进程之间是不会共享资源的，运行Test1和Test2是运行两次进程，所以第二次依然重新初始化A类。 类的加载当需要使用某个类时，系统会通过加载、连接、初始化三个步骤完成对类的初始化。类加载指的是类加载器将类的class文件读入内存，并为之创建一个java.lang.Class对象。类加载器通常由JVM提供，也称系统类加载器，除此之外，开发者可以通过继承ClassLoader基类来创建类加载器。使用不同类加载器，可以从不同来源加载类的数据通常有以下来源： 本地加载class文件 JAR包中加载class文件 网络加载 把一个Java源文件动态编译并加载 类的连接创建了Class对象后，系统将二进制数据合并到JRE中，这一过程可分为三个阶段： 验证：验证加载的类是否有正确的内部结构 准备：为类变量分配内存，并设置默认值 解析：将类的二进制数据中的符号引用替换成直接引用 类初始化在初始化阶段，JVM负责对类进行初始化，主要对类变量进行初始化。初始化有两种方式： 声明变量时就指定初始值 使用静态代码块指定初始值 JVM初始化一个类是按照一定规则进行的，如下： 如果没有加载和连接，则先加载并连接该类 如果父类没有初始化，则优先初始化其父类 如果有初始化语句，则系统先执行初始化语句 所以JVM总是最先初始化java.lang.Object类，并顺着继承链依次加载并初始化类。程序通过以下6种方式来使用某个类和接口时，系统就会初始化该类或接口： 创建类实例。包括：使用new关键字；反射创建；反序列化创建。 调用类方法。 访问类变量或赋值。 反射强制创建某个类或接口对应的java.lang.Class对象。(如果还未初始化该类) 初始化某类的子类。 使用java.exe命令运行某个类。 对于final型的类变量，如果该类变量的值在编译时就确定下来，那么这个类变量相当于“宏变量”。因此使用静态类变量也不会导致该类初始化，相当于使用常量。如果final修饰的变量不能确定下来，必须等到运行时确定，则将使该类初始化。 类加载器类加载器负责将.class文件加载到内存中，并生成一个java.lang.Class实例，一旦一个类被加载到JVM中，同一个类就不会被再次载入。所谓同一个类指的是有唯一标识的类，唯一标识是用全限定类名作为载入标识。在JVM中一个类用其全限定类名和其类加载器作为其全限定类名，例如：(类、package、加载器实例)。 当JVM启动时，会形成由三个类加载器组成的初始类加载器层次结构，加载顺序如下。 Bootstrap ClassLoader：根类加载器(不是Java实现，一般无法访问) Extension ClassLoader：扩展类加载器 System ClassLoader：系统类加载器 Bootstrap ClassLoader也叫引导(启动)类加载器，负责加载Java核心类。它不是java.lang.ClassLoader的子类，而是由JVM自己实现。 123456789public class BootstrapTest&#123; public static void main(String[] args)&#123; URLS[] u = sun.misc.Launcher.getBootstrapClassPath().getURLS(); //遍历输出根类加载器的全部URL for(int i=0;i&lt;u.length;i++)&#123; System.out.println(u[i].toExternalForm()); &#125; &#125;&#125; Extension ClassLoader，ExtClassLoader(sun.misc.Launcher$ExtClassLoader)的实例，负责加载JRE的扩展目录中的JAR包的类，通过这种方式可以为Java扩展核心类以外的功能，只要把开发的类打包成JAR包即可，然后放入JAVA_HOME/jre/lib/ext路径即可。 System ClassLoader，应用类加载器AppClassLoader的实例，它负责在JVM启动时加载来自命令-classpath或CLASSPATH环境变量所指定的JAR包和类路径。可以通过调用ClassLoader的getSystemClassLoader()方法来获取系统类加载器。 系统类加载器是当前路径，扩展类加载器的加载路径是JAVA_HOME/jre/lib/ext，所以可以说其父加载器为null也不为过，getParent()方法返回null，但根加载器可以作为其父加载器。 类加载机制加载机制有三种： 全盘委托：当某加载器加载一个类时，该类所引用和依赖的其他类也将由该类加载器负责加载。 父类(双亲)委托：先让父类加载器加载class，如果无法加载则从自己的类路径中加载。 缓存机制：保证所有已加载过的类都被缓存，当需要使用某个类时，加载器先从缓存区加载该类，如不存在才会加载对应的二进制数据，并将其转换成Class对象存入内存。(所以修改某个类后需重启JVM才会生效) 一个类加载器查找class和resource时，是通过“委托模式”进行的，它首先判断这个class是不是已经加载成功，如果没有的话它并不是自己进行查找，而是先通过父加载器，然后递归下去，直到Bootstrap ClassLoader，如果Bootstrap ClassLoader找到了，直接返回；如果没有找到，则一级一级返回，最后到达自身去查找这些对象。这种机制就叫做双亲委托。 JDK搜索类的方式ClassLoader使用的是双亲委托模型来搜索类的，每个ClassLoader实例都有一个父类加载器的引用(不是所谓的&#x2F;&#x2F;继承的关系，是一个包含的关系），虚拟机内置的类加载器Bootstrap ClassLoader本身没有父类加载器，但可以用作其它ClassLoader实例的的父类加载器，但是访问ExtClassLoader的父加载器返回null。 当一个ClassLoader实例需要加载某个类时，它会试图在亲自搜索某个类之前，先把这个任务委托给它的父类加载器，这个过程是由上至下依次检查的，首先由最顶层的类加载器Bootstrap ClassLoader试图加载，如果没加载到，则把任务转交给Extension ClassLoader试图加载，如果也没加载到，则转交给AppClassLoader进行加载，如果它也没有加载得到的话，则返回给委托的发起者，由它到指定的文件系统或网络等URL中加载该类。如果它们都没有加载到这个类时，则抛出ClassNotFoundException异常。否则将这个找到的类生成一个类的定义，并将它加载到内存当中，最后返回这个类在内存中的实例对象。 好处：因为这样可以避免重复加载，当父亲已经加载了该类的时候，就没有必要让子ClassLoader再加载一次。考虑到安全因素，我们试想一下，如果不使用这种委托模式，那我们就可以随时使用自定义的String来动态替代java核心API中定义的类型，这样会存在非常大的安全隐患，而双亲委托的方式，就可以避免这种情况，因为String已经在启动时就被引导类加载器(Bootstrap ClassLoader)加载，所以用户自定义的ClassLoader永远也无法加载一个自己写的String类，除非你改变JDK中ClassLoader搜索类的默认算法。 类加载步骤 检查是否有载入过。 如果父类加载器不存在，则使用根类加载器来载入类并返回对应java.lang.Class对象，否则执行第5步；如果存在则使用父类加载器去加载类并返回Class对象，不成功则执行第3步。 当前加载器从与它相关的类路径中寻找，找到就执行第4步，否则执行第5步。 从文件中载入Class，成功后同样返回Class对象。 抛出ClassNotFoundException异常。 JVM规范中规定如果用户自定义的类加载器将父类加载器强制设置为null，那么会自动将启动类加载器设置为当前用户自定义类加载器的父类加载器。同时，即使用户自定义类加载器不指定父类加载器，那么同样可以加载到&#x2F;lib下的类。自定义类加载器不指定父类加载器是默认系统类加载器为父类加载器，按照双亲委派加载。若强制父类加载器为null，则其他加载器就可能不被加载。 加载流程为：系统类加载器–&gt;扩展类加载器–&gt;启动类加载器，强制设置parent为null时关系就已经断了 源代码中走findBootstrapClassOrNull(name)加载 创建自定义类JVM中除根加载器外，其他都是ClassLoader抽象类的子类实例，开发者可以扩展其子类并重写所含方法来实现自定义类加载器。类加载器有两个关键方法： loadClass(String name,boolean resolve)：类加载器的入口点，根据指定名称加载类，并获取Class对象。 findClass(String name)：根据指定名称查找类。 如果需要实现自定义类加载器，则可以通过重写以上两个方法来实现。loadClass()方法的执行步骤如下： 用findLoadedClass(String)来检查是否已经加载类，已加载则返回。 在父类加载器上调用loadClass()方法。如果父类为null，则使用根类加载器来加载。 调用findClass(String)方法查找。 重写finsClass()方法可以避免覆盖默认类加载器的双亲委托、缓存机制，在ClassLoader里还有一个核心方法Class defineClass(String name,byte[] b,int off,int len)，负责将类的字节码文件读入字节数组byte[] b内，并把它转化为Class对象。defineClass()方法管理JVM的许多复杂的实现，不能被重写，因为是final的。除此外还有一些普通方法如下： findSystemClass(String name)：从本地文件系统装入文件，存在就用defineClass()方法将字节码转换成Class对象。 static getSystemClassLoader()：返回系统类加载器 getParent()：获取父类加载器。 resolveClass(Class&lt;?&gt; c)：链接指定类。 findLoaderClass(String name):如果已加载该类，则返回Class实例，否则返回null。 使用自定义类的好处它能用来实现以下功能： 执行代码前自动验证数字签名 根据提供的密码解密代码，避免反编译 动态加载类 把数据以字节码形式加载到应用中 URLClassLoader实现类该类是SystemClassLoader和ExtClassLoader的父类，注意不同上面的所谓“父类”，这里是类之间的继承关系。有如下两个构造器： URLClassLoader(URL[] urls)：使用默认父类加载器创建一个ClassLoder对象，并从指定路径加载类。 URLClassLoader(URL[] urls,ClassLoader parent)：不同上面的构造器，它可以指定一个父类加载器加载类。 获得URLClassLoader对象后，就可以调用loadClass()方法来加载指定类。 123456789101112131415161718private static Connection coon;public static Connection getConn(String url,String user,String pass) throws Exception&#123; if(conn = null)&#123; URL[] urls = &#123;new URL(&quot;file:mysql-connector-java-5.1.30-bin.jar&quot;)&#125;; URLClassLoader myClassLoader = new URLClassLoader(urls); //加载MySQL的JDBC驱动，并创建一个实例 Driver driver = (Driver)myClassLoader.loaderClass(&quot;com.mysql.jdbc.Driver&quot;).newInstance(); //创建一个设置JDBC连接属性的properties对象 Properties props = new Properties(); props.setProperty(&quot;user&quot;,user); props.setProperty(&quot;password&quot;,pass); conn = driver.connect(url,props);//连接数据库 &#125; return conn;&#125;public static void main(String[] args) throws Exception&#123; System.out.println(getConn(&quot;jdbc:mysql://localhost:3306/mysql&quot;),&quot;root&quot;,&quot;123456&quot;);&#125;","categories":[{"name":"java","slug":"java","permalink":"https://hawkezou.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://hawkezou.github.io/tags/java/"},{"name":"类加载","slug":"类加载","permalink":"https://hawkezou.github.io/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD/"}]},{"title":"Java注解篇","slug":"Java注解篇","date":"2020-10-16T09:19:31.000Z","updated":"2026-02-11T15:23:56.805Z","comments":false,"path":"2020/1016/","permalink":"https://hawkezou.github.io/2020/1016/","excerpt":"Java注解从Java5开始，Java增加对元数据的支持，也就是Annotation，不是一般的注释。这些标记在编译、类加载、运行时被读取，并执行相应处理。通过使用注解，开发人员在源文件中嵌入一些补充信息，进而代码分析和部署工具可以通过这些补充信息进行部署","text":"Java注解从Java5开始，Java增加对元数据的支持，也就是Annotation，不是一般的注释。这些标记在编译、类加载、运行时被读取，并执行相应处理。通过使用注解，开发人员在源文件中嵌入一些补充信息，进而代码分析和部署工具可以通过这些补充信息进行部署。某方面看，Annotation就像修饰符一样，可用于修饰包、方法和构造器、变量等，这些信息被储存在Annotation的”name&#x3D;value”对中。 Annotation是一个接口，程序可以通反射来获取指定程序元素的Annotation对象，然后通过注解对象来取得里面的元数据。 基本注解注解必须使用工具提取元数据，工具还会根据元数据增加额外的功能，这种处理访问注解的工具统称APT。5个注解都在Java.lang包下，5个基本注解如下： @Override @Deprecated @SuppressWarnings @SafeVarargs(Java7新增) @FunctionalInterface(Java8新增) 限定重写父类：@Override@Override就是用来指定方法覆盖的，它强制一个子类必须重写父类方法，告诉编译器检查这个方法，避免低级错误。注意的是：@Override只能修饰方法，不能修饰其他程序元素！ 标识已过时：@Deprecated该注解表示类、方法、接口已过时，当其他程序使用已过时的类、方法时，编译器将警告。 抑制编译器警告：@SuppressWarnings顾名思义，注解让编译器不会发出警告，如果修饰在类上，则该类不会有任何警告出现，如果修饰方法，则该方法不会有任何警告出现。 123456@SuppressWarnings(value=&quot;unchecked&quot;)public class SuppressTest&#123; public static void main(String[] args)&#123; List&lt;String&gt; myList = new ArrayList(); &#125;//此处泛型语法警告将被抑制&#125; Java7堆污染警告和@SafeVarargs上次讲泛型的时候，把一个不带泛型的对象赋给一个带泛型的变量时，将有可能引起转换异常，这种错误的原因可以称为堆污染。有些时候，开发者不希望看到该警告，可以用以下三种方法抑制警告： @SafeVarargs修饰该方法或构造器 @SuppressWarnings(“unchecked”) 编译使用-Xlint:varargs Java8的函数式接口与@FunctonalInterfaceJava8规定：如果接口中只有一个抽象方法，该接口就是函数式接口。而该注解就是用来指定某个接口必须为函数式接口的，只能含有一个抽象方法。注意：该注解只能修饰接口！ 元注解JDK除了5个基本注解外，还提供了6个元注解，其中5个都用于修饰其他注解定义，其中的@Repeatable专门用于定义Java8新增的重复注解。 @Retention只能用于修饰注解定义，用于指定注解可以保留多长时间。@Retention包含一个RetentionPolicy类型的Value成员变量，使用时指定值。value成员变量的值只能是如下三个： RetentionPolicy.CLASS：编译器把注解记录在class文件中，当运行程序时，JVM不可获取注解信息。默认值！ RetentionPolicy.RUNTIME：编译器把注解记录在class文件中，当运行程序时，JVM可以获取注解信息，程序可以通过反射获取注解信息。 RetentionPolicy.SOURCE：注解只保留在源代码中，编译器之间丢弃。 123@Retention(value=RetentionPolicy.RUNTIME)public class Test&#123;...&#125;//@Retention(RetentionPolicy.RUNTIME) 也可以,当成员变量为value时，可直接填入值 @Target只能修饰一个注解定义，用于指定被修饰的注解能用于修饰哪些程序单元。。同样它也包含一个名为value的成员变量，其值有： ElementType.ANNOTATION_TYPE：指定注解只能修饰注解 ElementType.CONSTRUCTOR：指定该注解只能修饰构造器 ElementType.FIELD：只能修饰成员变量 ElementType.LOCAL_VARIABLE：只能修饰局部变量 ElementType.METHOD：只能修饰方法 ElementType.PACKAGE：只能修饰包 ElementType.PARAMETER：修饰参数 ElementType.TYPE：可以修饰类、接口、注解或枚举定义 同样的操作，在括号内指定value值，可以省去name=value形式，直接填入值。 1@Target(ElementType.FIELD)//只能修饰成员变量 @Documented指定修饰的Annotation类将被javadoc工具提取成文档，如果定义Annotation类使用了该注解，则所有使用该Annotation修饰的程序元素的API文档中将包含该Annotation说明。 12345@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)@Documentedpublic @interface Test&#123;...&#125;//自定义一个注解，该注解信息将被提取进入API文档 @Inherited指定被它修饰的Annotation具有继承性，即某个类使用了该Annotation，则其子类将自动被该Annotation修饰。 12345@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Inheritedpublic @interface i&#123;...&#125;//使用i注解的类，其子类自动含有该注解 自定义注解上面已经提到了自定义注解，跟定义接口差不多，只不过在interface前添加@符号。通常自定义注解可以修饰任何程序元素，比如类、接口、方法等。然而我们可以根据Annotation是否包含成员变量，可以分为两类： 标记注解：没有成员变量，仅提供标记信息。 元数据注解：包含成员变量的Annotation，它们可以接收更多的元数据。 一旦在注解内定义成员变量后，使用时就应该指定成员变量的值，或者直接在注解内指定默认值，可使用default关键字。 1234567891011public @interface MyTag&#123; String name() default &quot;James&quot;; int age() default 32; //int[] ages();&#125;public class Test&#123; @MyTag public void test&#123; ... &#125;&#125; 提取注解信息Java使用Annotation接口来代表程序元素前的注解，该接口是所有注解的的父接口，同时在java.lang.reflect包下新增AnnotatedElement接口，该接口表示可以接收注解的程序元素。该接口的实现类主要有： Class：类定义 Constructor：构造器定义 Field：类的成员变量 Method：类的方法 Package：类的包 包同时还包含一些反射功能的工具类，AnnotatedElement接口是所有程序元素的父接口，所以程序通过反射获取某个类的AnnotatedElement对象之后，就可以调用对象的几个方法来访问Anntation信息。 A getAnnotation(Class annotationClass)：返回指定类型的注解，不存在返回null A getDeclaredAnnotations(Class annotationClass)：获取直接修饰该程序元素、指定类型的Annotation，不存在返回null。 Annotation[ ] getAnnotation()：返回该程序元素上存在的所有注解 Annotation[ ] getDeclaredAnnotations()：返回直接修饰该程序元素的指定Annotation。 boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass)：判断该程序元素上是否有指定类型的注解。 使用第一种的自定义注解，即没有成员变量的注解，它的作用是标记。如下： 123@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface Testable&#123;&#125; 上面的@Testable注解用于标记哪些方法是可以测试的，该注解可以作为JUnit测试的补充。 Java8新增注解重复注解在Java8以前，同一程序元素前最多只能使用一个类型的Annotation，如果需要使用多个相同类型的注解，则必须使用Annotation容器。Java8以前为如下形式： 1@Results(&#123;@Result(name=&quot;James&quot;,location=&quot;james.jsp&quot;),@Result(name=&quot;Kameron&quot;,location=&quot;kameron.jsp&quot;)&#125;) @Results注解只包含一个名为value、类型为Result[]的成员变量，指定多个@Result作为value的属性的数组元素。改进后为： 12@Result(name=&quot;James&quot;,location=&quot;james.jsp&quot;)@Result(name=&quot;Kameron&quot;,location=&quot;kameron.jsp&quot;) 上述即为重复注解，可以被多次使用修饰某一程序元素。开发此类重复注解需要使用@Repeatable修饰。 新增TypeAnnotation注解Java8为ElementType枚举增加了TYPE_PARAMETER、TYPE_USE两个枚举值，这样允许定义枚举时使用@Target(ElementType.TYPE_USE)修饰，这种注解被称为TypeAnnotation 类型注解，TypeAnnotation可用在任何用到类型的地方。比如： 创建对象时(new) 类型转换时 实现接口时 throws声明抛出异常时 以上情况都会用到类型，因此可以使用注解来修饰。 12345678@Target(ElementType.TYPE_USE)@NotNullpublic class TypeTest&#123; public static void main(@NotNull String[] args) throws @NotNull FileNotFoundException&#123; Object a = new @NotNull String(&quot;菜鸡一号&quot;); &#125; public void foo(List&lt;@NotNull String) info)&#123;...&#125;&#125; 要想让这些TypeAnnotation起作用，开发者需要自己实现Type Annotation检查框架或者使用第三方框架。 编译时处理注解APT(Annotation Processing Tool)是一种注解处理工具，它对源代码进行检查，并找出源文件所包含的Annotation信息，做额外处理。使用APT的目的是简化开发者的工作量，因为APT可以在编译程序源代码的同时生成一些附属文件，比如源文件、类文件、XML文件等，内容与源代码文件相关。简而言之，APT可以替代对代码信息和附属文件的维护工作。 Java.exe工具有一个-processor选项，可指定一个Annotation处理器，如果指定了这个处理器，那么这个处理器会在编译时提取并处理源文件中的注解。每个注解处理器都需要实现javax.anntation.processing包下的Processor接口。不过实现该接口必须实现所有方法，因此会采用继承AbstractProcessor方式来实现注解处理器。一个处理器可以处理一种或多种Annotation类型！ 12javac -processor HibernateAnnotationProcessor Person.java//路径下生成一个Person.hbm.xml文件 XML文件根据源代码文件中的Annotation生成，这是使用APT的结果！","categories":[{"name":"java","slug":"java","permalink":"https://hawkezou.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://hawkezou.github.io/tags/java/"},{"name":"注解","slug":"注解","permalink":"https://hawkezou.github.io/tags/%E6%B3%A8%E8%A7%A3/"}]},{"title":"Java泛型篇","slug":"Java泛型篇","date":"2020-10-13T09:19:13.000Z","updated":"2026-02-11T15:22:54.779Z","comments":false,"path":"2020/1013/","permalink":"https://hawkezou.github.io/2020/1013/","excerpt":"Java泛型上次讲了集合，就是放对象的容器，但是集合并不知道对象的具体数据类型，所以很容易发生异常。比如：","text":"Java泛型上次讲了集合，就是放对象的容器，但是集合并不知道对象的具体数据类型，所以很容易发生异常。比如： 12345List a = new ArrayList();a.add(&quot;as&quot;);a.add(&quot;end&quot;);a.add(2);a.forEach(a-&gt;System.out.println(((String)a).length()) );//强制转换错误 Java 泛型generics是JDK 5中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。 假定我们有这样一个需求：写一个排序方法，能够对整型数组、字符串数组甚至其他任何类型的数组进行排序，该如何实现？使用 Java 泛型的概念，我们可以写一个泛型方法来对一个对象数组排序。然后，调用该泛型方法来对整型数组、浮点数数组、字符串数组等进行排序。这样不仅大大减少了代码量，还利于避免不必要的异常！ 泛型菱形语法从Java7开始，在用构造器创建对象时后面不用再带上泛型了，简化了代码，例如： 1List&lt;String&gt; a = new ArrayList&lt;&gt;(); 定义接口、类和泛型方法Java5为接口和类增加了泛型支持，从而可以在创建集合对象时传入类型实参。 12345678910111213141516171819202122232425262728public interface List&lt;E&gt;&#123; void add(E x); Iterator&lt;E&gt; iter(); &#125;public interface StrList extends List&#123; void add(String x); Iterator&lt;String&gt; iter();&#125;public interface StrList extends List&lt;String&gt;&#123; void add(String x); Iterator&lt;String&gt; iter();&#125;public interface Map&lt;K,V&gt;&#123; ...&#125;public class human&lt;T&gt;&#123;//定义一个泛型类 public T man; public human()&#123;&#125; public human(T)&#123;&#125; public T getInfo()&#123; return this.man; &#125;&#125;public class A extends human&lt;String&gt;&#123; public String getInfo()&#123; return &quot;:&quot;+super.getInfo(); &#125;&#125; 上述代码中，定义一个泛型接口，可以衍生出多个类型子接口，同样一个带泛型的父类可以衍生出许多子类，当使用这些接口和父类时，不能再包含类型形参！但是可以不传入类型实参，例如： 12345public class A extends human&#123; public String getInfo()&#123; return super.getInfo().toString(); &#125;//返回字符串类型&#125; 如果需要重写继承父类的子类方法，则需要注意类型。对于泛型，只是允许程序员在编译时检测到非法的类型而已。但是在运行期时，其中的泛型标志会变化为Object类型。 泛型方法方法想定义自己的泛型形参也是允许的，这样还提供了对泛型方法的支持。&lt;&gt;括号内为类型形参声明！ 格式为：修饰符 &lt;T,V&gt; 返回值类型 方法名(形参列表)&#123;...&#125; 123456789101112public class Test&#123; static &lt;T&gt; void test(Collection&lt;? extends T&gt; ele,Collection&lt;T&gt; a)&#123; for(T ele: a)&#123; a.add(ele); &#125; &#125; public static void main(String[] args)&#123; List&lt;Object&gt; ao = new ArrayList&lt;&gt;(); List&lt;String&gt; as = new ArrayList&lt;&gt;(); test(as,ao); &#125;&#125; 泛型构造器123456789101112class Output&#123; public &lt;T&gt; Output(T t)&#123; System.out.println(t); &#125;&#125;public class Test&#123; public static void main(String[] args)&#123; new Output(&quot;发&quot;); new Output(666); new &lt;String&gt; Output(3.14);//实参是Double类型出错 &#125; &#125; 泛型构造器可以认为是泛型方法的特殊一种，不过大致上它们都差不多！ 类型通配符?使用泛型类时，都应该为这个泛型类传入实参，否则会提出警告。类型通配符一般是使用?代替具体的类型参数，它可以匹配任何类型，List&lt;?&gt;在逻辑上是List等所有具体类型实参的父类。 123public void test(List&lt;?&gt; c)&#123; System.out.println(c.get(0));&#125; 这种类型通配符的List仅表示它是各种泛型List的父类，并不能直接添加元素。例如： 12List&lt;?&gt; c = new ArrayList&lt;String&gt;();c.add(new Object()); 由于无法得知c中的元素类型，所以不能向其中添加对象，除了添加null。 类型通配符上限123public void getNumber(List&lt;? extends Number&gt; data) &#123; System.out.println(&quot;data :&quot; + data.get(0));&#125; &lt;? extends T&gt;表示该通配符所代表的类型是T类型的子类(或本身)，&lt;? super T&gt;表示该通配符所代表的类型是T类型的父类。 类型通配符下限类型通配符下限通过形如List&lt;? super Number&gt;来定义，表示类型只能接受Number本身及其父类类型，如Object类型的实例。 泛型方法与类型通配符的区别什么时候用类型通配符，什么时候用泛型方法呢？ 通配符能用来支持灵活的子类化 泛型方法允许类型形参用来表示一个或多个参数或参数与返回值之间的依赖关系 类型通配符可以在方法名中定义形参类型，也可以定义变量类型；但泛型方法的类型形参必须在显示声明 设定类型形参的上限泛型不仅允许使用通配符形参上限，还可以设置类型形参的上限。例如： 123456public class Apple&lt;T extends Number&gt;&#123;//Number及其子类 public static void main(String[] args)&#123; Apple&lt;Integer&gt; a = new Apple&lt;&gt;(); Apple&lt;String&gt; b = new Apple&lt;&gt;();//String不是Number的子类，将引起异常 &#125;&#125; 上面定义了一个泛型类，形参上限是Number及其子类，传入一个String类将导致编译错误。如果需要设定多个上限和接口，表示该形参类型既是父类及其子类，并且实现了多个上限接口。需要注意的是所有接口上限必须在类上限之后，类上限始终在前面。 1public class Apple&lt;T extends Number &amp; java.io.Serializable&gt;&#123;&#125; 擦除和转换严格泛型代码里，带泛型声明的类总应该带着类型参数。但是允许使用带泛型声明的类时，不指定类型实参，如果没有指定的话，则该类型参数被称作raw type原始类型，默认声明为该类型参数的第一个上限类型！ 当把一个带泛型信息的对象赋给另一个没有泛型信息的变量时，泛型信息将抛弃，称擦除。比如一个List&lt;String&gt;类型转给List类型，该List的类型上限变为Object。 如果将List对象赋给一个List&lt;String&gt;对象，不会引起编译错误，但是提示未经检查的转换。 12345List&lt;Integer&gt; a = new ArrayList&lt;&gt;();a.add(6);List list = a;List&lt;String&gt; ls = list;//引起警告System.out.println(ls.get(0));//转换将引起错误 泛型与数组数组元素类型不能包含类型变量或形参，除非无上限类型通配符，但可以声明元素类型包含类型变量或形参的数组。比如：只能说明List&lt;String&gt;[]形式的数组，不能创建ArrayList&lt;String&gt;[10]这样的数组。 1List&lt;String&gt;[] a = new ArrayList[10]; //没有问题","categories":[{"name":"java","slug":"java","permalink":"https://hawkezou.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://hawkezou.github.io/tags/java/"},{"name":"泛型","slug":"泛型","permalink":"https://hawkezou.github.io/tags/%E6%B3%9B%E5%9E%8B/"}]},{"title":"Java工具类","slug":"Java工具类","date":"2020-10-12T09:18:33.000Z","updated":"2026-02-11T15:23:04.460Z","comments":false,"path":"2020/1012/","permalink":"https://hawkezou.github.io/2020/1012/","excerpt":"排序操作Collections提供了如下方法用于对List集合排序： void reverse(List list)：反转顺序 void shuffle(List list)：随机排序 void sort(List list)：按升序排序 void sort(List list ,Comparator)：根据Comparator的顺序指定排序 void swap(List list,int i,int j)：指定元素之间交换 void rotate(List list,int d)：当d为正时，将集合后d个元素整体移到前面；为负时，将前d个元素整体移到后面","text":"排序操作Collections提供了如下方法用于对List集合排序： void reverse(List list)：反转顺序 void shuffle(List list)：随机排序 void sort(List list)：按升序排序 void sort(List list ,Comparator)：根据Comparator的顺序指定排序 void swap(List list,int i,int j)：指定元素之间交换 void rotate(List list,int d)：当d为正时，将集合后d个元素整体移到前面；为负时，将前d个元素整体移到后面 查找替换Collections还提供了如下方法用于查找和替换元素： int binarySearch(List list,Object o)：二分搜索指定List集合，获得对象的索引，前提是集合是有序的。 Object max(Collection c)：根据自然排序，返回最大元素 Object max(Collection c,Comparator comp)：根据指定排序，返回集合中的最大元素 Object min(Collection c)：根据自然排序，返回最小元素 Object min(Collection c,Comparator comp)：根据指定排序，返回集合中的最小元素 void fill(List list,Object o)：使用o替换集合中所有元素 int frequency(Collection c,Object o)：返回集合中o出现的次数 int indexOfSubList(List list,List sublist)：返回子List在集合中第一次出现的位置，若没有则返回-1 int lastIndexOfSubList(List list,List sublist)：返回子List在集合中最后一次出现的位置，若没有则返回-1 boolean replaceAll(List list,Object old,Object new)：使用一个新元素替换所有指定旧元素 同步控制的线程安全Collections工具类提供了多个synchronizedXxx()类方法，该方法将指定集合包装成线程同步的集合。在Map集合中，线程不安全的有HashSet,HashMap,TreeMap,TreeSet,ArrayList,ArrayDeque,LinkedList等，现在可以用该方法包装成线程安全的。 1234Collection c = Collections.synchronizedCollection(new ArrayList());List a = Collections.synchronizedList(new ArrayList());Set s = Collections.synchronizedSet(new HashSet());Map m = Collections.synchronizedMap(new HashMap()); 将创建的对象传入synchronizedXxx()方法，会返回线程安全的List,Map,Set集合对象。 设置不可变集合Collections提供以下三个类方法来返回一个不可变集合： emptyXxx()：返回一个空的，不可变的集合对象，此处集合可以是List，Set,Map。 singletonXxx()：返回一个包含指定对象的不可变集合对象，可以是List,Map。 unmodifiableXxx()：返回集合对象的不可变Map,此处集合可以是List,Set,Map。 方法的参数为原有的集合对象，返回了一个不可变对象(原有对象的不可变版本)。","categories":[{"name":"java","slug":"java","permalink":"https://hawkezou.github.io/categories/java/"}],"tags":[{"name":"集合","slug":"集合","permalink":"https://hawkezou.github.io/tags/%E9%9B%86%E5%90%88/"},{"name":"工具类","slug":"工具类","permalink":"https://hawkezou.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"}]},{"title":"Java构造器和初始化块","slug":"Java构造器和初始化块","date":"2020-09-24T05:20:19.000Z","updated":"2026-02-11T15:23:35.139Z","comments":false,"path":"2020/0924/","permalink":"https://hawkezou.github.io/2020/0924/","excerpt":"Java构造器和初始化块构造器是一个特殊的方法，但定义构造器和普通方法没什么太大区别，该有的都有。不过为了区分还是看看不一样的地方。","text":"Java构造器和初始化块构造器是一个特殊的方法，但定义构造器和普通方法没什么太大区别，该有的都有。不过为了区分还是看看不一样的地方。 方法名：构造器方法名需要和类名一样 返回值：构造器不定义返回值，也不用返回void，但是它会返回一个对象(隐式的) 修饰符：一般设为public权限，可以被其他方法调用 不是静态的：构造器方法不用static修饰 在定义一个类时，没有写构造器，系统将默认提供一个无参构造器。构造器是创建一个对象的途径之一。上面的第四点很少有书提到，但是我们也很少见到用static修饰的构造器—静态构造器。这里先讲一个知识点：在static修饰的方法中如果使用this关键字，则关键字无法指向对象。而访问非静态成员是隐式访问，在没有重名下，省略了this关键字，所以静态成员是无法访问非静态成员。回到static修饰，构造器如果用静态的，则不能访问非静态成员，而构造器是用来初始化成员变量的，那怎么初始化，怎么创建对象？最后还要返回对象。其次，创建对象会比较麻烦，new类名加构造器是不可想象的！ 既然构造器不用类名加构造器访问，开始又没有实例对象，那如何访问呢？因此，Java提供关键字new来调用构造器，所以在构造器中关键字this表示构造器正在初始化的对象，当然大多数情况下可以省略，除了构造器中有一个重名的局部变量的情况下。 1234public MyConstructor()&#123; int son = 0; this.son = 6;//构造器会把所有对象的son属性初始化为6&#125; 构造器的作用主要作用还是为了初始化，默认初始化把所有数字基本类型实例变量设为0，布尔类型为false，引用类型为null，如果想改变一下，可以在构造器中定义。 1234public MyConstructor(String name,int age)&#123; this.name = name;//传入两参数 this.age = age;&#125; 需要注意的是构造器不是全权负责创建对象，在执行构造器之前，系统已为对象分配了内存，结束后构造器返回对象，让引用指向该对象。 构造器重载如果想保留无参构造器，可以提供多个构造器，形成构造器重载。重载后，构造器的参数列表是不一样的，这样能利用不同的构造器创建不同的对象。如果包含多个构造器，其中一个构造器代码包含另一个，如下。这种情况是可以有简洁的代码代替的，但构造器不能直接被调用，用new关键字又会创建一个对象，则使用this关键字很好解决，this调用另一个重载的构造器。此种方法仅限在构造器中使用 1234567891011121314151617public class dog&#123; public String name; public int age; public int weight; public dog()&#123;&#125; public dog(String name,int age)&#123; this.name = name; this.age = age; &#125; public dog(String name,int age,int weight)&#123; this(name,age);//调用另一个构造器的初始化代码 //其实还可以用以下代码代替,但是不建议 //this.name = name; //this.age = age; this.weight = weight; &#125;&#125; 调用父类构造器子类继承父类不会获得父类的构造器，但子类构造器可以调用父类构造器的初始化代码，类似上面的调用另一个重载构造器。在一个构造器中调用另一个构造器用this完成，在子类构造器中调用父类构造器则用super完成。super调用必须出现在子类构造器的第一行，因为Java设计子类执行构造器必须先调用父类构造器，所以它是第一行，然后，然后就没this啥事了，因为刚才讲了，再this调用又要执行父类构造器。this与super不能同时使用！ 子类继承了父类的属性和方法，所以在先初始化父类的属性和方法，这样子类才可以初始化自己特有的，因为java中不允许调用没有初始化的成员。 this就是调用本类的其他构造函数，在其他构造函数中也有默认的super()，或者自定义了带参的super，这样就初始化了父类的成员了，所以写了this的构造函数不能再写super了，因为实例化一个对象运行两次super是不安全的。this放在第一行，也是因为要先初始化父类和this代表的构造函数先，因为当前构造函数可能用到那些成员，所以那些成员得要先初始化 不管是否使用super调用父类构造器，子类总会调用父类构造器一次，有以下情况： 子类构造器使用super显式调用父类构造器 子类构造器使用this调用重载构造器，执行前重载构造器先会隐式调用父类构造器 子类构造器既无super调用，也没有this调用，则系统默认调用父类无参构造器 创建任何对象时，总是从该类所在继承树最顶层类的构造器开始执行，然后往下执行到本类构造器。如果父类构造器还调用了重载构造器，那就会依次执行多个构造器。 初始化块跟构造器作用差不多，初始化块也可以进行对象初始化，它比构造器先执行。它也是类的一种成员，修饰符只能用static修饰，被修饰称为静态初始化块，也可以不修饰。 1234567&#123; a = 6;&#125;int a = 9;public test()&#123; System.out.println(new MyInstance().a);&#125;//输出9，实例变量值为9 类和对象无法调用初始化块，初始化块只在创建对象时隐式执行，而且在构造器之前执行。此外，普通初始化块、声明实例变量指定默认值，都可认为是对象的初始化块，执行顺序和排列顺序一样。 当创建一个对象时，系统先为对象的所有实例变量分配内存，接着程序开始对实例变量初始化，初始化顺序是：先执行初始化块或声明实例变量时指定初始值，再执行构造器中的初始值。 初始化块和构造器与构造器不同，初始化块是一段固定的代码，不接收参数，因此初始化块对同一个类的所有对象的初始化处理是一样的。所以就这种特点，我们可以利用来初始化相同一段值。构造器中相同一段代码可以提炼出相同初始化块，简化了程序，提高了复用性和可维护性。 实际上在编译Java块后，初始化块会消失，初始化块的代码会被“还原”到构造器中，且位于构造器代码前面！ 与构造器类似，创建一个Java对象，不仅会执行该类的普通初始化块和构造器，而且系统会从Object类开始执行，往下执行父类，然后才到该类的初始化块和构造器。如果希望类加载后对整个类进行初始化操作，例如把类变量初始化一下，则需要用静态初始化块。 静态初始化块也叫类初始化块，属于类的静态成员，同样需要遵循静态成员不能访问非静态成员的规则。普通初始化块负责对对象执行初始化，类初始化块则负责对类进行初始化。类初始化时，系统执行静态初始化块。静态初始化块是类相关的，系统将在类初始化阶段执行静态初始化块，而不是创建对象时才执行，因此静态初始化块总是比普通初始化块先执行。静态初始化块不能对实例变量进行初始化处理。 与普通初始化块类似，系统执行类的静态初始化块不仅会执行本类的静态初始化块，还会从源头类Object类开始执行，道理一样。类初始化后，才能使用这个类，然后才能创建对象。一旦类初始化成功，该类在JVM中一直存在，所以创建实例时，无须对类进行初始化。创建实例时，都需要先执行顶层父类的初始化块、构造器，然后执行父类的初始化块、构造器，然后执行本类的初始化块和构造器。静态初始化块-&gt;普通初始化块-&gt;构造器 Java系统加载并初始化某个类时，总是保证该类的所有父类全部加载和初始化！静态初始化块和声明静态变量时所指定的初始值都是该类的初始化代码。JVM第一次主动调用某个类，系统会在类准备阶段为该类所有静态成员分配内存，初始化阶段负责初始化。 123456789public class Test&#123; static &#123; //(1) a = 6; &#125; static int a = 9;//(2) public static void main(String[] args)&#123; System.out.println(Test.a); &#125;//输出9，如果调换(1)(2)则为6&#125;","categories":[{"name":"java","slug":"java","permalink":"https://hawkezou.github.io/categories/java/"}],"tags":[{"name":"构造器重载","slug":"构造器重载","permalink":"https://hawkezou.github.io/tags/%E6%9E%84%E9%80%A0%E5%99%A8%E9%87%8D%E8%BD%BD/"},{"name":"初始化块","slug":"初始化块","permalink":"https://hawkezou.github.io/tags/%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9D%97/"},{"name":"静态初始化块","slug":"静态初始化块","permalink":"https://hawkezou.github.io/tags/%E9%9D%99%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9D%97/"}]},{"title":"变量分类和运行机制及自动装拆箱","slug":"变量分类和运行机制及自动装拆箱","date":"2020-09-19T12:52:12.000Z","updated":"2026-02-11T15:26:13.951Z","comments":false,"path":"2020/0919/","permalink":"https://hawkezou.github.io/2020/0919/","excerpt":"成员变量和局部变量及运行机制两者的区别在于定义变量的位置不同，运行的机制也有差异。成员变量定义在类中，局部变量定义在定义在方法中。","text":"成员变量和局部变量及运行机制两者的区别在于定义变量的位置不同，运行的机制也有差异。成员变量定义在类中，局部变量定义在定义在方法中。 成员变量分为类变量和实例变量两种，局部变量分为形参(方法内)、方法局部变量和代码块内局部变量，比如循环内的。类变量的生命周期和类一样，从类准备阶段开始，到完全销毁这个类，作用域则与类的生存范围相同。而实例变量从实例被创建起开始存在，直到实例被销毁，作用域对应实例作用域。可以发现，成员变量之所以称为成员变量，是因为其与所在的整体共存亡的。 注意：类变量是属于类的，通过实例.类变量访问的依然是类变量，如果该实例修改了变量值，则其他实例访问时也将使用修改过的变量值。即访问了同一片内存区！ 与成员变量不同，局部变量除了形参外，都必须显式初始化；而上面的成员变量可以进行默认初始化，赋值规则与数组动态初始化时赋值规则相同。 当通过类或对象调用某个方法时，系统1会在调用该方法栈区内为所有形参分配内存，并将实参值赋值给对应形参，即完成形参初始化。 Java允许局部变量和成员变量同名，如果需要在方法内引用被覆盖的成员变量(局部变量和成员变量同名)，可以使用this关键字。 123456789101112131415public class Test&#123; public String name = &quot;猴子&quot;; public static int age = 500; public void outPut()&#123; String name = &quot;悟空&quot;; System.out.println(name);//&quot;悟空&quot; System.out.println(this.name);//&quot;猴子&quot; &#125; public static void main(String[] args)&#123; double age = 100000.0; System.out.println(age);//100000.0 System.out.println(Test.age);//500 new Test().outPut(); &#125;&#125; 成员、局部变量初始化及运行机制在类初始化或对象初始化时，系统会为成员变量分配内存空间，并指定默认初始值。需要关注的是，在创建一个对象时，不需要给类变量分配内存空间，只是为实例变量分配内存空间，因为类初始化时已经分配好了。在创建多个对象时，同样如此，也需要为实例变量分配内存空间，而且，实例变量是单个实例的，与类或其他实例无关。 局部变量定义后，必须经过显式初始化后才能使用，系统不会为局部变量执行初始化，就不会为变量分配内存空间，直到变量被初始化。与成员变量不同，局部变量不属于任何实例或类，因此它被保存在所在的方法栈中。如果变量是基本类型的变量，则会把值直接保存在对应内存中；但是变量是引用类型，则它存放的是地址，地址是所引用的对象或数组的地址。 局部变量的生命周期是和方法或代码块一致，但所在栈内存无需垃圾回收，因为局部变量只保存基本类型的值或引用，所以所占内存比较小。 包装类基本数据类型不具备对象特性：无成员变量，方法被调用。但有些时候显得不那么好，比如方法需要object类型的参数，并且需要提供实际值，像2，3，4，这就麻烦了。Java提供了包装类概念，并为8种基本数据类型定义了引用类型(基本数据类型的包装类)。 基本数据类型 包装类 byte Byte short Short int Integer long Long char Character float Float double Double boolean Boolean 上述除Character外，其他包装类可传入参数创建一个包装类对象， 由于基本数据类型和包装类对象之间转换麻烦，JDK1.5提供了自动装箱和拆箱功能，去解决该问题。 自动装箱：基本类型变量赋值给包装类(或者Object变量)；自动拆箱：包装类对象赋值给基本类型变量 123Integer a = 5;//基本类型赋值给Integer对象Object b = true;//把布尔类型赋值给Object对象int c = a;//Integer对象拆箱赋值给基本类型 虽然包装类是引用类型，但是实例是可以与数值比较的，比较时直接取出包装类的值进行比较。而包装类对象之间比较，只有指向同一对象时返回true。 12345System.out.println(new Integer(1) == new Integer(1));//falseInteger a = 6;Integer b = 6;System.out.println(a == b);//true,待会解释//注意，Integer数据范围在-128~127之间，若不在会重新创建实例 从上面来看，系统将整数装箱成实例，会放入一个cache数组(长度为256，Java就是这样设计的)中缓存起来，以后如需自动装箱则直接指向数组元素(若在-128~127之间)，即引用同一个实例对象。这样的缓存设计有利程序的运行性能，节省开销。 字符串与基本类型的转换字符串转基本类型有两种方式： 包装类的parseXxx(String s)方法(除了Character包装类外) 对应的构造器方法，Xxx(String s) 基本类型转字符串则使用String的多个重载valueOf方法。上述代码示例： 123456String str = &quot;123&quot;;int a = Integer.parseInt(str);//第一种方法int b = new Integer(str);//构造器创建对象，之后拆箱赋值给变量b//基本数据类型转字符串String str1 = String.valueOf(3.14159f);String str2 = String.valueOf(true); Java7、8增强包装类Java7开始为所有包装类提供静态的compare(v1,v2)方法，则可以通过该方法比较基本值的大小。比如： 123System.out.println(Boolean.compare(true,false));//1System.out.println(Boolean.compare(true,true));//0System.out.println(Boolean.compare(false,true));//-1 Java8再次增强，开始支持无符号算术运算。如为Integer、Long增强了静态的toUnsignedString(int&#x2F;long v)整型转化成无符号整数对应的字符串、toUnsignedString(int&#x2F;long v，int radix)转化成指定进制无符号整数对应的字符串。 无符号整数的二进制最高位不再当作符号位看，即最小值为0。例如-2，对应的无符号整数为252","categories":[{"name":"java","slug":"java","permalink":"https://hawkezou.github.io/categories/java/"}],"tags":[{"name":"变量分类","slug":"变量分类","permalink":"https://hawkezou.github.io/tags/%E5%8F%98%E9%87%8F%E5%88%86%E7%B1%BB/"},{"name":"自动装拆箱","slug":"自动装拆箱","permalink":"https://hawkezou.github.io/tags/%E8%87%AA%E5%8A%A8%E8%A3%85%E6%8B%86%E7%AE%B1/"}]},{"title":"继承和组合、单例类及不可变类","slug":"继承和组合、单例类及不可变类","date":"2020-09-17T13:15:46.000Z","updated":"2026-02-11T15:26:41.087Z","comments":false,"path":"2020/0917/","permalink":"https://hawkezou.github.io/2020/0917/","excerpt":"继承和组合、单例类及不可变类继承 inheritance：继承是实现类复用的重要手段，所谓复用，就是可以多次使用，或者再次利用，不用继续重写成员变量和方法。但不代表没有缺点，最不好的地方：破坏封装。子类拓展父类时，若访问权限允许，则可直接访问父类的成员变量和方法，破坏了良好的封装性(Encapsulation) ，造成子类与父类的耦合。","text":"继承和组合、单例类及不可变类继承 inheritance：继承是实现类复用的重要手段，所谓复用，就是可以多次使用，或者再次利用，不用继续重写成员变量和方法。但不代表没有缺点，最不好的地方：破坏封装。子类拓展父类时，若访问权限允许，则可直接访问父类的成员变量和方法，破坏了良好的封装性(Encapsulation) ，造成子类与父类的耦合。 因而，设计父类时应注意以下几点： 尽量隐藏内部数据 不要让子类随意访问 不要在父类的构造器中调用将被子类重写的方法 组合 combination对于继承而言，子类可以获取父类的public方法，使用子类时，可以访问子类从父类继承的方法；组合则是把旧类对象作为成员变量组合进来。我们不需要看到被组合进来的对象的方法，所以通常用private修饰。在功能上，两者没什么区别。 1234567891011121314151617181920class animal&#123; private void beat()&#123; System.out.println(&quot;心跳！&quot;); &#125; public void breath()&#123; System.out.println(&quot;呼吸！&quot;); &#125;&#125;class bird&#123; private animal a; public bird(animal)&#123; this.a = a; &#125; public void breath()&#123; a.breath();//复用animal的方法 &#125; public void fly()&#123; System.out.println(&quot;芜湖起飞！&quot;); &#125;&#125; 注意： 使用组合关系实现复用，需要创建两个animal对象，是否意味着开销更大？ 当创建一个子类对象时，系统不仅需要为该子类定义实例变量分配内存空间，而且需要为它父类所定义的实例变量分配内存。采用继承的方式，假设父类定义了两个实例的变量，子类定义了3个变量。创建子类实例时需要为子类分配5块内存空间。当采用组合设计时，先创建父类实例，此时需要分配2快内存，再创建整体类实例，也需要分配3块内存，只是多了一个引用变量来引用所组合的对象。因此，组合和继承设计开销不会有太大差别。 单例类这种类不像其他类，某些时候允许其他类自由创建该类对象没有什么意义，所以要降低对它的访问权限，让这样的类只能创建一个实例。 方法是把该类的构造方法用private修饰起来，但又需要创建一个对象，所以需要提供一个public方法去用于创建该类的对象，但是不是通过对象来创建对象，而是用类本身去创建，因此方法要用static修饰。 除此之外，该类还必须缓存对象，记录已创建的对象。同时让该静态方法能访问到，保存对象的成员变量也需要static修饰。 12345678910111213class person&#123; //静态成员变量来保存对象 private static person OnlyPerson; //对构造器隐藏 private person()&#123;&#125; //公共方法 public static person getPerson()&#123; if(OnlyPerson==null)&#123; OnlyPerson = new person(); &#125; return OnlyPerson; &#125;&#125; 不可变类 immutable不可变类意思是创建该类的实例后，该实例的变量不可变。Java提供的8个包装类和String类都是不可变类！ 12Double d = new Double(5.6);String s = new String(&quot;abc&quot;); 上面创建了一个Double和String对象，并传入两个值，但程序无法继续修改该值，所以Double和String类没有修改值的方法。 如果要创建一个不可变类，需要遵守如下规则： 使用private和final修饰符来修饰该类成员 提供带参构造器，用于初始化成员 仅提供get方法 确保引用的对象不会被修改 重写hashCode()方法和equals()方法 与此对应的是可变类，比如JavaBean，提供了getter()和setter方法。 缓存实例的不可变类不可变类的实例状态不可改变，可以方便被多个对象共享，主要是为了减小开销。不同的缓存方式有着不同的性能，可以用数组、集合等来缓存。 以Java的java.lang.Integer类为例，new一个构造器，每次返回新的Integer对象；如果用valueOf()方法来创建Integer对象，则会缓存该对象。 123456789101112public class IntegerCacheTest&#123; public static void main()&#123; //new一个对象 Integer a1 = new Integer(6); //生成新对象，并缓存该对象 Inreger a2 = Integer.valueOf(6); Integer a3 = Integer.valueOf(6); System.out.println(a1 == a2);//false System.out.println(a2 == a3);//true //注意：缓存的数只能在-128~127之间 &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://hawkezou.github.io/categories/java/"}],"tags":[{"name":"继承","slug":"继承","permalink":"https://hawkezou.github.io/tags/%E7%BB%A7%E6%89%BF/"},{"name":"组合","slug":"组合","permalink":"https://hawkezou.github.io/tags/%E7%BB%84%E5%90%88/"},{"name":"单例类","slug":"单例类","permalink":"https://hawkezou.github.io/tags/%E5%8D%95%E4%BE%8B%E7%B1%BB/"},{"name":"不可变类","slug":"不可变类","permalink":"https://hawkezou.github.io/tags/%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%B1%BB/"}]},{"title":"String与BigDecimal基础类","slug":"String与BigDecimal基础类","date":"2020-09-16T11:53:38.000Z","updated":"2026-02-11T15:25:58.768Z","comments":false,"path":"2020/0916/","permalink":"https://hawkezou.github.io/2020/0916/","excerpt":"","text":"String与BigDecimalString, StringBuffer and StringBuilderstring有11种构造方法 1. 可变性 String不可变 StringBuffer 和 StringBuilder 可变 在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 coder 来标识使用了哪种编码。 12345678public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; /** The value is used for character storage. */ private final byte[] value; /** The identifier of the encoding used to encode the bytes in &#123;@code value&#125;. */ private final byte coder;&#125; value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。 2. 线程安全 String 不可变，因此是线程安全的 StringBuilder 不是线程安全的 StringBuffer 是线程安全的，内部使用 synchronized 进行同步 String Pool字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。不仅如此，还可以使用 String 的 intern() 方法在运行过程将字符串添加到 String Pool 中。 当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。 下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同字符串，而 s3 和 s4 是通过 s1.intern() 方法取得同一个字符串引用。intern() 首先把 s1 引用的字符串放到 String Pool 中，然后返回这个字符串引用。因此 s3 和 s4 引用的是同一个字符串。 123456String s1 = new String(&quot;aaa&quot;);String s2 = new String(&quot;aaa&quot;);System.out.println(s1 == s2); // falseString s3 = s1.intern();String s4 = s1.intern();System.out.println(s3 == s4); // true 如果是采用 “bbb” 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。 123String s5 = &quot;bbb&quot;;String s6 = &quot;bbb&quot;;System.out.println(s5 == s6); // true 在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。 new String(“abc”)使用这种方式一共会创建两个字符串对象（前提是 String Pool 中还没有 “abc” 字符串对象）。 “abc” 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 “abc” 字符串字面量； 而使用 new 的方式会在堆中创建一个字符串对象。 创建一个测试类，其 main 方法中使用这种方式来创建字符串对象。 12345public class NewStringTest &#123; public static void main(String[] args) &#123; String s = new String(&quot;abc&quot;); &#125;&#125; 使用 javap -verbose 进行反编译，得到以下内容： 123456789101112131415161718192021// ...Constant pool:// ... #2 = Class #18 // java/lang/String #3 = String #19 // abc// ... #18 = Utf8 java/lang/String #19 = Utf8 abc// ... public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=3, locals=2, args_size=1 0: new #2 // class java/lang/String 3: dup 4: ldc #3 // String abc 6: invokespecial #4 // Method java/lang/String.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V 9: astore_1// ... 在 Constant Pool 中，#19 存储这字符串字面量 “abc”，#3 是 String Pool 的字符串对象，它指向 #19 这个字符串字面量。在 main 方法中，0: 行使用 new #2 在堆中创建一个字符串对象，并且使用 ldc #3 将 String Pool 中的字符串对象作为 String 构造函数的参数。 以下是 String 构造函数的源码，可以看到，在将一个字符串对象作为另一个字符串对象的构造函数参数时，并不会完全复制 value 数组内容，而是都会指向同一个 value 数组。 1234public String(String original) &#123; this.value = original.value; this.hash = original.hash;&#125; BigDecimalJava在java.math包中提供的API类BigDecimal，用来对超过16位有效位的数进行精确的运算。双精度浮点型变量double可以处理16位有效数。在实际应用中，需要对更大或者更小的数进行运算和处理。float和double只能用来做科学计算或者是工程计算，在商业计算中要用java.math.BigDecimal。BigDecimal所创建的是对象，我们不能使用传统的+、-、*、&#x2F;等算术运算符直接对其对象进行数学运算，而必须调用其相对应的方法。方法中的参数也必须是BigDecimal的对象。构造器是类的特殊方法，专门用来创建对象，特别是带有参数的对象。 BigDecimal一共有4个构造方法: BigDecimal(int) 创建一个具有参数所指定整数值的对象。 BigDecimal(double) 创建一个具有参数所指定双精度值的对象。（不建议采用） BigDecimal(long) 创建一个具有参数所指定长整数值的对象。 BigDecimal(String) 创建一个具有参数所指定以字符串表示的数值的对象 这里不建议采用第二种，原因： 1、参数类型为double的构造方法的结果有一定的不可预知性。有人可能认为在Java中写入 newBigDecimal(0.1)所创建的BigDecimal正好等于 0.1，但是它实际上等于0.1000000000000000055511151。这是因为0.1无法准确地表示为 double（或者说对于该情况，不能表示为任何有限长度的二进制小数）。这样，传入到构造方法的值不会正好等于 0.1（虽然表面上等于该值）。 2、另一方面，String 构造方法是完全可预知的：写入 newBigDecimal(“0.1”) 将创建一个 BigDecimal，它正好等于预期的 0.1。因此，比较而言，通常建议优先使用String构造方法 。 1BigDecimal a = new BigDecimal(&quot;2.3&quot;); 当double必须用作BigDecimal的源时，请使用Double.toString(double)转成String，然后使用String构造方法，或使用BigDecimal的静态方法valueOf，如下： 1BigDecimal a = new BigDecimal.valueOf(Double.toString(2.3)); 对于常用的加，减，乘，除，BigDecimal类提供了相应的成员方法 1234public BigDecimal add(BigDecimal value); //加法public BigDecimal subtract(BigDecimal value); //减法 public BigDecimal multiply(BigDecimal value); //乘法public BigDecimal divide(BigDecimal value); //除法 总结: 在需要精确的小数计算时再使用BigDecimal，BigDecimal的性能比double和float差，在处理庞大，复杂的运算时尤为明显。故一般精度的计算没必要使用BigDecimal。 尽量使用参数类型为String的构造函数。 BigDecimal都是不可变的（immutable）的， 在进行每一次四则运算时，都会产生一个新的对象 ，所以在做加减乘除运算时要记得要保存操作后的值。","categories":[{"name":"Java","slug":"Java","permalink":"https://hawkezou.github.io/categories/Java/"}],"tags":[{"name":"String","slug":"String","permalink":"https://hawkezou.github.io/tags/String/"},{"name":"BigDecimal","slug":"BigDecimal","permalink":"https://hawkezou.github.io/tags/BigDecimal/"}]},{"title":"SQL server连接本地数据库的两个问题","slug":"SQL-server连接本地数据库的两个问题","date":"2020-05-22T21:46:14.000Z","updated":"2026-02-11T15:25:19.988Z","comments":true,"path":"2020/0523/","permalink":"https://hawkezou.github.io/2020/0523/","excerpt":"SQL Server连接本地数据库时的异常 最近想学点SQL server,几个月前下过，可中间电脑换过机名，重装过系统(电脑不是键盘一下没反应就是鼠标没反应)，充分暴露出windows的不稳定。这告诉我们：要早点和windows离婚吧，换一个漂亮又好用点的linux系统(关键是免费开源)，如果有钱可以跟风mac。哈哈！所以呢，系统里的环境变量全部没了，除了操作系统本身的变量外。经验告诉我们：换系统就是换血，把C盘的除系统外的渣渣都清除了，还好是其他盘的东西还在，不过又得手动配置她们的变量了。","text":"SQL Server连接本地数据库时的异常 最近想学点SQL server,几个月前下过，可中间电脑换过机名，重装过系统(电脑不是键盘一下没反应就是鼠标没反应)，充分暴露出windows的不稳定。这告诉我们：要早点和windows离婚吧，换一个漂亮又好用点的linux系统(关键是免费开源)，如果有钱可以跟风mac。哈哈！所以呢，系统里的环境变量全部没了，除了操作系统本身的变量外。经验告诉我们：换系统就是换血，把C盘的除系统外的渣渣都清除了，还好是其他盘的东西还在，不过又得手动配置她们的变量了。 01 SQL SERVER初探初入SQL SERVER的可能不知道有两种版本分类的SQL SERVER，那现在就普及一下。第一种是MSSQL SERVER,全称是Microsoft SQL Sever，开发版，目前的大型网站一般使用Oracle或者MSSQL，JSP.PHP.ASP都可以。一般是企业级的商务网站使用的。全功能SQL数据库服务器，从2017版开始，横跨任何平台，完全免费。第二种是Express ，商业免费，有对应的限制一般都用这个。是SQL SERVER的简洁版，可以这样说。 但开始我也不懂啊，也没人叫我怎么玩哈，所以最近发现SQL不见了，就急忙下个SQL server2019最新版的玩一下。不行的是下载了6个多G，连带管理工具一起下(都是开热点的流量啊！啊啊！)，N久后，才下完！然后安装！！！N久。 起初是发现从前的2017版的没有了，主要是SSMS没有，SSMS是SQL SERVER Management Studio,SQL SERVER管理工具，用来管理数据库的，而我们下的是SQL SERVER的一个下载工具罢了。没SSMS还是玩不起来。 02 第一个问题：配置管理器无法连接到 WMI 提供程序 这个问题我记住你了，化成灰我都认得你！！ 弄了我一整晚，网上都查遍了，每个有效的方法。现在给大家清楚讲一遍，按上面的说，WMI,（Windows Management Instrumentation 即windows 管理规范）是一项核心的 Windows 管理技术；用户可以使用 WMI 管理本地和远程计算机。简单点，就是管本地和远程计算机的一个东西。有点内味了！！也就是说要这个服务来帮助SQL配置管理器管理计算机的，那怎么管呢？ 有两种解决方法：要么是没权限，弄权限；要么是服务器真的不能访问了，解决服务器。很明显，连自己的本地的机子，还说无法访问，那就是没权限啦。查查了半天，说要弄一个NETWORK SERVICE的权限，也弄了没反应，估计还不够吧！之后又有其他办法，说进如：”C:\\Program Files (x86)\\Microsoft SQL Server”里面，我的是这样的，里面是90‘100’120‘的数字文件夹(跟系统打交道的)，不是真正的SQL SERVER文件夹(有界面的那个)。 其中有一个shared文件夹里有150\\Shared\\sqlmgmproviderxpsp2up.mof这个文件。 我的是150&#x2F;，可能不一样。之后在命令行输入： mofcomp “C:\\Program Files(x86)\\MicrosoftSQLServer\\150\\Shared\\sqlmgmproviderxpsp2up.mof” 结果：将本地数据放到SQL储存库中了，就表示能访问到。那mof是个什么东西呢！ 反正就是微软瞎造的东西，跟配置有关。不管了！可以正常打开配置管理器，但是里面项目为空，啥也看不到呀！正常是这样的： 但是右边什么也没有，而且，SSMS还是连不上本地的数据库实例。 第二个问题：系统找不到指定的文件GUI是这样的：本来是输入个本机名字就行了，可就是死活连不上。SSMS: 想玩我？没门！这个时候，还是用的2017的SQL配置管理器，2019的SQLEXPRESS，连2019的配置管理器都没有，当然弄不了了。那之前的努力都白搭，花了我N久弄完！ 其实挺简单的，一步解决上面两个问题，还能使用最新的2019SQL SERVER。对啦，就是重新安装，不用开浏览器上什么官网，直接follow me。哈哈！ 找到SQL SERBER的安装目录，就是那个有安装的SQL server2019： D盘文件夹： sqlserver文件夹里是这样的： 之后一路默认安装： 安装期间会同时实例化本地的数据库，以windows管理员的身份管理，完成后就能看到开始菜单里有2019配置管理器了： sercice服务里也会有SQL服务，之前是没有的，即使解决了第一个问题后。估计这就是第二个问题没解决的原因吧！没SQL server服务，就没得玩喽！ 所以最后献上玩美结果： 哈哈，如果要用Network service权限解决的话请参考另一篇最后祝大家玩的愉快！！ 最后附上：小码csdn博客园微信公众号：小码之光","categories":[{"name":"SQL","slug":"SQL","permalink":"https://hawkezou.github.io/categories/SQL/"}],"tags":[{"name":"SQLserver","slug":"SQLserver","permalink":"https://hawkezou.github.io/tags/SQLserver/"}]},{"title":"virtualbox虚拟机安装","slug":"virtualbox虚拟机安装","date":"2020-04-25T04:43:02.000Z","updated":"2026-02-11T15:26:06.429Z","comments":true,"path":"2020/0425/","permalink":"https://hawkezou.github.io/2020/0425/","excerpt":"用虚拟机virtualbox安装ubantu桌面系统 下载ubantu镜像 下载安装虚拟机 新建一个虚拟电脑Linux01 安装ubantu镜像 （网络设置）","text":"用虚拟机virtualbox安装ubantu桌面系统 下载ubantu镜像 下载安装虚拟机 新建一个虚拟电脑Linux01 安装ubantu镜像 （网络设置） 01 下载ubantu镜像要想在虚拟机里玩ubantu，就要先准备好该系统的iso镜像文件，那么我们就直接到了官网去了 可是我们点击下载后速度又慢了，比github还慢，原因就不说了。所以当然有更快的方法啦！不一定非要去国外的官网下载，国内的各大高校和巨头都有镜像站提供免费的镜像下载，这里就给大家推荐一番。 阿里云开发者社区镜像站第一个就是ubantu,这里可以下server或desktop都可以，反正又快又免费！哈哈 浙大镜像站 为什么选择浙江大学的镜像站呢？国内有很多这样的镜像站啊。。。。当然是快啦，相比较其他大学的站点，算是比较好了。 我是在阿里云下的，起初弄不清server和desktop版，就先下了server版，结果就是疑惑了半天，也没出现漂亮的界面。 02 安装oracle virtualbox虚拟机这个就有点难下了，我没在镜像站里找，在网盘下的。(VMware需要许可证)这里大家可以搜一搜，分享VM 提取码：vz1h 下载好安装包后，打开就行了 03 新建虚拟电脑Linux01点击新建，选择要安装的系统，之后就是一路默认。 内存最好配置在2G以上 04 安装ubantu镜像虽然已经有一个虚拟电脑了(其实就是占用宿主机的磁盘空间)，这个时候只有硬件上的支持，还没有系统文件的调用。所以咋们进入启动Vbox界面的设置项 红色箭头那点击进入，再点击注册项，即可从宿主机文件里选择下载好的ubantu镜像文件 ok,配置好后，再启动虚拟电脑，就进入ubantu系统安装界面了，而不是命令行。 1接下来就是安装了 这里可以选择试用或者安装ubantu，安装后启动就直接进入虚拟电脑工作界面了。 界面还是很漂亮的，不过virtualbox是小型机，界面不能全屏，如果可能还是选VMware虚拟机吧，试过，感觉就是香！哈哈！ 05 网络设置 这里就不过多讲了，建好后可以配置网络，有自己的cdn节点。推荐程序羊","categories":[{"name":"linux","slug":"linux","permalink":"https://hawkezou.github.io/categories/linux/"}],"tags":[{"name":"ubantu","slug":"ubantu","permalink":"https://hawkezou.github.io/tags/ubantu/"},{"name":"virtualbox虚拟机","slug":"virtualbox虚拟机","permalink":"https://hawkezou.github.io/tags/virtualbox%E8%99%9A%E6%8B%9F%E6%9C%BA/"}]},{"title":"连接远程服务器出现乱码","slug":"连接远程服务器出现乱码","date":"2020-04-19T14:27:06.000Z","updated":"2026-02-11T15:26:48.498Z","comments":true,"path":"2020/0419/","permalink":"https://hawkezou.github.io/2020/0419/","excerpt":"连接远程服务器后出现命令行乱码真是巧了，最近遇到的事儿净跟编码有关，好像中了毒一样。话不多说，看乱码。","text":"连接远程服务器后出现命令行乱码真是巧了，最近遇到的事儿净跟编码有关，好像中了毒一样。话不多说，看乱码。大家已经看到了，连上服务器后的写个文件的目录命令，就只拉出了四个字，呃，不对，还有一个零蛋。好，这种乱码现象其实已经多见少怪了，然而还是有原因的，不然我怎么会写个博客记录一下。值得注意的就是在命令行出现乱码的情况很少，还是敲了命令之后，何况有的小伙伴还不熟悉linux系统的操作，更不知道怎么办了。慌了手脚，求救网页标签都打开了好几个，还是不知道咋弄，于是小伙伴只好四下求救大佬。今天我就带大家一块干了。。 so 到了面对编码的时候了 大家还记得上次讲过的编码格式问题吧，这次就不是转成Ansy格式了，要在secureCRT把编码格式转成utf-8格式，为什么呢？因为默认的secureCRT命令行不是utf-8,也不是中文字符集，所以就要改一改。如果小伙伴用的是中文破解版的，点击菜单栏中选择里会话选项，英文为option,界面如下，在外观(appearance)那里的字符编码选择那选择utf-8 字体选择自己喜欢的，但是要中文字符集gb2312 OK啦，解决问题啦，就有如下对比 这样就顺顺利利地干了它了，哈哈，心里是不是很爽啊。如果大家对界面背景不满意同样可以调节，比如背景为黑色，命令前景为白色或黑客绿(瞎装逼色)，看图 如果小伙伴还弄不明白，那只能献上本人亲自为大家制作的动图了（不信你看不懂） 好啦，以上就是小码码的学习心得，希望对大家有帮助，喜欢的话就点赞，留言哦，哈哈。附小码码官方博客","categories":[{"name":"linux","slug":"linux","permalink":"https://hawkezou.github.io/categories/linux/"}],"tags":[{"name":"问题","slug":"问题","permalink":"https://hawkezou.github.io/tags/%E9%97%AE%E9%A2%98/"},{"name":"linux","slug":"linux","permalink":"https://hawkezou.github.io/tags/linux/"}]}],"categories":[{"name":"java","slug":"java","permalink":"https://hawkezou.github.io/categories/java/"},{"name":"mysql","slug":"mysql","permalink":"https://hawkezou.github.io/categories/mysql/"},{"name":"linux","slug":"linux","permalink":"https://hawkezou.github.io/categories/linux/"},{"name":"git","slug":"git","permalink":"https://hawkezou.github.io/categories/git/"},{"name":"docker","slug":"docker","permalink":"https://hawkezou.github.io/categories/docker/"},{"name":"虚拟机","slug":"虚拟机","permalink":"https://hawkezou.github.io/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"碎碎念","slug":"碎碎念","permalink":"https://hawkezou.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"},{"name":"Java","slug":"Java","permalink":"https://hawkezou.github.io/categories/Java/"},{"name":"SQL","slug":"SQL","permalink":"https://hawkezou.github.io/categories/SQL/"}],"tags":[{"name":"java","slug":"java","permalink":"https://hawkezou.github.io/tags/java/"},{"name":"类加载","slug":"类加载","permalink":"https://hawkezou.github.io/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD/"},{"name":"注解","slug":"注解","permalink":"https://hawkezou.github.io/tags/%E6%B3%A8%E8%A7%A3/"},{"name":"泛型","slug":"泛型","permalink":"https://hawkezou.github.io/tags/%E6%B3%9B%E5%9E%8B/"},{"name":"集合","slug":"集合","permalink":"https://hawkezou.github.io/tags/%E9%9B%86%E5%90%88/"},{"name":"工具类","slug":"工具类","permalink":"https://hawkezou.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"name":"构造器重载","slug":"构造器重载","permalink":"https://hawkezou.github.io/tags/%E6%9E%84%E9%80%A0%E5%99%A8%E9%87%8D%E8%BD%BD/"},{"name":"初始化块","slug":"初始化块","permalink":"https://hawkezou.github.io/tags/%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9D%97/"},{"name":"静态初始化块","slug":"静态初始化块","permalink":"https://hawkezou.github.io/tags/%E9%9D%99%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9D%97/"},{"name":"变量分类","slug":"变量分类","permalink":"https://hawkezou.github.io/tags/%E5%8F%98%E9%87%8F%E5%88%86%E7%B1%BB/"},{"name":"自动装拆箱","slug":"自动装拆箱","permalink":"https://hawkezou.github.io/tags/%E8%87%AA%E5%8A%A8%E8%A3%85%E6%8B%86%E7%AE%B1/"},{"name":"继承","slug":"继承","permalink":"https://hawkezou.github.io/tags/%E7%BB%A7%E6%89%BF/"},{"name":"组合","slug":"组合","permalink":"https://hawkezou.github.io/tags/%E7%BB%84%E5%90%88/"},{"name":"单例类","slug":"单例类","permalink":"https://hawkezou.github.io/tags/%E5%8D%95%E4%BE%8B%E7%B1%BB/"},{"name":"不可变类","slug":"不可变类","permalink":"https://hawkezou.github.io/tags/%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%B1%BB/"},{"name":"String","slug":"String","permalink":"https://hawkezou.github.io/tags/String/"},{"name":"BigDecimal","slug":"BigDecimal","permalink":"https://hawkezou.github.io/tags/BigDecimal/"},{"name":"SQLserver","slug":"SQLserver","permalink":"https://hawkezou.github.io/tags/SQLserver/"},{"name":"ubantu","slug":"ubantu","permalink":"https://hawkezou.github.io/tags/ubantu/"},{"name":"virtualbox虚拟机","slug":"virtualbox虚拟机","permalink":"https://hawkezou.github.io/tags/virtualbox%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"问题","slug":"问题","permalink":"https://hawkezou.github.io/tags/%E9%97%AE%E9%A2%98/"},{"name":"linux","slug":"linux","permalink":"https://hawkezou.github.io/tags/linux/"}]}